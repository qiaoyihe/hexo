<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java入门阶级,每个 Java 初学者都应该收藏 | 花绫子</title><meta name="author" content="花绫子"><meta name="copyright" content="花绫子"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 基础和 Java 面向对象编程">
<meta property="og:type" content="article">
<meta property="og:title" content="java入门阶级,每个 Java 初学者都应该收藏">
<meta property="og:url" content="https://www.yyisq.com/posts/53415/index.html">
<meta property="og:site_name" content="花绫子">
<meta property="og:description" content="Java 基础和 Java 面向对象编程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.yyisq.com/img/java.webp">
<meta property="article:published_time" content="2022-11-04T14:00:45.000Z">
<meta property="article:modified_time" content="2022-11-22T12:02:21.402Z">
<meta property="article:author" content="花绫子">
<meta property="article:tag" content="java">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.yyisq.com/img/java.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.yyisq.com/posts/53415/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="x_BXbbncv1Mh4RAEAhJTv1KJNtMw2Hjjkiam4vqXJFw"/><meta name="baidu-site-verification" content="code-wL0YtFZ1Km"/><link rel="manifest" href="/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/image/png"/><link rel="mask-icon" href="/image/png" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?89e220f4a193cbf12552f64350fa12b8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-MSVN4RXSMW"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-MSVN4RXSMW');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":30,"position":"top","messagePrev":"这篇文章已经发表了","messageNext":"天了，其中某些内容可能已经过时。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java入门阶级,每个 Java 初学者都应该收藏',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-22 20:02:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href=" /css/background.css"><link rel="stylesheet" href=" /css/icon.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="花绫子" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avtar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-fw fa fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> 小伙伴</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/mood/"><i class="fa-fw fas fa-heart"></i><span> 心情墙</span></a></li><li><a class="site-page child" href="/messageboard"><i class="fa-fw fa-fw fas fa-envelope"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-image"></i><span> My相册</span></a></li><li><a class="site-page child" href="/talking"><i class="fa-fw fa fa-commenting"></i><span> 公告</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-tags"></i><span> 待</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">花绫子</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-fw fa fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> 小伙伴</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/mood/"><i class="fa-fw fas fa-heart"></i><span> 心情墙</span></a></li><li><a class="site-page child" href="/messageboard"><i class="fa-fw fa-fw fas fa-envelope"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-image"></i><span> My相册</span></a></li><li><a class="site-page child" href="/talking"><i class="fa-fw fa fa-commenting"></i><span> 公告</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-tags"></i><span> 待</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">java入门阶级,每个 Java 初学者都应该收藏</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-04T14:00:45.000Z" title="发表于 2022-11-04 22:00:45">2022-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-22T12:02:21.402Z" title="更新于 2022-11-22 20:02:21">2022-11-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>89分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java入门阶级,每个 Java 初学者都应该收藏"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>这么说吧，在我眼里，Java 就是最流行的编程语言，没有之一（PHP 往一边站）。不仅岗位多，容易找到工作，关键是薪资水平也到位，不学 Java 亏得慌，对吧？<br>那可能零基础学编程的小伙伴就会头疼了，网上关于 Java 的大部分技术文章都不够幽默，不够风趣，不够系列，急需要一份能看得进去的学习手册，那我觉得我肝的这份手册正好符合要求，并且会一直持续更新下去。<br>第一版的内容暂时包含两方面，Java 基础和 Java 面向对象编程。来吧，先上目录，一睹为快。<br>01、Java 基本语法简介<br>02、Java 基本数据类型简介<br>03、Java main() 方法简介<br>04、Java 的流程控制语句<br>05、Java 包的简介<br>06、Java 到底是值传递还是引用传递<br>07、Java 的类和对象<br>08、Java 构造方法<br>09、Java 抽象类<br>10、Java 接口<br>11、Java 继承<br>12、this 关键字<br>13、super 关键字<br>14、重写和重载<br>15、static 关键字<br>16、Java 枚举<br>17、final 关键字<br>目录欣赏完了，接下来就是拜读精华内容的时间，搬个小板凳，认认真真好好学吧，学到就是赚到！</p>
<h1 id="一、Java-基本语法简介"><a href="#一、Java-基本语法简介" class="headerlink" title="一、Java 基本语法简介"></a>一、Java 基本语法简介</h1><h2 id="01、数据类型"><a href="#01、数据类型" class="headerlink" title="01、数据类型"></a>01、数据类型</h2><p>Java 有 2 种数据类型，一种是基本数据类型，一种是引用类型。<br>基本数据类型用于存储简单类型的数据，比如说，int、long、byte、short 用于存储整数，float、double 用于存储浮点数，char 用于存储字符，boolean 用于存储布尔值。<br>不同的基本数据类型，有不同的默认值和大小，来个表格感受下。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>false</td>
<td>1比特</td>
</tr>
<tr>
<td>char</td>
<td>0</td>
<td>2字节</td>
</tr>
<tr>
<td>byte</td>
<td>0</td>
<td>1字节</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
<td>2字节</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
<td>4字节</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
<td>8字节</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
<td>4字节</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
<td>8字节</td>
</tr>
</tbody></table>
<p>引用类型用于存储对象（null 表示没有值的对象）的引用，String 是引用类型的最佳代表，比如说 String cmower = “沉默王二”。</p>
<h2 id="02、声明变量"><a href="#02、声明变量" class="headerlink" title="02、声明变量"></a>02、声明变量</h2><p>要声明一个变量，必须指定它的名字和类型，来看一个简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int age;</span><br><span class="line">String name;</span><br></pre></td></tr></table></figure>
<p>count 和 name 在声明后会得到一个默认值，按照它们的数据类型——不能是局部变量（否则 Java 编译器会在你使用变量的时候提醒要先赋值），必须是类成员变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SyntaxLocalVariable &#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SyntaxLocalVariable syntax = new SyntaxLocalVariable();</span><br><span class="line">        System.out.println(syntax.age); // 输出 0</span><br><span class="line">        System.out.println(syntax.name);  // 输出 null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在声明一个变量后使用“=”操作符进行赋值，就像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int age = 18;</span><br><span class="line">String name = &quot;沉默王二&quot;;</span><br></pre></td></tr></table></figure>
<p>我们定义了 2 个变量，int 类型的 age 和 String 类型的 name，age 赋值 18，name 赋值为“沉默王二”。<br>每行代码后面都跟了一个“;”，表示当前语句结束了。<br>在 Java 中，变量最好遵守命名约定，这样能提高代码的可阅读性。</p>
<ul>
<li>以字母、下划线（_）或者美元符号（$）开头</li>
<li>不能使用 Java 的保留字，比如说 int 不能作为变量名</li>
</ul>
<h2 id="03、数组"><a href="#03、数组" class="headerlink" title="03、数组"></a>03、数组</h2><p>数组在 Java 中占据着重要的位置，它是很多集合类的底层实现。数组属于引用类型，它用来存储一系列指定类型的数据。<br>声明数组的一般语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] identiier = new type[length];</span><br></pre></td></tr></table></figure>
<p>type 可以是任意的基本数据类型或者引用类型。来看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ArraysDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int [] nums = new int[10];</span><br><span class="line">        nums[0] = 18;</span><br><span class="line">        nums[1] = 19;</span><br><span class="line">        System.out.println(nums[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组的索引从 0 开始，第一个元素的索引为 0，第二个元素的索引为 1。为什么要这样设计？感兴趣的话，你可以去探究一下。<br>通过变量名[索引]的方式可以访问数组指定索引处的元素，赋值或者取值是一样的。</p>
<h2 id="04、关键字"><a href="#04、关键字" class="headerlink" title="04、关键字"></a>04、关键字</h2><p>关键字属于保留字，在 Java 中具有特殊的含义，比如说 public、final、static、new 等等，它们不能用来作为变量名。为了便于你作为参照，我列举了 48 个常用的关键字，你可以瞅一瞅。</p>
<p>1： abstract： abstract 关键字用于声明抽象类——可以有抽象和非抽象方法。</p>
<p>2： boolean： boolean 关键字用于将变量声明为布尔值类型，它只有 true 和 false 两个值。</p>
<p>3： break： break 关键字用于中断循环或 switch 语句。</p>
<p>4： byte： byte 关键字用于声明一个可以容纳 8 个比特的变量。</p>
<p>5： case： case 关键字用于在 switch 语句中标记条件的值。</p>
<p>6： catch： catch 关键字用于捕获 try 语句中的异常。</p>
<p>7： char： char 关键字用于声明一个可以容纳无符号 16 位比特的 Unicode 字符的变量。</p>
<p>8： class： class 关键字用于声明一个类。</p>
<p>9： continue： continue 关键字用于继续下一个循环。它可以在指定条件下跳过其余代码。</p>
<p>10：default： default 关键字用于指定 switch 语句中除去 case 条件之外的默认代码块。</p>
<p>11：do： do 关键字通常和 while 关键字配合使用，do 后紧跟循环体。</p>
<p>12：double： double 关键字用于声明一个可以容纳 64 位浮点数的变量。</p>
<p>13：else： else 关键字用于指示 if 语句中的备用分支。</p>
<p>14：enum： enum（枚举）关键字用于定义一组固定的常量。</p>
<p>15：extends： extends 关键字用于指示一个类是从另一个类或接口继承的。</p>
<p>16：final： final 关键字用于指示该变量是不可更改的。</p>
<p>17：finally： finally 关键字和 try-catch 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</p>
<p>18：float： float 关键字用于声明一个可以容纳 32 位浮点数的变量。</p>
<p>19：for： for 关键字用于启动一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</p>
<p>20：if： if 关键字用于指定条件，如果条件为真，则执行对应代码。</p>
<p>21：implements： implements 关键字用于实现接口。</p>
<p>22：import： import 关键字用于导入对应的类或者接口。</p>
<p>23：instanceof： instanceof 关键字用于判断对象是否属于某个类型（class）。</p>
<p>24：int： int 关键字用于声明一个可以容纳 32 位带符号的整数变量。</p>
<p>25：interface： interface 关键字用于声明接口——只能具有抽象方法。</p>
<p>26：long： long 关键字用于声明一个可以容纳 64 位整数的变量。</p>
<p>27：native： native 关键字用于指定一个方法是通过调用本机接口（非 Java）实现的。</p>
<p>28：new： new 关键字用于创建一个新的对象。</p>
<p>29：null： 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null。</p>
<p>30：package： package 关键字用于声明类所在的包。</p>
<p>31：private： private 关键字是一个访问修饰符，表示方法或变量只对当前类可见。</p>
<p>32：protected： protected 关键字也是一个访问修饰符，表示方法或变量对同一包内的类和所有子类可见。</p>
<p>33：public： public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。</p>
<p>34：return： return 关键字用于在代码执行完成后返回（一个值）。</p>
<p>35：short： short 关键字用于声明一个可以容纳 16 位整数的变量。</p>
<p>36：static： static 关键字表示该变量或方法是静态变量或静态方法。</p>
<p>37：strictfp：  strictfp 关键字并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。</p>
<p>38：super： super 关键字可用于调用父类的方法或者变量。</p>
<p>39：switch： switch 关键字通常用于三个（以上）的条件判断。</p>
<p>40：synchronized： synchronized 关键字用于指定多线程代码中的同步方法、变量或者代码块。</p>
<p>41：this： this 关键字可用于在方法或构造函数中引用当前对象。</p>
<p>42：throw： throw 关键字主动抛出异常。</p>
<p>43：throws： throws 关键字用于声明异常。</p>
<p>44：transient： transient 关键字在序列化的使用用到，它修饰的字段不会被序列化。</p>
<p>45：try： try 关键字用于包裹要捕获异常的代码块。</p>
<p>46：void： void 关键字用于指定方法没有返回值。</p>
<p>47：volatile： volatile 关键字保证了不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>48：while： 如果循环次数不固定，建议使用 while 循环。<br><img src="https://www.qyihe.xyz/images/post/10.1.jpg"></p>
<h2 id="05、操作符"><a href="#05、操作符" class="headerlink" title="05、操作符"></a>05、操作符</h2><p>除去“=”赋值操作符，Java 中还有很多其他作用的操作符，我们来大致看一下。</p>
<h3 id="①、算术运算符"><a href="#①、算术运算符" class="headerlink" title="①、算术运算符"></a>①、算术运算符</h3><ul>
<li> +（加号）</li>
<li> –（减号）</li>
<li> *（乘号）</li>
<li> /（除号）</li>
<li> ％（取余）</li>
</ul>
<p>来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ArithmeticOperator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 10;</span><br><span class="line">        int b = 5;</span><br><span class="line">        </span><br><span class="line">        System.out.println(a + b);//15  </span><br><span class="line">        System.out.println(a - b);//5  </span><br><span class="line">        System.out.println(a * b);//50  </span><br><span class="line">        System.out.println(a / b);//2  </span><br><span class="line">        System.out.println(a % b);//0  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“+”号比较特殊，还可以用于字符串拼接，来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = &quot;沉默王二&quot; + &quot;一枚有趣的程序员&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="②、逻辑运算符"><a href="#②、逻辑运算符" class="headerlink" title="②、逻辑运算符"></a>②、逻辑运算符</h3><p>逻辑运算符通常用于布尔表达式，常见的有：</p>
<ul>
<li>&amp;&amp;（AND）多个条件中只要有一个为 false 结果就为 false</li>
<li>||（OR）多个条件只要有一个为 true 结果就为 true</li>
<li>!（NOT）条件如果为 true，加上“!”就为 false，否则，反之。</li>
</ul>
<p>来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class LogicalOperator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a=10;</span><br><span class="line">        int b=5;</span><br><span class="line">        int c=20;</span><br><span class="line">        System.out.println(a&lt;b&amp;&amp;a&lt;c);//false</span><br><span class="line">        System.out.println(a&gt;b||a&lt;c);//true</span><br><span class="line">        System.out.println(!(a&lt;b)); // true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="③、比较运算符"><a href="#③、比较运算符" class="headerlink" title="③、比较运算符"></a>③、比较运算符</h3><ul>
<li> &lt; (小于)</li>
<li> &lt;= (小于或者等于)</li>
<li><blockquote>
<p>(大于)</p>
</blockquote>
</li>
<li> &gt;= (大于或者等于)</li>
<li> == (相等)</li>
<li> != (不等)</li>
</ul>
<h2 id="06、程序结构"><a href="#06、程序结构" class="headerlink" title="06、程序结构"></a>06、程序结构</h2><p>Java 中最小的程序单元叫做类，一个类可以有一个或者多个字段（也叫作成员变量），还可以有一个或者多个方法，甚至还可以有一些内部类。<br>如果一个类想要执行，就必须有一个 main 方法——程序运行的入口，就好像人的嘴一样，嗯，可以这么牵强的理解一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class StructureProgram &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;没有成员变量，只有一个 main 方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类名叫做 StructureProgram，在它里面，只有一个 main 方法。</li>
<li>{} 之间的代码称之为代码块。</li>
<li>以上源代码将会保存在一个后缀名为 java 的文件中。</li>
</ul>
<h2 id="07、编译然后执行代码"><a href="#07、编译然后执行代码" class="headerlink" title="07、编译然后执行代码"></a>07、编译然后执行代码</h2><p>通常，一些教程在介绍这块内容的时候，建议你通过命令行中先执行 javac 命令将源代码编译成字节码文件，然后再执行 java 命令指定代码。<br>但我不希望这个糟糕的局面再继续下去了——新手安装配置 JDK 真的蛮需要勇气和耐心的，稍有不慎，没入门就先放弃了。况且，在命令行中编译源代码会遇到很多莫名其妙的错误，这对新手是极其致命的——如果你再遇到这种老式的教程，可以吐口水了。<br>好的方法，就是去下载 IntelliJ IDEA，简称 IDEA，它被业界公认为最好的 Java 集成开发工具，尤其在智能代码助手、代码自动提示、代码重构、代码版本管理(Git、SVN、Maven)、单元测试、代码分析等方面有着亮眼的发挥。IDEA 产于捷克（位于东欧），开发人员以严谨著称。IDEA 分为社区版和付费版两个版本，新手直接下载社区版就足够用了。<br>安装成功后，可以开始敲代码了，然后直接右键运行（连保存都省了），结果会在 Run 面板中显示，如下图所示。<br><img src="https://www.qyihe.xyz/images/post/10.2.jpg"><br>想查看反编译后的字节码的话，可以在 src 的同级目录 target/classes 的包路径下找到一个 StructureProgram.class 的文件（如果找不到的话，在目录上右键选择「Reload from Disk」）。<br>可以双击打开它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">// (powered by Fernflower decompiler)</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">package com.cmower.baeldung.basic;</span><br><span class="line"></span><br><span class="line">public class StructureProgram &#123;</span><br><span class="line">    public StructureProgram() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;没有成员变量，只有一个 main 方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDEA 默认会用 Fernflower 将 class 字节码反编译为我们可以看得懂的 Java 代码。实际上，class 字节码（请安装 show bytecode 插件）长下面这个样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// class version 57.65535 (-65479)</span><br><span class="line">// access flags 0x21</span><br><span class="line">public class com/cmower/baeldung/basic/StructureProgram &#123;</span><br><span class="line"></span><br><span class="line">  // compiled from: StructureProgram.java</span><br><span class="line"></span><br><span class="line">  // access flags 0x1</span><br><span class="line">  public &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER 3 L0</span><br><span class="line">    ALOAD 0</span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE this Lcom/cmower/baeldung/basic/StructureProgram; L0 L1 0</span><br><span class="line">    MAXSTACK = 1</span><br><span class="line">    MAXLOCALS = 1</span><br><span class="line"></span><br><span class="line">  // access flags 0x9</span><br><span class="line">  public static main([Ljava/lang/String;)V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER 5 L0</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC &quot;\u6ca1\u6709\u6210\u5458\u53d8\u91cf\uff0c\u53ea\u6709\u4e00\u4e2a main \u65b9\u6cd5&quot;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER 6 L1</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE args [Ljava/lang/String; L0 L2 0</span><br><span class="line">    MAXSTACK = 2</span><br><span class="line">    MAXLOCALS = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新手看起来还是有些懵逼的，建议过过眼瘾就行了。<br><img src="https://www.qyihe.xyz/images/post/10.3.jpg"></p>
<h1 id="二、Java-基本数据类型简介"><a href="#二、Java-基本数据类型简介" class="headerlink" title="二、Java 基本数据类型简介"></a>二、Java 基本数据类型简介</h1><h2 id="01、布尔"><a href="#01、布尔" class="headerlink" title="01、布尔"></a>01、布尔</h2><p>布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean flag = true;</span><br></pre></td></tr></table></figure>
<h2 id="02、byte"><a href="#02、byte" class="headerlink" title="02、byte"></a>02、byte</h2><p>byte 的取值范围在 -128 和 127 之间，包含 127。最小值为 -128，最大值为 127，默认值为 0。<br>在网络传输的过程中，为了节省空间，常用字节来作为数据的传输方式。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte a = 10;</span><br><span class="line">byte b = -10;</span><br></pre></td></tr></table></figure>
<h2 id="03、short"><a href="#03、short" class="headerlink" title="03、short"></a>03、short</h2><p>short 的取值范围在 -32,768 和 32,767 之间，包含 32,767。最小值为 -32,768，最大值为 32,767，默认值为 0。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short s = 10000;</span><br><span class="line">short r = -5000;</span><br></pre></td></tr></table></figure>
<h2 id="04、int"><a href="#04、int" class="headerlink" title="04、int"></a>04、int</h2><p>int 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间，默认值为 0。如果没有特殊需求，整形数据就用 int。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 100000;</span><br><span class="line">int b = -200000;</span><br></pre></td></tr></table></figure>
<h2 id="05、long"><a href="#05、long" class="headerlink" title="05、long"></a>05、long</h2><p>long 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间，默认值为 0。如果 int 存储不下，就用 long，整形数据就用 int。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long a = 100000L; </span><br><span class="line">long b = -200000L;</span><br></pre></td></tr></table></figure>
<p>为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。</p>
<h2 id="06、float"><a href="#06、float" class="headerlink" title="06、float"></a>06、float</h2><p>float 是单精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围是无限的，默认值为 0.0f。float 不适合用于精确的数值，比如说货币。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float f1 = 234.5f;</span><br></pre></td></tr></table></figure>
<p>为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。</p>
<h2 id="07、double"><a href="#07、double" class="headerlink" title="07、double"></a>07、double</h2><p>double 是双精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围也是无限的，默认值为 0.0。double 同样不适合用于精确的数值，比如说货币。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double d1 = 12.3</span><br></pre></td></tr></table></figure>
<p>那精确的数值用什么表示呢？最好使用 BigDecimal，它可以表示一个任意大小且精度完全准确的浮点数。针对货币类型的数值，也可以先乘以 100 转成整形进行处理。<br>Tips：单精度是这样的格式，1 位符号，8 位指数，23 位小数，有效位数为 7 位。<br><img src="https://www.qyihe.xyz/images/post/10.4.jpg"><br>双精度是这样的格式，1 位符号，11 位指数，52 为小数，有效位数为 16 位。<br><img src="https://www.qyihe.xyz/images/post/10.5.jpg"><br>取值范围取决于指数位，计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。</p>
<blockquote>
<p>一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。</p>
</blockquote>
<h2 id="08、char"><a href="#08、char" class="headerlink" title="08、char"></a>08、char</h2><p>char 可以表示一个 16 位的 Unicode 字符，其值范围在 ‘\u0000’（0）和 ‘\uffff’（65,535）（包含）之间。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char letterA = &#x27;A&#x27;; // 用英文的单引号包裹住。</span><br></pre></td></tr></table></figure>
<h1 id="三、Java-main-方法简介"><a href="#三、Java-main-方法简介" class="headerlink" title="三、Java main() 方法简介"></a>三、Java main() 方法简介</h1><p>每个程序都需要一个入口，对于 Java 程序来说，入口就是 main 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>public、static、void 这 3 个关键字在前面的内容已·经介绍过了，如果觉得回去找比较麻烦的话，这里再贴一下：</p>
</li>
<li><p>public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。</p>
</li>
<li><p>static 关键字表示该变量或方法是静态变量或静态方法，可以直接通过类访问，不需要实例化对象来访问。</p>
</li>
<li><p>void 关键字用于指定方法没有返回值。</p>
</li>
</ul>
<p>另外，main 关键字为方法的名字，Java 虚拟机在执行程序时会寻找这个标识符；args 为 main() 方法的参数名，它的类型为一个 String 数组，也就是说，在使用 java 命令执行程序的时候，可以给 main() 方法传递字符串数组作为参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloWorld 沉默王二 沉默王三</span><br></pre></td></tr></table></figure>
<p>javac 命令用来编译程序，java 命令用来执行程序，HelloWorld 为这段程序的类名，沉默王二和沉默王三为字符串数组，中间通过空格隔开，然后就可以在 main() 方法中通过 args[0] 和 args[1] 获取传递的参数值了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        if (&quot;沉默王二&quot;.equals(args[0])) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (&quot;沉默王三&quot;.equals(args[1])) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main() 方法的写法并不是唯一的，还有其他几种变体，尽管它们可能并不常见，可以简单来了解一下。</p>
<p>第二种，把方括号 [] 往 args 靠近而不是 String 靠近：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String []args) &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种，把方括号 [] 放在 args 的右侧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四种，还可以把数组形式换成可变参数的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String...args) &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第五种，在 main() 方法上添加另外一个修饰符 strictfp，用于强调在处理浮点数时的兼容性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public strictfp static void main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在 main() 方法上添加 final 关键字或者 synchronized 关键字。</p>
<p>第六种，还可以为 args 参数添加 final 关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(final String[] args) &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第七种，最复杂的一种，所有可以添加的关键字统统添加上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final static synchronized strictfp void main(final String[] args) &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，并不需要为了装逼特意把 main() 方法写成上面提到的这些形式，使用 IDE 提供的默认形式就可以了。</p>
<h1 id="四、Java-的流程控制语句"><a href="#四、Java-的流程控制语句" class="headerlink" title="四、Java 的流程控制语句"></a>四、Java 的流程控制语句</h1><ul>
<li><p>在 Java 中，有三种类型的流程控制语句：</p>
</li>
<li><p>条件分支，用于在两个或者多个条件之间做出选择，常见的有 if/else/else if、三元运算符和 switch 语句。</p>
</li>
<li><p>循环或者遍历，常见的有 for、while 和 do-while。</p>
</li>
<li><p>break 和 continue，用于跳出循环或者跳过进入下一轮循环。</p>
</li>
</ul>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>if 语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式)&#123;  </span><br><span class="line">// 如果条件为 true，则执行这块代码</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：<br><img src="https://www.qyihe.xyz/images/post/10.6.jpg"><br>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class IfExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age = 20;</span><br><span class="line">        if (age &lt; 30) &#123;</span><br><span class="line">            System.out.println(&quot;青春年华&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">青春年华</span><br></pre></td></tr></table></figure>
<h2 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a>if-else 语句</h2><p>if-else 语句的格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式)&#123;  </span><br><span class="line">// 条件为 true 时执行的代码块</span><br><span class="line">&#125;else&#123;  </span><br><span class="line">// 条件为 false  时执行的代码块</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：<br><img src="https://www.qyihe.xyz/images/post/10.7.jpg"><br>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class IfElseExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age = 31;</span><br><span class="line">        if (age &lt; 30) &#123;</span><br><span class="line">            System.out.println(&quot;青春年华&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;而立之年&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而立之年</span><br></pre></td></tr></table></figure>
<p>除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class LeapYear &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int year = 2020;</span><br><span class="line">        if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &#123;</span><br><span class="line">            System.out.println(&quot;闰年&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;普通年份&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">闰年</span><br></pre></td></tr></table></figure>
<p>如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class IfElseTernaryExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int num = 13;</span><br><span class="line">        String result = (num % 2 == 0) ? &quot;偶数&quot; : &quot;奇数&quot;;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇数</span><br></pre></td></tr></table></figure>
<h2 id="if-else-if-语句"><a href="#if-else-if-语句" class="headerlink" title="if-else-if 语句"></a>if-else-if 语句</h2><p>if-else-if 语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(条件1)&#123;  </span><br><span class="line">// 条件1 为 true 时执行的代码</span><br><span class="line">&#125;else if(条件2)&#123;  </span><br><span class="line">// 条件2 为 true 时执行的代码</span><br><span class="line">&#125;  </span><br><span class="line">else if(条件3)&#123;  </span><br><span class="line">// 条件3 为 true 时执行的代码</span><br><span class="line">&#125;  </span><br><span class="line">...  </span><br><span class="line">else&#123;  </span><br><span class="line">// 以上条件均为 false 时执行的代码</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：<br><img src="https://www.qyihe.xyz/images/post/10.8.jpg"><br>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class IfElseIfExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age = 31;</span><br><span class="line">        if (age &lt; 30) &#123;</span><br><span class="line">            System.out.println(&quot;青春年华&quot;);</span><br><span class="line">        &#125; else if (age &gt;= 30 &amp;&amp; age &lt; 40 ) &#123;</span><br><span class="line">            System.out.println(&quot;而立之年&quot;);</span><br><span class="line">        &#125; else if (age &gt;= 40 &amp;&amp; age &lt; 50 ) &#123;</span><br><span class="line">            System.out.println(&quot;不惑之年&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;知天命&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而立之年</span><br></pre></td></tr></table></figure>
<h2 id="if-嵌套语句"><a href="#if-嵌套语句" class="headerlink" title="if 嵌套语句"></a>if 嵌套语句</h2><p>if 嵌套语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(外侧条件)&#123;    </span><br><span class="line">     // 外侧条件为 true 时执行的代码 </span><br><span class="line">          if(内侧条件)&#123;  </span><br><span class="line">             // 内侧条件为 true 时执行的代码</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：<br><img src="https://www.qyihe.xyz/images/post/10.9.jpg"><br>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class NestedIfExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age = 20;</span><br><span class="line">        boolean isGirl = true;</span><br><span class="line">        if (age &gt;= 20) &#123;</span><br><span class="line">            if (isGirl) &#123;</span><br><span class="line">                System.out.println(&quot;女生法定结婚年龄&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">女生法定结婚年龄</span><br></pre></td></tr></table></figure>
<h2 id="switch-语句的格式："><a href="#switch-语句的格式：" class="headerlink" title="switch 语句的格式："></a>switch 语句的格式：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch(变量) &#123;    </span><br><span class="line">case 可选值1:    </span><br><span class="line"> // 可选值1匹配后执行的代码;    </span><br><span class="line"> break;  // 该关键字是可选项</span><br><span class="line">case 可选值2:    </span><br><span class="line"> // 可选值2匹配后执行的代码;    </span><br><span class="line"> break;  // 该关键字是可选项</span><br><span class="line">......    </span><br><span class="line">    </span><br><span class="line">default: // 该关键字是可选项     </span><br><span class="line"> // 所有可选值都不匹配后执行的代码 </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<ul>
<li><p>变量可以有 1 个或者 N 个值。</p>
</li>
<li><p>值类型必须和变量类型是一致的，并且值是确定的。</p>
</li>
<li><p>值必须是唯一的，不能重复，否则编译会出错。</p>
</li>
<li><p>break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。</p>
</li>
<li><p>default 关键字也是可选的。<br><img src="https://www.qyihe.xyz/images/post/10.10.jpg"><br>画个流程图：</p>
</li>
</ul>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Switch1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age = 20;</span><br><span class="line">        switch (age) &#123;</span><br><span class="line">            case 20 :</span><br><span class="line">                System.out.println(&quot;上学&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 24 :</span><br><span class="line">                System.out.println(&quot;苏州工作&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 30 :</span><br><span class="line">                System.out.println(&quot;洛阳工作&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;未知&quot;);</span><br><span class="line">                break; // 可省略</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上学</span><br></pre></td></tr></table></figure>
<p>当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Switch2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String name = &quot;沉默王二&quot;;</span><br><span class="line">        switch (name) &#123;</span><br><span class="line">            case &quot;詹姆斯&quot;:</span><br><span class="line">                System.out.println(&quot;篮球运动员&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;穆里尼奥&quot;:</span><br><span class="line">                System.out.println(&quot;足球教练&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;沉默王二&quot;:</span><br><span class="line">            case &quot;沉默王三&quot;:</span><br><span class="line">                System.out.println(&quot;乒乓球爱好者&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                        &quot;名字没有匹配项&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">乒乓球爱好者</span><br></pre></td></tr></table></figure>
<p>枚举作为 switch 语句的变量也很常见，来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SwitchEnumDemo &#123;</span><br><span class="line">    public enum PlayerTypes &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL,</span><br><span class="line">        UNKNOWN</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(createPlayer(PlayerTypes.BASKETBALL));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String createPlayer(PlayerTypes playerType) &#123;</span><br><span class="line">        switch (playerType) &#123;</span><br><span class="line">            case TENNIS:</span><br><span class="line">                return &quot;网球运动员费德勒&quot;;</span><br><span class="line">            case FOOTBALL:</span><br><span class="line">                return &quot;足球运动员C罗&quot;;</span><br><span class="line">            case BASKETBALL:</span><br><span class="line">                return &quot;篮球运动员詹姆斯&quot;;</span><br><span class="line">            case UNKNOWN:</span><br><span class="line">                throw new IllegalArgumentException(&quot;未知&quot;);</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                        &quot;运动员类型: &quot; + playerType);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">篮球运动员詹姆斯</span><br></pre></td></tr></table></figure>
<h2 id="循环语句比较"><a href="#循环语句比较" class="headerlink" title="循环语句比较"></a>循环语句比较</h2><table>
<thead>
<tr>
<th>比较方式</th>
<th>for</th>
<th>while</th>
<th>do-while</th>
</tr>
</thead>
<tbody><tr>
<td>简介</td>
<td>for 循环的次数是固定的</td>
<td>while 循环的次数是不固定的，并且需要条件为 true</td>
<td>do-while 循环的次数也不固定，但会至少执行一次循环，无聊条件是否为 true</td>
</tr>
<tr>
<td>何时使用</td>
<td>循环次数固定的</td>
<td>循环次数是不固定的</td>
<td>循环次数不固定，并且循环体至少要执行一次</td>
</tr>
<tr>
<td>语法</td>
<td>for(init:condition;++/–) {// 要执行的代码}</td>
<td>while(condition){// 要执行的代码}</td>
<td>do{//要执行的代码}while(condition);</td>
</tr>
</tbody></table>
<h2 id="普通的-for-循环"><a href="#普通的-for-循环" class="headerlink" title="普通的 for 循环"></a>普通的 for 循环</h2><p>普通的 for 循环可以分为 4 个部分：<br>（1）初始变量：循环开始执行时的初始条件。<br>（2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。<br>（3）循环体：循环每次要执行的代码块，直到条件变为 false。<br>（4）自增/自减：初识变量变化的方式。<br>来看一下普通 for 循环的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(初识变量;条件;自增/自减)&#123;  </span><br><span class="line">// 循环体</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>画个流程图：<br><img src="https://www.qyihe.xyz/images/post/10.11.jpg"><br>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ForExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            System.out.println(&quot;沉默王二好帅啊&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉默王二好帅啊</span><br><span class="line">沉默王二好帅啊</span><br><span class="line">沉默王二好帅啊</span><br><span class="line">沉默王二好帅啊</span><br><span class="line">沉默王二好帅啊</span><br></pre></td></tr></table></figure>
<p>循环语句还可以嵌套呢，这样就可以打印出更好玩的呢。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class PyramidForExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            for (int j = 0;j&lt;= i;j++) &#123;</span><br><span class="line">                System.out.print(&quot;❤&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出什么玩意呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❤</span><br><span class="line">❤❤</span><br><span class="line">❤❤❤</span><br><span class="line">❤❤❤❤</span><br><span class="line">❤❤❤❤❤</span><br></pre></td></tr></table></figure>
<h2 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h2><p>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型 元素 : 数组或集合)&#123;  </span><br><span class="line">// 要执行的代码</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>来看一下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ForEachExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] strs = &#123;&quot;沉默王二&quot;, &quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        for (String str : strs) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">沉默王二</span><br><span class="line">一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<h2 id="无限-for-循环"><a href="#无限-for-循环" class="headerlink" title="无限 for 循环"></a>无限 for 循环</h2><p>想不想体验一下无限 for 循环的威力，也就是死循环？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class InfinitiveForExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">            System.out.println(&quot;停不下来。。。。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>
<p>一旦运行起来，就停不下来了，除非强制停止。</p>
<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(条件)&#123;  </span><br><span class="line">//循环体  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>画个流程图：<br><img src="https://www.qyihe.xyz/images/post/10.12.jpg"><br>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WhileExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">            if (i == 5) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>猜猜会输出几次？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉默王二</span><br><span class="line">沉默王二</span><br><span class="line">沉默王二</span><br><span class="line">沉默王二</span><br><span class="line">沉默王二</span><br></pre></td></tr></table></figure>
<h2 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;  </span><br><span class="line">// 循环体</span><br><span class="line">&#125;while(提交); </span><br></pre></td></tr></table></figure>
<p>画个流程图：<br><img src="https://www.qyihe.xyz/images/post/10.13.jpg"><br>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DoWhileExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            System.out.println(&quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">            if (i == 5) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉默王二</span><br><span class="line">沉默王二</span><br><span class="line">沉默王二</span><br><span class="line">沉默王二</span><br><span class="line">沉默王二</span><br></pre></td></tr></table></figure>
<h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>break 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。<br>可以将 break 关键字用于所有类型循环语句中，比如说 for 循环，while 循环，以及 do-while 循环。<br>来画个流程图感受一下：<br><img src="https://www.qyihe.xyz/images/post/10.14.jpg"><br>用在 for 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用在嵌套 for 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt;= 3; j++) &#123;</span><br><span class="line">        if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i + &quot; &quot; + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用在 while 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">while (i &lt;= 10) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用在 do-while 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int j = 1;</span><br><span class="line">do &#123;</span><br><span class="line">    if (j == 5) &#123; </span><br><span class="line">        j++;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    j++;</span><br><span class="line">&#125; while (j &lt;= 10);</span><br></pre></td></tr></table></figure>
<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。<br>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ContinueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">            if (i == 5) &#123;</span><br><span class="line">                // 使用 continue 关键字</span><br><span class="line">                continue;// 5 将会被跳过</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>5 真的被跳过了。<br>再来个循环嵌套的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ContinueInnerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= 3; j++) &#123;</span><br><span class="line">                if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class="line">                    //  当i=2，j=2时跳过</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i + &quot; &quot; + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出什么玩意呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<p>“2 2” 没有输出，被跳过了。<br>再来看一下 while 循环时 continue 的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ContinueWhileDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while (i &lt;= 10) &#123;</span><br><span class="line">            if (i == 5) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。<br>最后，再来看一下 do-while 循环时 continue 的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ContinueDoWhileDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i=1;</span><br><span class="line">        do&#123;</span><br><span class="line">            if(i==5)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;while(i&lt;=10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p>
<h1 id="五、Java-包的简介"><a href="#五、Java-包的简介" class="headerlink" title="五、Java 包的简介"></a>五、Java 包的简介</h1><p>在 Java 中，我们使用 package（包）对相关的类、接口和子包进行分组。这样做的好处有：</p>
<ul>
<li>使相关类型更容易查找</li>
<li>避免命名冲突，比如说 com.itwanger.Hello 和 com.itwangsan.Hello 不同</li>
<li>通过包和访问权限控制符来限定类的可见性</li>
</ul>
<h2 id="01、创建一个包"><a href="#01、创建一个包" class="headerlink" title="01、创建一个包"></a>01、创建一个包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.itwanger;</span><br></pre></td></tr></table></figure>
<p>可以使用 package 关键字来定义一个包名，需要注意的是，这行代码必须处于一个类中的第一行。强烈建议在包中声明类，不要缺省，否则就失去了包结构的带来的好处。<br>包的命名应该遵守以下规则：</p>
<ul>
<li>应该全部是小写字母</li>
<li>可以包含多个单词，单词之间使用“.”连接，比如说 java.lang</li>
<li>名称由公司名或者组织名确定，采用倒序的方式，比如说，我个人博客的域名是 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.itwanger.com,所以我创建的包名是就是/">www.itwanger.com，所以我创建的包名是就是</a> com.itwanger.xxxx。</li>
</ul>
<p>每个包或者子包都在磁盘上有自己的目录结构，如果 Java 文件时在 com.itwanger.xxxx 包下，那么该文件所在的目录结构就应该是 com-&gt;itwanger-&gt;xxxx。</p>
<h2 id="02、使用包"><a href="#02、使用包" class="headerlink" title="02、使用包"></a>02、使用包</h2><p>让我们在名为 test 的子包里新建一个 Cmower 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.itwanger.test;</span><br><span class="line"></span><br><span class="line">public class Cmower &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要在另外一个包中使用 Cmower 类，就需要通过 import 关键字将其引入。有两种方式可供选择，第一种，使用 * 导入包下所有的类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import com.itwanger.test.*;</span><br></pre></td></tr></table></figure>
<p>第二种，使用类名导入该类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import com.itwanger.test.Cmower;</span><br></pre></td></tr></table></figure>
<p>Java 和第三方类库提供了很多包可供使用，可以通过上述的方式导入类库使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.itwanger.test;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class CmowerTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Cmower&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(new Cmower());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="03、全名"><a href="#03、全名" class="headerlink" title="03、全名"></a>03、全名</h2><p>有时，我们可能会使用来自不同包下的两个具有相同名称的类。例如，我们可能同时使用 java.sql.Date 和 java.util.Date。当我们遇到命名冲突时，我们需要对至少一个类使用全名（包名+类名）。</p>
<figure class="highlight plaintext"><figcaption><span>list1 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(new com.itwanger.test.Cmower());</span><br></pre></td></tr></table></figure>
<h1 id="六、Java-到底是值传递还是引用传递"><a href="#六、Java-到底是值传递还是引用传递" class="headerlink" title="六、Java 到底是值传递还是引用传递"></a>六、Java 到底是值传递还是引用传递</h1><p>将参数传递给方法有两种常见的方式，一种是“值传递”，一种是“引用传递”。C 语言本身只支持值传递，它的衍生品 C++ 既支持值传递，也支持引用传递，而 Java 只支持值传递。</p>
<h2 id="01、值传递-VS-引用传递"><a href="#01、值传递-VS-引用传递" class="headerlink" title="01、值传递 VS 引用传递"></a>01、值传递 VS 引用传递</h2><p>首先，我们必须要搞清楚，到底什么是值传递，什么是引用传递，否则，讨论 Java 到底是值传递还是引用传递就显得毫无意义。<br>当一个参数按照值的方式在两个方法之间传递时，调用者和被调用者其实是用的两个不同的变量——被调用者中的变量（原始值）是调用者中变量的一份拷贝，对它们当中的任何一个变量修改都不会影响到另外一个变量。<br>而当一个参数按照引用传递的方式在两个方法之间传递时，调用者和被调用者其实用的是同一个变量，当该变量被修改时，双方都是可见的。<br>Java 程序员之所以容易搞混值传递和引用传递，主要是因为 Java 有两种数据类型，一种是基本类型，比如说 int，另外一种是引用类型，比如说 String。<br>基本类型的变量存储的都是实际的值，而引用类型的变量存储的是对象的引用——指向了对象在内存中的地址。值和引用存储在 stack（栈）中，而对象存储在 heap（堆）中。<br><img src="https://www.qyihe.xyz/images/post/10.15.jpg"><br>之所以有这个区别，是因为：</p>
<ul>
<li>栈的优势是，存取速度比堆要快，仅次于直接位于 CPU 中的寄存器。但缺点是，栈中的数据大小与生存周期必须是确定的。</li>
<li>堆的优势是可以动态地分配内存大小，生存周期也不必事先告诉编译器，Java 的垃圾回收器会自动收走那些不再使用的数据。但由于要在运行时动态分配内存，存取速度较慢。</li>
</ul>
<h2 id="02、基本类型的参数传递"><a href="#02、基本类型的参数传递" class="headerlink" title="02、基本类型的参数传递"></a>02、基本类型的参数传递</h2><p>众所周知，Java 有 8 种基本数据类型，分别是 int、long、byte、short、float、double 、char 和 boolean。它们的值直接存储在栈中，每当作为参数传递时，都会将原始值（实参）复制一份新的出来，给形参用。形参将会在被调用方法结束时从栈中清除。<br>来看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PrimitiveTypeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age = 18;</span><br><span class="line">        modify(age);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void modify(int age1) &#123;</span><br><span class="line">        age1 = 30;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）main 方法中的 age 是基本类型，所以它的值 18 直接存储在栈中。<br>（2）调用 modify() 方法的时候，将为实参 age 创建一个副本（形参 age1），它的值也为 18，不过是在栈中的其他位置。<br>（3）对形参 age 的任何修改都只会影响它自身而不会影响实参。<br><img src="https://www.qyihe.xyz/images/post/10.16.jpg"></p>
<h2 id="03、引用类型的参数传递"><a href="#03、引用类型的参数传递" class="headerlink" title="03、引用类型的参数传递"></a>03、引用类型的参数传递</h2><p>来看一段创建引用类型变量的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = new Writer(18, &quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>
<p>writer 是对象吗？还是对象的引用？为了搞清楚这个问题，我们可以把上面的代码拆分为两行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Writer writer;</span><br><span class="line">writer = new Writer(18, &quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>
<p>假如 writer 是对象的话，就不需要通过 new 关键字创建对象了，对吧？那也就是说，writer 并不是对象，在“=”操作符执行之前，它仅仅是一个变量。那谁是对象呢？new Writer(18, “沉默王二”)，它是对象，存储于堆中；然后，“=”操作符将对象的引用赋值给了 writer 变量，于是 writer 此时应该叫对象引用，它存储在栈中，保存了对象在堆中的地址。<br>每当引用类型作为参数传递时，都会创建一个对象引用（实参）的副本（形参），该形参保存的地址和实参一样。<br>来看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceTypeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Writer a = new Writer(18);</span><br><span class="line">        Writer b = new Writer(18);</span><br><span class="line">        modify(a, b);</span><br><span class="line"></span><br><span class="line">        System.out.println(a.getAge());</span><br><span class="line">        System.out.println(b.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void modify(Writer a1, Writer b1) &#123;</span><br><span class="line">        a1.setAge(30);</span><br><span class="line"></span><br><span class="line">        b1 = new Writer(18);</span><br><span class="line">        b1.setAge(30);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）在调用 modify() 方法之前，实参 a 和 b 指向的对象是不一样的，尽管 age 都为 18。<br><img src="https://www.qyihe.xyz/images/post/10.17.jpg"><br>（2）在调用 modify() 方法时，实参 a 和 b 都在栈中创建了一个新的副本，分别是 a1 和 b1，但指向的对象是一致的（a 和 a1 指向对象 a，b 和 b1 指向对象 b）。<br><img src="https://www.qyihe.xyz/images/post/10.18.jpg"><br>（3）在 modify() 方法中，修改了形参 a1 的 age 为 30，意味着对象 a 的 age 从 18 变成了 30，而实参 a 指向的也是对象 a，所以 a 的 age 也变成了 30；形参 b1 指向了一个新的对象，随后 b1 的 age 被修改为 30。<br><img src="https://www.qyihe.xyz/images/post/10.19.jpg"><br>修改 a1 的 age，意味着同时修改了 a 的 age，因为它们指向的对象是一个；修改 b1 的 age，对 b 却没有影响，因为它们指向的对象是两个。<br>程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30</span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<p>果然和我们的分析是吻合的。</p>
<h1 id="七、Java-的类和对象"><a href="#七、Java-的类和对象" class="headerlink" title="七、Java 的类和对象"></a>七、Java 的类和对象</h1><p>类和对象是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。对象可以是现实中看得见的任何物体（一只特立独行的猪），也可以是想象中的任何虚拟物体（能七十二变的孙悟空），Java 通过类（class）来定义这些物体，有什么状态（通过字段，或者叫成员变量定义，比如说猪的颜色是纯色还是花色），有什么行为（通过方法定义，比如说猪会吃，会睡觉）。<br>来，让我来定义一个简单的类给你看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，每个 Java 类都会有一个空的构造方法，尽管它在源代码中是缺省的，但却可以通过反编译字节码看到它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public Pig() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，就是多出来的那个 public Pig() {}，参数是空的，方法体是空的。我们可以通过 new 关键字利用这个构造方法来创建一个对象，代码如下所示：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pig pig = new Pig();</span><br></pre></td></tr></table></figure><br>当然了，我们也可以主动添加带参的构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public Pig(String color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，再查看反编译后的字节码时，你会发现缺省的无参构造方法消失了——和源代码一模一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public Pig(String color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着无法通过 new Pig() 来创建对象了——编译器会提醒你追加参数。<br><img src="https://www.qyihe.xyz/images/post/10.20.jpg"><br>比如说你将代码修改为 new Pig(“纯白色”)，或者添加无参的构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public Pig(String color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Pig() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用无参构造方法创建的对象状态默认值为 null（color 字符串为引用类型），如果是基本类型的话，默认值为对应基本类型的默认值，比如说 int 为 0，更详细的见下图。<br><img src="https://www.qyihe.xyz/images/post/10.21.jpg"><br>（图片中有一处错误，boolean 的默认值为 false）<br>接下来，我们来创建多个 Pig 对象，它的颜色各不相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PigTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pig pigNoColor = new Pig();</span><br><span class="line">        Pig pigWhite = new Pig(&quot;纯白色&quot;);</span><br><span class="line">        Pig pigBlack = new Pig(&quot;纯黑色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看，我们创建了 3 个不同花色的 Pig 对象，全部来自于一个类，由此可见类的重要性，只需要定义一次，就可以多次使用。<br>那假如我想改变对象的状态呢？该怎么办？目前毫无办法，因为没有任何可以更改状态的方法，直接修改 color 是行不通的，因为它的访问权限修饰符是 private 的。<br>最好的办法就是为 Pig 类追加 getter/setter 方法，就像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String getColor() &#123;</span><br><span class="line">    return color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setColor(String color) &#123;</span><br><span class="line">    this.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 setColor() 方法来修改，通过 getColor() 方法获取状态，它们的权限修饰符是 public 的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pig pigNoColor = new Pig();</span><br><span class="line">pigNoColor.setColor(&quot;花色&quot;);</span><br><span class="line">System.out.println(pigNoColor.getColor()); // 花色</span><br></pre></td></tr></table></figure>
<p>为什么要这样设计呢？可以直接将 color 字段的访问权限修饰符换成是 public 的啊，不就和 getter/setter 一样的效果了吗？<br>因为有些情况，某些字段是不允许被随意修改的，它只有在对象创建的时候初始化一次，比如说猪的年龄，它只能每年长一岁（举个例子），没有月光宝盒让它变回去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private int age;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">    return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void increaseAge() &#123;</span><br><span class="line">    this.age++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看，age 就没有 setter 方法，只有一个每年可以调用一次的 increaseAge() 方法和 getter 方法。如果把 age 的访问权限修饰符更改为 public，age 就完全失去控制了，可以随意将其重置为 0 或者负数。<br>访问权限修饰符对于 Java 来说，非常重要，目前共有四种：public、private、protected 和 default（缺省）。<br>一个类只能使用 public 或者 default 修饰，public 修饰的类你之前已经见到过了，现在我来定义一个缺省权限修饰符的类给你欣赏一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈哈，其实也没啥可以欣赏的。缺省意味着这个类可以被同一个包下的其他类进行访问；而 public 意味着这个类可以被所有包下的类进行访问。<br>假如硬要通过 private 和 protected 来修饰类的话，编译器会生气的，它不同意。<br><img src="https://www.qyihe.xyz/images/post/10.22.jpg"><br>private 可以用来修饰类的构造方法、字段和方法，只能被当前类进行访问。protected 也可以用来修饰类的构造方法、字段和方法，但它的权限范围更宽一些，可以被同一个包中的类进行访问，或者当前类的子类。<br>可以通过下面这张图来对比一下四个权限修饰符之间的差别：<br><img src="https://www.qyihe.xyz/images/post/10.23.jpg"></p>
<ul>
<li><p>同一个类中，不管是哪种权限修饰符，都可以访问；</p>
</li>
<li><p>同一个包下，private 修饰的无法访问；</p>
</li>
<li><p>子类可以访问 public 和 protected 修饰的；</p>
</li>
<li><p>public 修饰符面向世界，哈哈，可以被所有的地方访问到。<br><img src="https://www.qyihe.xyz/images/post/10.24.jpg"></p>
<h1 id="八、Java-构造方法"><a href="#八、Java-构造方法" class="headerlink" title="八、Java 构造方法"></a>八、Java 构造方法</h1><p>假设现在有一个 Writer 类，它有两个字段，姓名和年纪：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Writer&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写了 toString() 方法，用于打印 Writer 类的详情。由于没有构造方法，意味着当我们创建 Writer 对象时，它的字段值并没有初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = new Writer();</span><br><span class="line">System.out.println(writer.toString());</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writer&#123;name=&#x27;null&#x27;, age=0&#125;</span><br></pre></td></tr></table></figure>
<p>name 是字符串类型，所以默认值为 null，age 为 int 类型，所以默认值为 0。<br>让我们为 Writer 类主动加一个无参的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Writer() &#123;</span><br><span class="line">    this.name = &quot;&quot;;</span><br><span class="line">    this.age = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法也是一个方法，只不过它没有返回值，默认返回创建对象的类型。需要注意的是，当前构造方法没有参数，它被称为无参构造方法。如果我们没有主动创建无参构造方法的话，编译器会隐式地自动添加一个无参的构造方法。这就是为什么，一开始虽然没有构造方法，却可以使用 new Writer() 创建对象的原因，只不过，所有的字段都被初始化成了默认值。<br>接下来，让我们添加一个有参的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Writer(String name, int age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们创建 Writer 对象的时候就可以通过对字段值初始化值了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Writer writer1 = new Writer(&quot;沉默王二&quot;,18);</span><br><span class="line">System.out.println(writer1.toString());</span><br></pre></td></tr></table></figure>
<p>来看一下打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writer&#123;name=&#x27;沉默王二&#x27;, age=18&#125;</span><br></pre></td></tr></table></figure>
<p>可以根据字段的数量添加不同参数数量的构造方法，比如说，我们可以单独为 name 字段添加一个构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Writer(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能够兼顾 age 字段，我们可以通过 this 关键字调用其他的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Writer(String name) &#123;</span><br><span class="line">    this(name,18);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把作者的年龄都默认初始化为 18。如果需要使用父类的构造方法，还可以使用 super 关键字，手册后面有详细的介绍。</p>
<h1 id="九、Java-抽象类"><a href="#九、Java-抽象类" class="headerlink" title="九、Java 抽象类"></a>九、Java 抽象类</h1><p>当我们要完成的任务是确定的，但具体的方式需要随后开个会投票的话，Java 的抽象类就派上用场了。这句话怎么理解呢？搬个小板凳坐好，听我来给你讲讲。<br><img src="https://www.qyihe.xyz/images/post/10.25.jpg"></p>
<h2 id="01、抽象类的-5-个关键点"><a href="#01、抽象类的-5-个关键点" class="headerlink" title="01、抽象类的 5 个关键点"></a>01、抽象类的 5 个关键点</h2><p>（1）定义抽象类的时候需要用到关键字 abstract，放在 class 关键字前。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于抽象类的命名，阿里出品的 Java 开发手册上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，记住了哦。<br>（2）抽象类不能被实例化，但可以有子类。<br>尝试通过 new 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。<br><img src="https://www.qyihe.xyz/images/post/10.26.jpg"><br>通过 extends 关键字可以继承抽象类，继承后，BasketballPlayer 类就是 AbstractPlayer 的子类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。<br>当在一个普通类（没有使用 abstract 关键字修饰）中定义了抽象方法，编译器就会有两处错误提示。<br>第一处在类级别上，提醒你“这个类必须通过 abstract 关键字定义”，or 的那个信息没必要，见下图。<br><img src="https://www.qyihe.xyz/images/post/10.27.jpg"><br>第二处在方法级别上，提醒你“抽象方法所在的类不是抽象的”，见下图。<br><img src="https://www.qyihe.xyz/images/post/10.28.jpg"><br>（4）抽象类可以同时声明抽象方法和具体方法，也可以什么方法都没有，但没必要。就像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractPlayer &#123;</span><br><span class="line">    abstract void play();</span><br><span class="line">    </span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（5）抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类中定义了 play() 方法，子类中就必须实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void play() &#123;</span><br><span class="line">        System.out.println(&quot;我是张伯伦，篮球场上得过 100 分&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有实现的话，编译器会提醒你“子类必须实现抽象方法”，见下图。<br><img src="https://www.qyihe.xyz/images/post/10.29.jpg"></p>
<h2 id="02、什么时候用抽象类"><a href="#02、什么时候用抽象类" class="headerlink" title="02、什么时候用抽象类"></a>02、什么时候用抽象类</h2><p>与抽象类息息相关的还有一个概念，就是接口，我们留到下一篇文章中详细说，因为要说的知识点还是蛮多的。你现在只需要有这样一个概念就好，接口是对行为的抽象，抽象类是对整个类（包含成员变量和行为）进行抽象。<br>（是不是有点明白又有点不明白，别着急，翘首以盼地等下一篇文章出炉吧）<br>除了接口之外，还有一个概念就是具体的类，就是不通过 abstract 修饰的普通类，见下面这段代码中的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BasketballPlayer &#123;</span><br><span class="line">   public void play() &#123;</span><br><span class="line">        System.out.println(&quot;我是詹姆斯，现役第一人&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有接口，有具体类，那什么时候该使用抽象类呢？<br>（1）我们希望一些通用的功能被多个子类复用。比如说，AbstractPlayer 抽象类中有一个普通的方法 sleep()，表明所有运动员都需要休息，那么这个方法就可以被子类复用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractPlayer &#123;</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 AbstractPlayer 类可以不是抽象类——把 abstract 修饰符去掉也能满足这种场景。但 AbstractPlayer 类可能还会有一个或者多个抽象方法。<br>BasketballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BasketballPlayer 对象可以直接调用 sleep() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BasketballPlayer basketballPlayer = new BasketballPlayer();</span><br><span class="line">basketballPlayer.sleep();</span><br></pre></td></tr></table></figure>
<p>FootballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class FootballPlayer extends AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FootballPlayer 对象也可以直接调用 sleep() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FootballPlayer footballPlayer = new FootballPlayer();</span><br><span class="line">footballPlayer.sleep();</span><br></pre></td></tr></table></figure>
<p>（2）我们需要在抽象类中定义好 API，然后在子类中扩展实现。比如说，AbstractPlayer  抽象类中有一个抽象方法 play()，定义所有运动员都可以从事某项运动，但需要对应子类去扩展实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractPlayer &#123;</span><br><span class="line">    abstract void play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void play() &#123;</span><br><span class="line">        System.out.println(&quot;我是张伯伦，我篮球场上得过 100 分，&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">FootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</span><br></pre></td></tr></table></figure>
<p>public class FootballPlayer extends AbstractPlayer {<br>  @Override<br>  void play() {</p>
<pre><code>  System.out.println(&quot;我是C罗，我能接住任意高度的头球&quot;);
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（3）如果父类与子类之间的关系符合 is-a 的层次关系，就可以使用抽象类，比如说篮球运动员是运动员，足球运动员是运动员。</span><br><span class="line">## 03、具体示例</span><br><span class="line">为了进一步展示抽象类的特性，我们再来看一个具体的示例。假设现在有一个文件，里面的内容非常简单——“Hello World”，现在需要有一个读取器将内容读取出来，最好能按照大写的方式，或者小写的方式。</span><br><span class="line">这时候，最好定义一个抽象类，比如说 BaseFileReader：</span><br></pre></td></tr></table></figure>
<p>public abstract class BaseFileReader {<br>  protected Path filePath;</p>
<p>  protected BaseFileReader(Path filePath) {</p>
<pre><code>  this.filePath = filePath;
</code></pre>
<p>  }</p>
<p>  public List<String> readFile() throws IOException {</p>
<pre><code>  return Files.lines(filePath)
          .map(this::mapFileLine).collect(Collectors.toList());
</code></pre>
<p>  }</p>
<p>  protected abstract String mapFileLine(String line);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问。</span><br><span class="line">readFile() 方法用来读取文件，方法体里面调用了抽象方法 mapFileLine()——需要子类扩展实现大小写的方式。</span><br><span class="line">你看，BaseFileReader 设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。</span><br><span class="line">小写的方式：</span><br></pre></td></tr></table></figure>
<p>public class LowercaseFileReader extends BaseFileReader {<br>  protected LowercaseFileReader(Path filePath) {</p>
<pre><code>  super(filePath);
</code></pre>
<p>  }</p>
<p>  @Override<br>  protected String mapFileLine(String line) {</p>
<pre><code>  return line.toLowerCase();
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大写的方式：</span><br></pre></td></tr></table></figure>
<p>public class UppercaseFileReader extends BaseFileReader {<br>  protected UppercaseFileReader(Path filePath) {</p>
<pre><code>  super(filePath);
</code></pre>
<p>  }</p>
<p>  @Override<br>  protected String mapFileLine(String line) {</p>
<pre><code>  return line.toUpperCase();
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你看，从文件里面一行一行读取内容的代码被子类复用了——抽象类 BaseFileReader 类中定义的普通方法 readFile()。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。</span><br><span class="line">接下来，我们来新建一个测试类 FileReaderTest：</span><br></pre></td></tr></table></figure>
<p>public class FileReaderTest {<br>  public static void main(String[] args) throws URISyntaxException, IOException {</p>
<pre><code>  URL location = FileReaderTest.class.getClassLoader().getResource(&quot;helloworld.txt&quot;);
  Path path = Paths.get(location.toURI());
  BaseFileReader lowercaseFileReader = new LowercaseFileReader(path);
  BaseFileReader uppercaseFileReader = new UppercaseFileReader(path);
  System.out.println(lowercaseFileReader.readFile());
  System.out.println(uppercaseFileReader.readFile());
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">项目的 resource 目录下有一个文本文件，名字叫 helloworld.txt。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.30.jpg)</span><br><span class="line">可以通过 ClassLoader.getResource() 的方式获取到该文件的 URI 路径，然后就可以使用 LowercaseFileReader 和 UppercaseFileReader 两种方式读取到文本内容了。</span><br><span class="line">输出结果如下所示：</span><br></pre></td></tr></table></figure>
<p>[hello world]<br>[HELLO WORLD]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 十、Java 接口</span><br><span class="line">对于面向对象编程来说，抽象是一个极具魅力的特征。如果一个程序员的抽象思维很差，那他在编程中就会遇到很多困难，无法把业务变成具体的代码。在 Java 中，可以通过两种形式来达到抽象的目的，一种是抽象类，另外一种就是接口。</span><br><span class="line">如果你现在就想知道抽象类与接口之间的区别，我可以提前给你说一个：</span><br><span class="line"></span><br><span class="line">- 一个类只能继承一个抽象类，但却可以实现多个接口。</span><br><span class="line"></span><br><span class="line">当然了，在没有搞清楚接口到底是什么，它可以做什么之前，这个区别理解起来会有点难度。</span><br><span class="line">## 01、接口是什么</span><br><span class="line">接口是通过 interface 关键字定义的，它可以包含一些常量和方法，来看下面这个示例。</span><br></pre></td></tr></table></figure>
<p>public interface Electronic {<br>  // 常量<br>  String LED = “LED”;</p>
<p>  // 抽象方法<br>  int getElectricityUse();</p>
<p>  // 静态方法<br>  static boolean isEnergyEfficient(String electtronicType) {</p>
<pre><code>  return electtronicType.equals(LED);
</code></pre>
<p>  }</p>
<p>  // 默认方法<br>  default void printDescription() {</p>
<pre><code>  System.out.println(&quot;电子&quot;);
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）接口中定义的变量会在编译的时候自动加上 public static final 修饰符，也就是说 LED 变量其实是一个常量。</span><br><span class="line">Java 官方文档上有这样的声明：</span><br></pre></td></tr></table></figure>
<p>Every field declaration in the body of an interface is implicitly public, static, and final.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">换句话说，接口可以用来作为常量类使用，还能省略掉 public static final，看似不错的一种选择，对吧？</span><br><span class="line">不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。</span><br><span class="line">（2）没有使用 private、default 或者 static 关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 public abstract 修饰符。也就是说 getElectricityUse() 其实是一个抽象方法，没有方法体——这是定义接口的本意。</span><br><span class="line">（3）从 Java 8 开始，接口中允许有静态方法，比如说 isEnergyEfficient() 方法。</span><br><span class="line">静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口的名字来调用，比如说 Electronic.isEnergyEfficient(&quot;LED&quot;)。</span><br><span class="line">接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。</span><br><span class="line">（4）接口中允许定义 default 方法也是从 Java 8 开始的，比如说 printDescription()，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现，也就是说，无法直接使用一个“;”号来结束默认方法——编译器会报错的。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.31.jpg)</span><br><span class="line">允许在接口中定义默认方法的理由是很充分的，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 default 方法的帮助下，我们就必须挨个对实现类进行修改。</span><br><span class="line">来看一下 Electronic 接口反编译后的字节码吧，你会发现，接口中定义的所有变量或者方法，都会自动添加上 public 关键字——假如你想知道编译器在背后都默默做了哪些辅助，记住反编译字节码就对了。</span><br></pre></td></tr></table></figure>
<p>public interface Electronic<br>{</p>
<p>  public abstract int getElectricityUse();</p>
<p>  public static boolean isEnergyEfficient(String electtronicType)<br>  {</p>
<pre><code>  return electtronicType.equals(&quot;LED&quot;);
</code></pre>
<p>  }</p>
<p>  public void printDescription()<br>  {</p>
<pre><code>  System.out.println(&quot;\u7535\u5B50&quot;);
</code></pre>
<p>  }</p>
<p>  public static final String LED = “LED”;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">有些读者可能会问，“二哥，为什么我反编译后的字节码和你的不一样，你用了什么反编译工具？”其实没有什么秘密，微信搜「沉默王二」回复关键字「JAD」就可以免费获取了，超级好用。</span><br><span class="line">## 02、定义接口的注意事项</span><br><span class="line">由之前的例子我们就可以得出下面这些结论：</span><br><span class="line"></span><br><span class="line">- 接口中允许定义变量</span><br><span class="line">- 接口中允许定义抽象方法</span><br><span class="line">- 接口中允许定义静态方法（Java 8 之后）</span><br><span class="line">- 接口中允许定义默认方法（Java 8 之后）</span><br><span class="line"></span><br><span class="line">除此之外，我们还应该知道：</span><br><span class="line">（1）接口不允许直接实例化。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.32.jpg)</span><br><span class="line">需要定义一个类去实现接口，然后再实例化。</span><br></pre></td></tr></table></figure>
<p>public class Computer implements Electronic {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>  new Computer();
</code></pre>
<p>  }</p>
<p>  @Override<br>  public int getElectricityUse() {</p>
<pre><code>  return 0;
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（2）接口可以是空的，既不定义变量，也不定义方法。</span><br></pre></td></tr></table></figure>
<p>public interface Serializable {<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serializable 是最典型的一个空的接口，我之前分享过一篇文章《Java Serializable：明明就一个空的接口嘛》，感兴趣的读者可以去我的个人博客看一看，你就明白了空接口的意义。</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.itwanger.com/java/2019/1%E2%80%A6">www.itwanger.com/java/2019/1…</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（3）不要在定义接口的时候使用 final 关键字，否则会报编译错误，因为接口就是为了让子类实现的，而 final 阻止了这种行为。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.33.jpg)</span><br><span class="line">（4）接口的抽象方法不能是 private、protected 或者 final。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.34.jpg)</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.35.jpg)</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.36.jpg)</span><br><span class="line">（5）接口的变量是隐式 public static final，所以其值无法改变。</span><br><span class="line">## 03、接口可以做什么</span><br><span class="line">（1）使某些实现类具有我们想要的功能，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了 Comparable 或者 Comparator 的类具有比较功能。</span><br><span class="line">Cloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 Object.clone() 方法，否则会抛出 CloneNotSupportedException。</span><br></pre></td></tr></table></figure>
<p>public class CloneableTest implements Cloneable {<br>  @Override<br>  protected Object clone() throws CloneNotSupportedException {</p>
<pre><code>  return super.clone();
</code></pre>
<p>  }</p>
<p>  public static void main(String[] args) throws CloneNotSupportedException {</p>
<pre><code>  CloneableTest c1 = new CloneableTest();
  CloneableTest c2 = (CloneableTest) c1.clone();
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行后没有报错。现在把 implements Cloneable 去掉。</span><br></pre></td></tr></table></figure>
<p>public class CloneableTest {<br>  @Override<br>  protected Object clone() throws CloneNotSupportedException {</p>
<pre><code>  return super.clone();
</code></pre>
<p>  }</p>
<p>  public static void main(String[] args) throws CloneNotSupportedException {</p>
<pre><code>  CloneableTest c1 = new CloneableTest();
  CloneableTest c2 = (CloneableTest) c1.clone();
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行后抛出 CloneNotSupportedException：</span><br></pre></td></tr></table></figure>
<p>Exception in thread “main” java.lang.CloneNotSupportedException: com.cmower.baeldung.interface1.CloneableTest<br>  at java.base/java.lang.Object.clone(Native Method)<br>  at com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:6)<br>  at com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:11)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">至于 Comparable 和 Comparator 的用法，感兴趣的读者可以参照我之前写的另外一篇文章《来吧，一文彻底搞懂Java中的Comparable和Comparator》。</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.itwanger.com/java/2020/0%E2%80%A6">www.itwanger.com/java/2020/0…</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（2）Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。</span><br><span class="line">可能有些读者会问，“二哥，为什么 Java 只支持单一继承？”简单来解释一下。</span><br><span class="line">如果有两个类共同继承（extends）一个有特定方法的父类，那么该方法会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。这也正是著名的菱形问题，见下图。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.37.jpg)</span><br><span class="line">ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重载的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。</span><br><span class="line">接口没有这方面的困扰。来定义两个接口，Fly 会飞，Run 会跑。</span><br></pre></td></tr></table></figure>
<p>public interface Fly {<br>  void fly();<br>}<br>public interface Run {<br>  void run();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后让一个类同时实现这两个接口。</span><br></pre></td></tr></table></figure>
<p>public class Pig implements Fly,Run{<br>  @Override<br>  public void fly() {</p>
<pre><code>  System.out.println(&quot;会飞的猪&quot;);
</code></pre>
<p>  }</p>
<p>  @Override<br>  public void run() {</p>
<pre><code>  System.out.println(&quot;会跑的猪&quot;);
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这就在某种形式上达到了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。</span><br><span class="line">（3）实现多态。</span><br><span class="line">什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。</span><br><span class="line">多态可以通过继承（extends）的关系实现，也可以通过接口的形式实现。来看这样一个例子。</span><br><span class="line">Shape 是表示一个形状。</span><br></pre></td></tr></table></figure>
<p>public interface Shape {<br>  String name();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">圆是一个形状。</span><br></pre></td></tr></table></figure>
<p>public class Circle implements Shape {<br>  @Override<br>  public String name() {</p>
<pre><code>  return &quot;圆&quot;;
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正方形也是一个形状。</span><br></pre></td></tr></table></figure>
<p>public class Square implements Shape {<br>  @Override<br>  public String name() {</p>
<pre><code>  return &quot;正方形&quot;;
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后来看测试类。</span><br></pre></td></tr></table></figure>
<p>List<Shape> shapes = new ArrayList&lt;&gt;();<br>Shape circleShape = new Circle();<br>Shape squareShape = new Square();</p>
</li>
</ul>
<p>shapes.add(circleShape);<br>shapes.add(squareShape);</p>
<p>for (Shape shape : shapes) {<br>    System.out.println(shape.name());<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">多态的存在 3 个前提：</span><br><span class="line">1、要有继承关系，Circle 和 Square 都实现了 Shape 接口</span><br><span class="line">2、子类要重写父类的方法，Circle 和 Square 都重写了 name() 方法</span><br><span class="line">3、父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle 对象，后者指向的是 Square 对象。</span><br><span class="line">然后，我们来看一下测试结果：</span><br></pre></td></tr></table></figure>
<p>圆<br>正方形</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 name() 方法的时候，它知道 Circle 对象应该调用 Circle 类的 name() 方法，Square 对象应该调用 Square 类的 name() 方法。</span><br><span class="line">## 04、接口与抽象类的区别</span><br><span class="line">好了，关于接口的一切，你应该都搞清楚了。现在回到读者春夏秋冬的那条留言，“兄弟，说说抽象类和接口之间的区别？”</span><br><span class="line">（1）语法层面上</span><br><span class="line"></span><br><span class="line">- 接口中不能有 public 和 protected 修饰的方法，抽象类中可以有。</span><br><span class="line">- 接口中的变量只能是隐式的常量，抽象类中可以有任意类型的变量。</span><br><span class="line">- 一个类只能继承一个抽象类，但却可以实现多个接口。</span><br><span class="line"></span><br><span class="line">（2）设计层面上</span><br><span class="line">抽象类是对类的一种抽象，继承抽象类的类和抽象类本身是一种 is-a 的关系。</span><br><span class="line">接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，所有的类都可以实现 Serializable 接口，从而具有序列化的功能。</span><br><span class="line">就这么多吧，能说道这份上，我相信面试官就不会为难你了。</span><br><span class="line"># 十一、Java 继承</span><br><span class="line">在 Java 中，一个类可以继承另外一个类或者实现多个接口，我想这一点，大部分的读者应该都知道了。还有一点，我不确定大家是否知道，就是一个接口也可以继承另外一个接口，就像下面这样：</span><br></pre></td></tr></table></figure>
<p>public interface OneInterface extends Cloneable {<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样做有什么好处呢？我想有一部分读者应该已经猜出来了，就是实现了 OneInterface 接口的类，也可以使用 Object.clone() 方法了。</span><br></pre></td></tr></table></figure>
<p>public class TestInterface implements OneInterface {<br>    public static void main(String[] args) throws CloneNotSupportedException {<br>        TestInterface c1 = new TestInterface();<br>        TestInterface c2 = (TestInterface) c1.clone();<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">除此之外，我们还可以在 OneInterface 接口中定义其他一些抽象方法（比如说深拷贝），使该接口拥有 Cloneable 所不具有的功能。</span><br></pre></td></tr></table></figure>
<p>public interface OneInterface extends Cloneable {<br>    void deepClone();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">看到了吧？这就是继承的好处：子接口拥有了父接口的方法，使得子接口具有了父接口相同的行为；同时，子接口还可以在此基础上自由发挥，添加属于自己的行为。</span><br><span class="line">以上，把“接口”换成“类”，结论同样成立。让我们来定义一个普通的父类 Wanger：</span><br></pre></td></tr></table></figure>
<p>public class Wanger {<br>    int age;<br>    String name;<br>    void write() {<br>        System.out.println(“我写了本《基督山伯爵》”);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后，我们再来定义一个子类 Wangxiaoer，使用关键字 extends 来继承父类 Wanger：</span><br></pre></td></tr></table></figure>
<p>public class Wangxiaoer extends Wanger{<br>    @Override<br>    void write() {<br>        System.out.println(“我写了本《茶花女》”);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们可以将通用的方法和成员变量放在父类中，达到代码复用的目的；然后将特殊的方法和成员变量放在子类中，除此之外，子类还可以覆盖父类的方法（比如write() 方法）。这样，子类也就焕发出了新的生命力。</span><br><span class="line">Java 只支持单一继承，这一点，我在上一篇接口的文章中已经提到过了。如果一个类在定义的时候没有使用 extends 关键字，那么它隐式地继承了 java.lang.Object 类——在我看来，这恐怕就是 Java 号称万物皆对象的真正原因了。</span><br><span class="line">那究竟子类继承了父类的什么呢？</span><br><span class="line">子类可以继承父类的非 private 成员变量，为了验证这一点，我们来看下面这个示例。</span><br></pre></td></tr></table></figure>
<p>public class Wanger {<br>    String defaultName;<br>    private String privateName;<br>    public String publicName;<br>    protected String protectedName;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">父类 Wanger 定义了四种类型的成员变量，缺省的 defaultName、私有的 privateName、共有的 publicName、受保护的 protectedName。</span><br><span class="line">在子类 Wangxiaoer 中定义一个测试方法 testVariable()：</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.38.jpg)</span><br><span class="line">可以确认，除了私有的 privateName，其他三种类型的成员变量都可以继承到。</span><br><span class="line">同理，子类可以继承父类的非 private 方法，为了验证这一点，我们来看下面这个示例。</span><br></pre></td></tr></table></figure>
<p>public class Wanger {<br>    void write() {<br>    }</p>
<pre><code>private void privateWrite() &#123;
&#125;

public void publicWrite() &#123;
&#125;

protected void protectedWrite() &#123;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">父类 Wanger 定义了四种类型的方法，缺省的 write、私有的 privateWrite()、共有的 publicWrite()、受保护的 protectedWrite()。</span><br><span class="line">在子类 Wangxiaoer 中定义一个 main 方法，并使用 new 关键字新建一个子类对象：</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.39.jpg)</span><br><span class="line">可以确认，除了私有的 privateWrite()，其他三种类型的方法都可以继承到。</span><br><span class="line">不过，子类无法继承父类的构造方法。如果父类的构造方法是带有参数的，代码如下所示：</span><br></pre></td></tr></table></figure>
<p>public class Wanger {<br>    int age;<br>    String name;</p>
<pre><code>public Wanger(int age, String name) &#123;
    this.age = age;
    this.name = name;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">则必须在子类的构造器中显式地通过 super 关键字进行调用，否则编译器将提示以下错误：</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.40.jpg)</span><br><span class="line">修复后的代码如下所示：</span><br></pre></td></tr></table></figure>
<p>public class Wangxiaoer extends Wanger{<br>    public Wangxiaoer(int age, String name) {<br>        super(age, name);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is-a 是继承的一个明显特征，就是说子类的对象引用类型可以是一个父类类型。</span><br></pre></td></tr></table></figure>
<p>public class Wangxiaoer extends Wanger{<br>    public static void main(String[] args) {<br>        Wanger wangxiaoer = new Wangxiaoer();<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同理，子接口的实现类的对象引用类型也可以是一个父接口类型。</span><br></pre></td></tr></table></figure>
<p>public interface OneInterface extends Cloneable {<br>}<br>public class TestInterface implements OneInterface {<br>    public static void main(String[] args) {<br>        Cloneable c1 = new TestInterface();<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">尽管一个类只能继承一个类，但一个类却可以实现多个接口，这一点，我在上一篇文章也提到过了。另外，还有一点我也提到了，就是 Java 8 之后，接口中可以定义 default 方法，这很方便，但也带来了新的问题：</span><br><span class="line"></span><br><span class="line">&gt; 如果一个类实现了多个接口，而这些接口中定义了相同签名的 default 方法，那么这个类就要重写该方法，否则编译无法通过。</span><br><span class="line"></span><br><span class="line">FlyInterface 是一个会飞的接口，里面有一个签名为 sleep() 的默认方法：</span><br></pre></td></tr></table></figure>
<p>public interface FlyInterface {<br>    void fly();<br>    default void sleep() {<br>        System.out.println(“睡着飞”);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RunInterface 是一个会跑的接口，里面也有一个签名为 sleep() 的默认方法：</span><br></pre></td></tr></table></figure>
<p>public interface RunInterface {<br>    void run();<br>    default void sleep() {<br>        System.out.println(“睡着跑”);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pig 类实现了 FlyInterface 和 RunInterface 两个接口，但这时候编译出错了。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.41.jpg)</span><br><span class="line">原本，default 方法就是为实现该接口而不覆盖该方法的类提供默认实现的，现在，相同方法签名的 sleep() 方法把编译器搞懵逼了，只能重写了。</span><br></pre></td></tr></table></figure>
<p>public class Pig implements FlyInterface, RunInterface {</p>
<pre><code>@Override
public void fly() &#123;
    System.out.println(&quot;会飞的猪&quot;);
&#125;

@Override
public void sleep() &#123;
    System.out.println(&quot;只能重写了&quot;);
&#125;

@Override
public void run() &#123;
    System.out.println(&quot;会跑的猪&quot;);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类虽然不能继承多个类，但接口却可以继承多个接口，这一点，我不知道有没有触及到一些读者的知识盲区。</span><br></pre></td></tr></table></figure>
<p>public interface WalkInterface extends FlyInterface,RunInterface{<br>    void walk();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 十二、this 关键字</span><br><span class="line">在 Java 中，this 关键字指的是当前对象（它的方法正在被调用）的引用，能理解吧，各位亲？不理解的话，我们继续往下看。</span><br><span class="line">看完再不明白，你过来捶爆我，我保证不还手，只要不打脸。</span><br><span class="line">## 01、消除字段歧义</span><br><span class="line">我敢赌一毛钱，所有的读者，不管男女老少，应该都知道这种用法，毕竟写构造方法的时候经常用啊。谁要不知道，过来，我给你发一毛钱红包，只要你脸皮够厚。</span><br></pre></td></tr></table></figure>
<p>public class Writer {<br>    private int age;<br>    private String name;</p>
<pre><code>public Writer(int age, String name) &#123;
    this.age = age;
    this.name = name;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Writer 类有两个成员变量，分别是 age 和 name，在使用有参构造函数的时候，如果参数名和成员变量的名字相同，就需要使用 this 关键字消除歧义：this.age 是指成员变量，age 是指构造方法的参数。</span><br><span class="line">## 02、引用类的其他构造方法</span><br><span class="line">当一个类的构造方法有多个，并且它们之间有交集的话，就可以使用 this 关键字来调用不同的构造方法，从而减少代码量。</span><br><span class="line">比如说，在无参构造方法中调用有参构造方法：</span><br></pre></td></tr></table></figure>
<p>public class Writer {<br>    private int age;<br>    private String name;</p>
<pre><code>public Writer(int age, String name) &#123;
    this.age = age;
    this.name = name;
&#125;

public Writer() &#123;
    this(18, &quot;沉默王二&quot;);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以在有参构造方法中调用无参构造方法：</span><br></pre></td></tr></table></figure>
<p>public class Writer {<br>    private int age;<br>    private String name;</p>
<pre><code>public Writer(int age, String name) &#123;
    this();
    this.age = age;
    this.name = name;
&#125;

public Writer() &#123;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需要注意的是，this() 必须是构造方法中的第一条语句，否则就会报错。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.42.jpg)</span><br><span class="line">## 03、作为参数传递</span><br><span class="line">在下例中，有一个无参的构造方法，里面调用了 print() 方法，参数只有一个 this 关键字。</span><br></pre></td></tr></table></figure>
<p>public class ThisTest {<br>    public ThisTest() {<br>        print(this);<br>    }</p>
<pre><code>private void print(ThisTest thisTest) &#123;
    System.out.println(&quot;print &quot; +thisTest);
&#125;

public static void main(String[] args) &#123;
    ThisTest test = new ThisTest();
    System.out.println(&quot;main &quot; + test);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">来打印看一下结果：</span><br></pre></td></tr></table></figure>
<p>print com.cmower.baeldung.this1.ThisTest@573fd745<br>main com.cmower.baeldung.this1.ThisTest@573fd745</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从结果中可以看得出来，this 就是我们在 main() 方法中使用 new 关键字创建的 ThisTest 对象。</span><br><span class="line">## 04、链式调用</span><br><span class="line">学过 JavaScript，或者 jQuery 的读者可能对链式调用比较熟悉，类似于 a.b().c().d()，仿佛能无穷无尽调用下去。</span><br><span class="line">在 Java 中，对应的专有名词叫 Builder 模式，来看一个示例。</span><br></pre></td></tr></table></figure>
<p>public class Writer {<br>    private int age;<br>    private String name;<br>    private String bookName;</p>
<pre><code>public Writer(WriterBuilder builder) &#123;
    this.age = builder.age;
    this.name = builder.name;
    this.bookName = builder.bookName;
&#125;

public static class WriterBuilder &#123;
    public String bookName;
    private int age;
    private String name;

    public WriterBuilder(int age, String name) &#123;
        this.age = age;
        this.name = name;
    &#125;

    public WriterBuilder writeBook(String bookName) &#123;
        this.bookName = bookName;
        return this;
    &#125;

    public Writer build() &#123;
        return new Writer(this);
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Writer 类有三个成员变量，分别是 age、name 和 bookName，还有它们仨对应的一个构造方法，参数是一个内部静态类 WriterBuilder。</span><br><span class="line">内部类 WriterBuilder 也有三个成员变量，和 Writer 类一致，不同的是，WriterBuilder 类的构造方法里面只有 age 和 name 赋值了，另外一个成员变量 bookName 通过单独的方法 writeBook() 来赋值，注意，该方法的返回类型是 WriterBuilder，最后使用 return 返回了 this 关键字。</span><br><span class="line">最后的 build() 方法用来创建一个 Writer 对象，参数为 this 关键字，也就是当前的 WriterBuilder 对象。</span><br><span class="line">这时候，创建 Writer 对象就可以通过链式调用的方式。</span><br></pre></td></tr></table></figure>
<p>Writer writer = new Writer.WriterBuilder(18,”沉默王二”)<br>                .writeBook(“《Web全栈开发进阶之路》”)<br>                .build();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 05、在内部类中访问外部类对象</span><br><span class="line">说实话，自从 Java 8 的函数式编程出现后，就很少用到 this 在内部类中访问外部类对象了。来看一个示例：</span><br></pre></td></tr></table></figure>
<p>public class ThisInnerTest {<br>    private String name;</p>
<pre><code>class InnerClass &#123;
    public InnerClass() &#123;
        ThisInnerTest thisInnerTest = ThisInnerTest.this;
        String outerName = thisInnerTest.name;
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在内部类 InnerClass 的构造方法中，通过外部类.this 可以获取到外部类对象，然后就可以使用外部类的成员变量了，比如说 name。</span><br><span class="line"># 十三、super 关键字</span><br><span class="line">简而言之，super 关键字就是用来访问父类的。</span><br><span class="line">先来看父类：</span><br></pre></td></tr></table></figure>
<p>public class SuperBase {<br>    String message = “父类”;</p>
<pre><code>public SuperBase(String message) &#123;
    this.message = message;
&#125;

public SuperBase() &#123;
&#125;

public void printMessage() &#123;
    System.out.println(message);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再来看子类：</span><br></pre></td></tr></table></figure>
<p>public class SuperSub extends SuperBase {<br>    String message = “子类”;</p>
<pre><code>public SuperSub(String message) &#123;
    super(message);
&#125;

public SuperSub() &#123;
    super.printMessage();
    printMessage();
&#125;

public void getParentMessage() &#123;
    System.out.println(super.message);
&#125;

public void printMessage() &#123;
    System.out.println(message);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）super 关键字可用于访问父类的构造方法</span><br><span class="line">你看，子类可以通过 super(message) 来调用父类的构造方法。现在来新建一个 SuperSub 对象，看看输出结果是什么：</span><br></pre></td></tr></table></figure>
<p>SuperSub superSub = new SuperSub(“子类的message”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new 关键字在调用构造方法创建子类对象的时候，会通过 super 关键字初始化父类的 message，所以此此时父类的 message 会输出“子类的message”。</span><br><span class="line">（2）super 关键字可以访问父类的变量</span><br><span class="line">上述例子中的 SuperSub 类中就有，getParentMessage() 通过 super.message 方法父类的同名成员变量 message。</span><br><span class="line">（3）当方法发生重写时，super 关键字可以访问父类的同名方法</span><br><span class="line">上述例子中的 SuperSub 类中就有，无参的构造方法 SuperSub() 中就使用 super.printMessage() 调用了父类的同名方法。</span><br><span class="line"># 十四、重写和重载</span><br><span class="line">先来看一段重写的代码吧。</span><br></pre></td></tr></table></figure>
<p>class LaoWang{<br>    public void write() {<br>        System.out.println(“老王写了一本《基督山伯爵》”);<br>    }<br>}<br>public class XiaoWang extends LaoWang {<br>    @Override<br>    public void write() {<br>        System.out.println(“小王写了一本《茶花女》”);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。就好像父类 LaoWang 有一个 write() 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 write() 方法（无参），但方法体是写一本《茶花女》。</span><br><span class="line">来写一段测试代码。</span><br></pre></td></tr></table></figure>
<p>public class OverridingTest {<br>    public static void main(String[] args) {<br>        LaoWang wang = new XiaoWang();<br>        wang.write();<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大家猜结果是什么？</span><br></pre></td></tr></table></figure>
<p>小王写了一本《茶花女》</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在上面的代码中，们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 write() 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 write() 方法而不是父类 LaoWang  中的 write() 方法，因此输出结果为“小王写了一本《茶花女》”。</span><br><span class="line">再来看一段重载的代码吧。</span><br></pre></td></tr></table></figure>
<p>class LaoWang{<br>    public void read() {<br>        System.out.println(“老王读了一本《Web全栈开发进阶之路》”);<br>    }</p>
<pre><code>public void read(String bookname) &#123;
    System.out.println(&quot;老王读了一本《&quot; + bookname + &quot;》&quot;);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重载的两个方法名相同，但方法参数的个数不同，另外也不涉及到继承，两个方法在同一个类中。就好像类 LaoWang 有两个方法，名字都是 read()，但一个有参数（书名），另外一个没有（只能读写死的一本书）。</span><br><span class="line">来写一段测试代码。</span><br></pre></td></tr></table></figure>
<p>public class OverloadingTest {<br>    public static void main(String[] args) {<br>        LaoWang wang = new LaoWang();<br>        wang.read();<br>        wang.read(“金瓶梅”);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">这结果就不用猜了。变量 wang 的类型为 LaoWang，wang.read() 调用的是无参的 read() 方法，因此先输出“老王读了一本《Web全栈开发进阶之路》”；wang.read(&quot;金瓶梅&quot;) 调用的是有参的 read(bookname) 方法，因此后输出“老王读了一本《金瓶梅》”。在编译期间，编译器就知道这两个 read() 方法时不同的，因为它们的方法签名（=方法名称+方法参数）不同。</span><br><span class="line">简单的来总结一下：</span><br><span class="line">（1）编译器无法决定调用哪个重写的方法，因为只从变量的类型上是无法做出判断的，要在运行时才能决定；但编译器可以明确地知道该调用哪个重载的方法，因为引用类型是确定的，参数个数决定了该调用哪个方法。</span><br><span class="line">（2）多态针对的是重写，而不是重载。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.43.jpg)</span><br><span class="line">哎，后悔啊，早年我要是能把这道面试题吃透的话，也不用被老马刁难了。吟一首诗感慨一下人生吧。</span><br><span class="line"></span><br><span class="line">&gt;青青园中葵，朝露待日晞。</span><br><span class="line">&gt;阳春布德泽，万物生光辉。</span><br><span class="line">&gt;常恐秋节至，焜黄华叶衰。</span><br><span class="line">&gt;百川东到海，何时复西归?</span><br><span class="line">&gt;少壮不努力，老大徒伤悲</span><br><span class="line"></span><br><span class="line">另外，我想要告诉大家的是，重写（Override）和重载（Overload）是 Java 中两个非常重要的概念，新手经常会被它们俩迷惑，因为它们俩的英文名字太像了，中文翻译也只差一个字。难，太难了。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.44.jpg)</span><br><span class="line"># 十五、static 关键字</span><br><span class="line">先来个提纲挈领（唉呀妈呀，成语区博主上线了）吧：</span><br><span class="line"></span><br><span class="line">&gt;static 关键字可用于变量、方法、代码块和内部类，表示某个特定的成员只属于某个类本身，而不是该类的某个对象。</span><br><span class="line"></span><br><span class="line">## 01、静态变量</span><br><span class="line">静态变量也叫类变量，它属于一个类，而不是这个类的对象。</span><br></pre></td></tr></table></figure>
<p>public class Writer {<br>    private String name;<br>    private int age;<br>    public static int countOfWriters;</p>
<pre><code>public Writer(String name, int age) &#123;
    this.name = name;
    this.age = age;
    countOfWriters++;
&#125;

public String getName() &#123;
    return name;
&#125;

public void setName(String name) &#123;
    this.name = name;
&#125;

public int getAge() &#123;
    return age;
&#125;

public void setAge(int age) &#123;
    this.age = age;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其中，countOfWriters 被称为静态变量，它有别于 name 和 age 这两个成员变量，因为它前面多了一个修饰符 static。</span><br><span class="line">这意味着无论这个类被初始化多少次，静态变量的值都会在所有类的对象中共享。</span><br></pre></td></tr></table></figure>
<p>Writer w1 = new Writer(“沉默王二”,18);<br>Writer w2 = new Writer(“沉默王三”,16);</p>
<p>System.out.println(Writer.countOfWriters);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">按照上面的逻辑，你应该能推理得出，countOfWriters 的值此时应该为 2 而不是 1。从内存的角度来看，静态变量将会存储在 Java 虚拟机中一个名叫“Metaspace”（元空间，Java 8 之后）的特定池中。</span><br><span class="line">静态变量和成员变量有着很大的不同，成员变量的值属于某个对象，不同的对象之间，值是不共享的；但静态变量不是的，它可以用来统计对象的数量，因为它是共享的。就像上面例子中的 countOfWriters，创建一个对象的时候，它的值为 1，创建两个对象的时候，它的值就为 2。</span><br><span class="line">简单小结一下：</span><br><span class="line">（1）由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问；</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.45.jpg)</span><br><span class="line">（2）不需要初始化类就可以访问静态变量。</span><br></pre></td></tr></table></figure>
<p>public class WriterDemo {<br>    public static void main(String[] args) {<br>        System.out.println(Writer.countOfWriters); // 输出 0<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 02、静态方法</span><br><span class="line">静态方法也叫类方法，它和静态变量类似，属于一个类，而不是这个类的对象。</span><br></pre></td></tr></table></figure>
<p>public static void setCountOfWriters(int countOfWriters) {<br>    Writer.countOfWriters = countOfWriters;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setCountOfWriters() 就是一个静态方法，它由 static 关键字修饰。</span><br><span class="line">如果你用过 java.lang.Math 类或者 Apache 的一些工具类（比如说 StringUtils）的话，对静态方法一定不会感动陌生。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.46.jpg)</span><br><span class="line">Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.47.jpg)</span><br><span class="line">简单小结一下：</span><br><span class="line">（1）Java 中的静态方法在编译时解析，因为静态方法不能被重写（方法重写发生在运行时阶段，为了多态）。</span><br><span class="line">（2）抽象方法不能是静态的。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.48.jpg)</span><br><span class="line">（3）静态方法不能使用 this 和 super 关键字。</span><br><span class="line">（4）成员方法可以直接访问其他成员方法和成员变量。</span><br><span class="line">（5）成员方法也可以直接方法静态方法和静态变量。</span><br><span class="line">（6）静态方法可以访问所有其他静态方法和静态变量。</span><br><span class="line">（7）静态方法无法直接访问成员方法和成员变量。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.49.jpg)</span><br><span class="line">## 03、静态代码块</span><br><span class="line">静态代码块可以用来初始化静态变量，尽管静态方法也可以在声明的时候直接初始化，但有些时候，我们需要多行代码来完成初始化。</span><br></pre></td></tr></table></figure>
<p>public class StaticBlockDemo {<br>    public static List<String> writes = new ArrayList&lt;&gt;();</p>
<pre><code>static &#123;
    writes.add(&quot;沉默王二&quot;);
    writes.add(&quot;沉默王三&quot;);
    writes.add(&quot;沉默王四&quot;);

    System.out.println(&quot;第一块&quot;);
&#125;

static &#123;
    writes.add(&quot;沉默王五&quot;);
    writes.add(&quot;沉默王六&quot;);

    System.out.println(&quot;第二块&quot;);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">writes 是一个静态的 ArrayList，所以不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初始化。</span><br><span class="line">简单小结一下：</span><br><span class="line">（1）一个类可以有多个静态代码块。</span><br><span class="line">（2）静态代码块的解析和执行顺序和它在类中的位置保持一致。为了验证这个结论，可以在 StaticBlockDemo 类中加入空的 main 方法，执行完的结果如下所示：</span><br></pre></td></tr></table></figure>
<p>第一块<br>第二块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 04、静态内部类</span><br><span class="line">Java 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。</span><br><span class="line">常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我们本次文章的讨论范围，以后有机会再细说。</span><br></pre></td></tr></table></figure>
<p>public class Singleton {<br>    private Singleton() {}</p>
<pre><code>private static class SingletonHolder &#123;
    public static final Singleton instance = new Singleton();
&#125;

public static Singleton getInstance() &#123;
    return SingletonHolder.instance;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">以上这段代码是不是特别熟悉，对，这就是创建单例的一种方式，第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全也能保证 Singleton 类的唯一性。不过，创建单例更优雅的一种方式是使用枚举。</span><br><span class="line">简单小结一下：</span><br><span class="line">（1）静态内部类不能访问外部类的所有成员变量。</span><br><span class="line">（2）静态内部类可以访问外部类的所有静态变量，包括私有静态变量。</span><br><span class="line">（3）外部类不能声明为 static。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.50.jpg)</span><br><span class="line"># 十六、Java 枚举</span><br><span class="line">开门见山地说吧，enum（枚举）是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，默认继承自 java.lang.Enum。</span><br><span class="line">为了证明这一点，我们来新建一个枚举 PlayerType：</span><br></pre></td></tr></table></figure>
<p>public enum PlayerType {<br>    TENNIS,<br>    FOOTBALL,<br>    BASKETBALL<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个关键字带一个类名，还有大括号，以及三个大写的单词，但没看到继承 Enum 类啊？别着急，心急吃不了热豆腐啊。使用 JAD 查看一下反编译后的字节码，就一清二楚了。</span><br></pre></td></tr></table></figure>
<p>public final class PlayerType extends Enum<br>{</p>
<pre><code>public static PlayerType[] values()
&#123;
    return (PlayerType[])$VALUES.clone();
&#125;

public static PlayerType valueOf(String name)
&#123;
    return (PlayerType)Enum.valueOf(com/cmower/baeldung/enum1/PlayerType, name);
&#125;

private PlayerType(String s, int i)
&#123;
    super(s, i);
&#125;

public static final PlayerType TENNIS;
public static final PlayerType FOOTBALL;
public static final PlayerType BASKETBALL;
private static final PlayerType $VALUES[];

static 
&#123;
    TENNIS = new PlayerType(&quot;TENNIS&quot;, 0);
    FOOTBALL = new PlayerType(&quot;FOOTBALL&quot;, 1);
    BASKETBALL = new PlayerType(&quot;BASKETBALL&quot;, 2);
    $VALUES = (new PlayerType[] &#123;
        TENNIS, FOOTBALL, BASKETBALL
    &#125;);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">看到没？PlayerType 类是 final 的，并且继承自 Enum 类。这些工作我们程序员没做，编译器帮我们悄悄地做了。此外，它还附带几个有用静态方法，比如说 values() 和  valueOf(String name)。</span><br><span class="line">## 01、内部枚举</span><br><span class="line">好的，小伙伴们应该已经清楚枚举长什么样子了吧？既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。</span><br></pre></td></tr></table></figure>
<p>public class Player {<br>    private PlayerType type;<br>    public enum PlayerType {<br>        TENNIS,<br>        FOOTBALL,<br>        BASKETBALL<br>    }</p>
<pre><code>public boolean isBasketballPlayer() &#123;
  return getType() == PlayerType.BASKETBALL;
&#125;

public PlayerType getType() &#123;
    return type;
&#125;

public void setType(PlayerType type) &#123;
    this.type = type;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PlayerType 就相当于 Player 的内部类，isBasketballPlayer() 方法用来判断运动员是否是一个篮球运动员。</span><br><span class="line">由于枚举是 final 的，可以确保在 Java 虚拟机中仅有一个常量对象（可以参照反编译后的静态代码块「static 关键字带大括号的那部分代码」），所以我们可以很安全地使用“==”运算符来比较两个枚举是否相等，参照 isBasketballPlayer() 方法。</span><br><span class="line">那为什么不使用 equals() 方法判断呢？</span><br></pre></td></tr></table></figure>
<p>if(player.getType().equals(Player.PlayerType.BASKETBALL)){};<br>if(player.getType() == Player.PlayerType.BASKETBALL){};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“==”运算符比较的时候，如果两个对象都为 null，并不会发生 NullPointerException，而 equals() 方法则会。</span><br><span class="line">另外， “==”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而 equals() 方法则不会。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.51.jpg)</span><br><span class="line">## 02、枚举可用于 switch 语句</span><br><span class="line">这个我在之前的一篇我去的文章中详细地说明过了，感兴趣的小伙伴可以点击链接跳转过去看一下。</span><br></pre></td></tr></table></figure>
<p>switch (playerType) {<br>        case TENNIS:<br>            return “网球运动员费德勒”;<br>        case FOOTBALL:<br>            return “足球运动员C罗”;<br>        case BASKETBALL:<br>            return “篮球运动员詹姆斯”;<br>        case UNKNOWN:<br>            throw new IllegalArgumentException(“未知”);<br>        default:<br>            throw new IllegalArgumentException(<br>                    “运动员类型: “ + playerType);</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 03、枚举可以有构造方法</span><br><span class="line">如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。</span><br></pre></td></tr></table></figure>
<p>public enum PlayerType {<br>    TENNIS(“网球”),<br>    FOOTBALL(“足球”),<br>    BASKETBALL(“篮球”);</p>
<pre><code>private String name;

PlayerType(String name) &#123;
    this.name = name;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 04、EnumSet</span><br><span class="line">EnumSet 是一个专门针对枚举类型的 Set 接口的实现类，它是处理枚举类型数据的一把利器，非常高效（内部实现是位向量，我也搞不懂）。</span><br><span class="line">因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法：</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.52.jpg)</span><br><span class="line">下面的示例中使用 noneOf() 创建了一个空的 PlayerType 的 EnumSet；使用 allOf() 创建了一个包含所有 PlayerType 的 EnumSet。</span><br></pre></td></tr></table></figure>
<p>public class EnumSetTest {<br>    public enum PlayerType {<br>        TENNIS,<br>        FOOTBALL,<br>        BASKETBALL<br>    }</p>
<pre><code>public static void main(String[] args) &#123;
    EnumSet&lt;PlayerType&gt; enumSetNone = EnumSet.noneOf(PlayerType.class);
    System.out.println(enumSetNone);

    EnumSet&lt;PlayerType&gt; enumSetAll = EnumSet.allOf(PlayerType.class);
    System.out.println(enumSetAll);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序输出结果如下所示：</span><br></pre></td></tr></table></figure>
<p>[]<br>[TENNIS, FOOTBALL, BASKETBALL]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有了 EnumSet 后，就可以使用 Set 的一些方法了：</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.53.jpg)</span><br><span class="line">## 05、EnumMap</span><br><span class="line">EnumMap 是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。</span><br><span class="line">和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字：</span><br></pre></td></tr></table></figure>
<p>EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有了 EnumMap 对象后就可以使用 Map 的一些方法了：</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.54.jpg)</span><br><span class="line">和 HashMap 的使用方法大致相同，来看下面的例子：</span><br></pre></td></tr></table></figure>
<p>EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);<br>enumMap.put(PlayerType.BASKETBALL,”篮球运动员”);<br>enumMap.put(PlayerType.FOOTBALL,”足球运动员”);<br>enumMap.put(PlayerType.TENNIS,”网球运动员”);<br>System.out.println(enumMap);</p>
<p>System.out.println(enumMap.get(PlayerType.BASKETBALL));<br>System.out.println(enumMap.containsKey(PlayerType.BASKETBALL));<br>System.out.println(enumMap.remove(PlayerType.BASKETBALL));</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序输出结果如下所示：</span><br></pre></td></tr></table></figure>
<p>{TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员}<br>篮球运动员<br>true<br>篮球运动员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 06、单例</span><br><span class="line">通常情况下，实现一个单例并非易事，不信，来看下面这段代码</span><br></pre></td></tr></table></figure>
<p>public class Singleton {<br>    private volatile static Singleton singleton;<br>    private Singleton (){}<br>    public static Singleton getSingleton() {<br>    if (singleton == null) {<br>        synchronized (Singleton.class) {<br>        if (singleton == null) {<br>            singleton = new Singleton();<br>        }<br>        }<br>    }<br>    return singleton;<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但枚举的出现，让代码量减少到极致：</span><br></pre></td></tr></table></figure>
<p>public enum EasySingleton{<br>    INSTANCE;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">完事了，真的超级短，有没有？枚举默认实现了 Serializable 接口，因此 Java 虚拟机可以保证该类为单例，这与传统的实现方式不大相同。传统方式中，我们必须确保单例在反序列化期间不能创建任何新实例。</span><br><span class="line">## 07、枚举可与数据库交互</span><br><span class="line">我们可以配合 Mybatis 将数据库字段转换为枚举类型。现在假设有一个数据库字段 check_type 的类型如下：</span><br></pre></td></tr></table></figure>
<p><code>check_type</code> int(1) DEFAULT NULL COMMENT ‘检查类型（1：未通过、2：通过）’,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它对应的枚举类型为 CheckType，代码如下：</span><br></pre></td></tr></table></figure>
<p>public enum CheckType {<br>    NO_PASS(0, “未通过”), PASS(1, “通过”);<br>    private int key;</p>
<pre><code>private String text;

private CheckType(int key, String text) &#123;
    this.key = key;
    this.text = text;
&#125;

public int getKey() &#123;
    return key;
&#125;

public String getText() &#123;
    return text;
&#125;

private static HashMap&lt;Integer,CheckType&gt; map = new HashMap&lt;Integer,CheckType&gt;();
static &#123;
    for(CheckType d : CheckType.values())&#123;
        map.put(d.key, d);
    &#125;
&#125;

public static CheckType parse(Integer index) &#123;
    if(map.containsKey(index))&#123;
        return map.get(index);
    &#125;
    return null;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）CheckType 添加了构造方法，还有两个字段，key 为 int 型，text 为 String 型。</span><br><span class="line">（2）CheckType 中有一个public static CheckType parse(Integer index)方法，可将一个 Integer 通过 key 的匹配转化为枚举类型。</span><br><span class="line">那么现在，我们可以在 Mybatis 的配置文件中使用 typeHandler 将数据库字段转化为枚举类型。</span><br></pre></td></tr></table></figure>
<resultMap id="CheckLog" type="com.entity.CheckLog">
  <id property="id" column="id"/>
  <result property="checkType" column="check_type" typeHandler="com.CheckTypeHandler"></result>
</resultMap>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其中 checkType 字段对应的类如下：</span><br></pre></td></tr></table></figure>
public class CheckLog implements Serializable {

<pre><code>private String id;
private CheckType checkType;

public String getId() &#123;
    return id;
&#125;

public void setId(String id) &#123;
    this.id = id;
&#125;

public CheckType getCheckType() &#123;
    return checkType;
&#125;

public void setCheckType(CheckType checkType) &#123;
    this.checkType = checkType;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CheckTypeHandler 转换器的类源码如下：</span><br></pre></td></tr></table></figure>
<p>public class CheckTypeHandler extends BaseTypeHandler<CheckType> {</p>
<pre><code>@Override
public CheckType getNullableResult(ResultSet rs, String index) throws SQLException &#123;
    return CheckType.parse(rs.getInt(index));
&#125;

@Override
public CheckType getNullableResult(ResultSet rs, int index) throws SQLException &#123;
    return CheckType.parse(rs.getInt(index));
&#125;

@Override
public CheckType getNullableResult(CallableStatement cs, int index) throws SQLException &#123;
    return CheckType.parse(cs.getInt(index));
&#125;

@Override
public void setNonNullParameter(PreparedStatement ps, int index, CheckType val, JdbcType arg3) throws SQLException &#123;
    ps.setInt(index, val.getKey());
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CheckTypeHandler 的核心功能就是调用 CheckType 枚举类的 parse() 方法对数据库字段进行转换。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.55.jpg)</span><br><span class="line">恕我直言，我觉得小伙伴们肯定会用 Java 枚举了，如果还不会，就过来砍我！</span><br><span class="line"># 十七、final 关键字</span><br><span class="line">尽管继承可以让我们重用现有代码，但有时处于某些原因，我们确实需要对可扩展性进行限制，final 关键字可以帮助我们做到这一点。</span><br><span class="line">## 01、final 类</span><br><span class="line">如果一个类使用了 final 关键字修饰，那么它就无法被继承。如果小伙伴们细心观察的话，Java 就有不少 final 类，比如说最常见的 String 类。</span><br></pre></td></tr></table></figure>
<p>public final class String<br>    implements java.io.Serializable, Comparable<String>, CharSequence,<br>               Constable, ConstantDesc {}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">为什么 String 类要设计成 final 的呢？原因大致有以下三个：</span><br><span class="line"></span><br><span class="line">- 为了实现字符串常量池</span><br><span class="line">- 为了线程安全</span><br><span class="line">- 为了 HashCode 的不可变性</span><br><span class="line"></span><br><span class="line">更详细的原因，可以查看我之前写的一篇文章。</span><br><span class="line">任何尝试从 final 类继承的行为将会引发编译错误，为了验证这一点，我们来看下面这个例子，Writer 类是 final 的。</span><br></pre></td></tr></table></figure>
<p>public final class Writer {<br>    private String name;</p>
<pre><code>public String getName() &#123;
    return name;
&#125;

public void setName(String name) &#123;
    this.name = name;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尝试去继承它，编译器会提示以下错误，Writer 类是 final 的，无法继承。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.56.jpg)</span><br><span class="line">不过，类是 final 的，并不意味着该类的对象是不可变的。</span><br></pre></td></tr></table></figure>
<p>Writer writer = new Writer();<br>writer.setName(“沉默王二”);<br>System.out.println(writer.getName()); // 沉默王二</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Writer 的 name 字段的默认值是 null，但可以通过 settter 方法将其更改为“沉默王二”。也就是说，如果一个类只是 final 的，那么它并不是不可变的全部条件。</span><br><span class="line">如果，你想了解不可变类的全部真相，请查看我之前写的文章这次要说不明白immutable类，我就怎么地。突然发现，写系列文章真的妙啊，很多相关性的概念全部涉及到了。我真服了自己了。</span><br><span class="line">把一个类设计成 final 的，有其安全方面的考虑，但不应该故意为之，因为把一个类定义成 final 的，意味着它没办法继承，假如这个类的一些方法存在一些问题的话，我们就无法通过重写的方式去修复它。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.57.jpg)</span><br><span class="line">## 02、final 方法</span><br><span class="line">被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它设计成 final 的。</span><br><span class="line">Thread 类就是一个例子，它本身不是 final 的，这意味着我们可以扩展它，但它的 isAlive() 方法是 final 的：</span><br></pre></td></tr></table></figure>
<p>public class Thread implements Runnable {<br>    public final native boolean isAlive();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要注意的是，该方法是一个本地（native）方法，用于确认线程是否处于活跃状态。而本地方法是由操作系统决定的，因此重写该方法并不容易实现。</span><br><span class="line">Actor 类有一个 final 方法 show()：</span><br></pre></td></tr></table></figure>
<p>public class Actor {<br>    public final void show() {</p>
<pre><code>&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当我们想要重写该方法的话，就会出现编译错误：</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.58.jpg)</span><br><span class="line">如果一个类中的某些方法要被其他方法调用，则应考虑事被调用的方法称为 final 方法，否则，重写该方法会影响到调用方法的使用。</span><br><span class="line">一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？</span><br><span class="line">我能想到的一点，就是前者不能被继承，也就是说方法无法被重写；后者呢，可以被继承，然后追加一些非 final 的方法。没毛病吧？看把我聪明的。</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.59.jpg)</span><br><span class="line">## 03、final 变量</span><br><span class="line">被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。之前被一个小伙伴问过，什么是 effective final，什么是 final，这一点，我在之前的文章也有阐述过，所以这里再贴一下地址：</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.itwanger.com/java/2020/0%E2%80%A6">www.itwanger.com/java/2020/0…</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）final 修饰的基本数据类型</span><br><span class="line">来声明一个 final 修饰的 int 类型的变量：</span><br></pre></td></tr></table></figure>
<p>final int age = 18;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">尝试将它修改为 30，结果编译器生气了：</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.60.jpg)</span><br><span class="line">（2）final 修饰的引用类型</span><br><span class="line">现在有一个普通的类 Pig，它有一个字段 name：</span><br></pre></td></tr></table></figure>
<p>public class Pig {<br>   private String name;</p>
<pre><code>public String getName() &#123;
    return name;
&#125;

public void setName(String name) &#123;
    this.name = name;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在测试类中声明一个 final 修饰的 Pig 对象：</span><br><span class="line"> final Pig pig = new Pig();</span><br><span class="line">如果尝试将 pig 重新赋值的话，编译器同样会生气：</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.61.jpg)</span><br><span class="line">但我们仍然可以去修改 Pig 的字段值：</span><br></pre></td></tr></table></figure>
<p>final Pig pig = new Pig();<br>pig.setName(“特立独行”);<br>System.out.println(pig.getName()); // 特立独行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（3）final 修饰的字段</span><br><span class="line">final 修饰的字段可以分为两种，一种是 static 的，另外一种是没有 static 的，就像下面这样：</span><br></pre></td></tr></table></figure>
<p>public class Pig {<br>   private final int age = 1;<br>   public static final double PRICE = 36.5;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">非 static 的 final 字段必须有一个默认值，否则编译器将会提醒没有初始化：</span><br><span class="line">![](https://www.qyihe.xyz/images/post/10.62.jpg)</span><br><span class="line">static 的 final 字段也叫常量，它的名字应该为大写，可以在声明的时候初始化，也可以通过 static 代码块初始化。</span><br><span class="line"></span><br><span class="line">(4) final 修饰的参数</span><br><span class="line"></span><br><span class="line">final 关键字还可以修饰参数，它意味着参数在方法体内不能被再修改：</span><br></pre></td></tr></table></figure>
<p>public class ArgFinalTest {<br>    public void arg(final int age) {<br>    }</p>
<pre><code>public void arg1(final String name) &#123;
&#125;
</code></pre>
<p>}</p>
<pre><code>如果尝试去修改它的话，编译器会提示以下错误：
![](https://www.qyihe.xyz/images/post/10.63.jpg)
。。。。。。

&gt; 
&gt;转载于[沉默王二](https://juejin.im/post/5ee414c76fb9a047dd2768ea#heading-39)
&gt; 
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.yyisq.com">花绫子</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.yyisq.com/posts/53415/">https://www.yyisq.com/posts/53415/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.yyisq.com" target="_blank">花绫子</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post_share"><div class="social-share" data-image="/img/java.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4a17b156/"><img class="prev-cover" src="/img/Helloworld.webp" onerror="onerror=null;src='/img/404.webp'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello World</div></div></a></div><div class="next-post pull-right"><a href="/posts/5440/"><img class="next-cover" src="https://www.yyisq.com/img/1.webp" onerror="onerror=null;src='/img/404.webp'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Github初始化配置</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avtar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">花绫子</div><div class="author-info__description">一个记录学习笔记的地方</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/qiaoyihe" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="iconfont class icon-github"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="iconfont icon-rss"></i></a></div></div><div class="card-widget latestBB"><div class="item-headline"><i class="fas fa-bolt"></i><span>公告</span></div><div class="item-content"><div class="swiper-container swiper-container-aside">
  <div class="swiper-wrapper swiper-weapper-aside"></div>
</div>
<a class="bb-btn button--animated" href="/talking/" title="查看全部"><i class="far fa-hand-point-right fa-fw"></i> 查看更多 </a>
<script>
  window.kkBBConfig = {
    limit: 7,
    blog:'/talking/',
    api_url:
      'https://636c-cloudbase-baas-6g56sw0n48c42844-1251754947.tcb.qcloud.la/json/bber.json?sign=2f462069d51316ecbf90c134c58ba6d8&t=1666538506'
  }
</script>
<script src="https://cdn.jsdelivr.net/npm/butterfly-bber-swiper/dist/index.min.js"></script>
</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、Java 基本语法简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">01、数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">02、声明变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">03、数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.4.</span> <span class="toc-text">04、关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">05、操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E3%80%81%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.1.</span> <span class="toc-text">①、算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.2.</span> <span class="toc-text">②、逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E3%80%81%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.3.</span> <span class="toc-text">③、比较运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06%E3%80%81%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">06、程序结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07%E3%80%81%E7%BC%96%E8%AF%91%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.</span> <span class="toc-text">07、编译然后执行代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">二、Java 基本数据类型简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E5%B8%83%E5%B0%94"><span class="toc-number">2.1.</span> <span class="toc-text">01、布尔</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81byte"><span class="toc-number">2.2.</span> <span class="toc-text">02、byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81short"><span class="toc-number">2.3.</span> <span class="toc-text">03、short</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04%E3%80%81int"><span class="toc-number">2.4.</span> <span class="toc-text">04、int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05%E3%80%81long"><span class="toc-number">2.5.</span> <span class="toc-text">05、long</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06%E3%80%81float"><span class="toc-number">2.6.</span> <span class="toc-text">06、float</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07%E3%80%81double"><span class="toc-number">2.7.</span> <span class="toc-text">07、double</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08%E3%80%81char"><span class="toc-number">2.8.</span> <span class="toc-text">08、char</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Java-main-%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">三、Java main() 方法简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Java-%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.</span> <span class="toc-text">四、Java 的流程控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.1.</span> <span class="toc-text">if 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-else-%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.2.</span> <span class="toc-text">if-else 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-else-if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.3.</span> <span class="toc-text">if-else-if 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-%E5%B5%8C%E5%A5%97%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.4.</span> <span class="toc-text">if 嵌套语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.5.</span> <span class="toc-text">switch 语句的格式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E6%AF%94%E8%BE%83"><span class="toc-number">4.6.</span> <span class="toc-text">循环语句比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%9A%84-for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.7.</span> <span class="toc-text">普通的 for 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-each"><span class="toc-number">4.8.</span> <span class="toc-text">for-each</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%99%90-for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.9.</span> <span class="toc-text">无限 for 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.10.</span> <span class="toc-text">while 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.11.</span> <span class="toc-text">do-while 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break"><span class="toc-number">4.12.</span> <span class="toc-text">break</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#continue"><span class="toc-number">4.13.</span> <span class="toc-text">continue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Java-%E5%8C%85%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">5.</span> <span class="toc-text">五、Java 包的简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8C%85"><span class="toc-number">5.1.</span> <span class="toc-text">01、创建一个包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81%E4%BD%BF%E7%94%A8%E5%8C%85"><span class="toc-number">5.2.</span> <span class="toc-text">02、使用包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81%E5%85%A8%E5%90%8D"><span class="toc-number">5.3.</span> <span class="toc-text">03、全名</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81Java-%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">6.</span> <span class="toc-text">六、Java 到底是值传递还是引用传递</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92-VS-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">6.1.</span> <span class="toc-text">01、值传递 VS 引用传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">6.2.</span> <span class="toc-text">02、基本类型的参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">6.3.</span> <span class="toc-text">03、引用类型的参数传递</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Java-%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">七、Java 的类和对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81Java-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">八、Java 构造方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Java-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">九、Java 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84-5-%E4%B8%AA%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">9.1.</span> <span class="toc-text">01、抽象类的 5 个关键点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">02、什么时候用抽象类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2e5b9ea2/" title="测试发布日志"><img src="https://www.yyisq.com/img/1.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="测试发布日志"/></a><div class="content"><a class="title" href="/posts/2e5b9ea2/" title="测试发布日志">测试发布日志</a><time datetime="2022-11-12T09:49:36.000Z" title="发表于 2022-11-12 17:49:36">2022-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8859bfd3/" title="试运行"><img src="https://www.yyisq.com/img/3.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="试运行"/></a><div class="content"><a class="title" href="/posts/8859bfd3/" title="试运行">试运行</a><time datetime="2022-11-11T16:27:08.000Z" title="发表于 2022-11-12 00:27:08">2022-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/188331/" title="Java数据类型"><img src="/img/java.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="Java数据类型"/></a><div class="content"><a class="title" href="/posts/188331/" title="Java数据类型">Java数据类型</a><time datetime="2022-11-11T14:00:45.000Z" title="发表于 2022-11-11 22:00:45">2022-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/55041/" title="进制转换"><img src="/img/java.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="进制转换"/></a><div class="content"><a class="title" href="/posts/55041/" title="进制转换">进制转换</a><time datetime="2022-11-10T14:00:45.000Z" title="发表于 2022-11-10 22:00:45">2022-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/55803/" title="java循环"><img src="/img/java.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="java循环"/></a><div class="content"><a class="title" href="/posts/55803/" title="java循环">java循环</a><time datetime="2022-11-10T14:00:45.000Z" title="发表于 2022-11-10 22:00:45">2022-11-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By <a target="_blank" rel="noopener external nofollow noreferrer" href="https://status.yyisq.com/" >花绫子</a></div><div class="framework-info"></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://my-repository-kappa-opal.vercel.app/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://my-repository-kappa-opal.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-MSVN4RXSMW', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>