{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/butterfly/source/css/background.css","path":"css/background.css","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/icon.css","path":"css/icon.css","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/1.jpg","path":"img/1.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/3.jpg","path":"img/3.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/5.webp","path":"img/5.webp","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/8-1.jpg","path":"img/8-1.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/avtar.jpg","path":"img/avtar.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java.webp","path":"img/java.webp","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"94c02d28ad3b91add7f53ec599aacd98424f5884","modified":1627875554656},{"_id":"source/robots.txt","hash":"e0010cf16d364af26c72b7f4ab6e9f18e7e3b8a4","modified":1627826079678},{"_id":"source/_posts/2.md","hash":"4e1f11e985639eb824da3e486948433b9144d5be","modified":1627803633228},{"_id":"source/_data/link.yml","hash":"39c09ab626092140629681ef55e22a8eb3f570d8","modified":1627827140858},{"_id":"source/_posts/4.md","hash":"b499e64805d0dee5238ff10d710b950841580726","modified":1627803706965},{"_id":"source/_posts/3.md","hash":"a8e677d30b70c0ba62f3ea98c9b34e041c9c4793","modified":1627804990902},{"_id":"source/_posts/5.md","hash":"6f3a4f3abf5383d6f71045cdc69af52383b7d875","modified":1627803915973},{"_id":"source/_posts/6.md","hash":"e3a1b1b65ae2fe3a9ca741cf083e520a54afbf2a","modified":1627803658843},{"_id":"source/_posts/8.md","hash":"4300ed94dc67254b1c7b076ee680e66718e8547c","modified":1627803821765},{"_id":"source/_posts/7.md","hash":"a2247c826334e510c6f8a1df22553d37e0114c17","modified":1627803854411},{"_id":"source/_posts/hello-world.md","hash":"db7106abb3296c10987ca832d1715569685fe3ca","modified":1641306295891},{"_id":"source/about/index.md","hash":"924b8c803f3a4a4400f5bee5532f74dd1005d3b8","modified":1664973300325},{"_id":"source/messageboard/index.md","hash":"e2591455e3732c0ab5fd452ac5294279a8627f87","modified":1627803109154},{"_id":"source/photo/index.md","hash":"ed1d9ba960a64204c6069c3397824bf94e0eadb4","modified":1641300870888},{"_id":"source/mood/index.md","hash":"fb17d6e8f480145f31a82e2fc010aae6942f7c0e","modified":1641298656836},{"_id":"source/photo/2020/index.md","hash":"749e50adc4a73eccf81ae4fc039ccef340cdaadd","modified":1627903428319},{"_id":"source/photo/gd/index.md","hash":"4ef89fb0c80b1d51a98481ec5268a502ef398d27","modified":1627903436278},{"_id":"source/photo/gmzr/index.md","hash":"a45fe530e82dce9c63ca32f7233de8982ec5dad4","modified":1627903443664},{"_id":"source/_posts/10.md","hash":"60283dddc64eb307d19f156f8a86fa1988d755fd","modified":1627803737589},{"_id":"source/link/index.md","hash":"692691db9e253028f43b2ceda6053fa53990e880","modified":1664973082971},{"_id":"source/categories/index.md","hash":"a997314b4d0144075e2ad42e6d072c66228d822f","modified":1627786388714},{"_id":"source/tags/index.md","hash":"22b8871c82104949e26022bd562718c50c67ec91","modified":1627786373321},{"_id":"themes/butterfly/_config.yml","hash":"63d1a594969b7b5b97e1babebc7b85ef07c02e4f","modified":499162500000},{"_id":"themes/butterfly/package.json","hash":"0b9365f18b3da34b0af3d0d83d1c53c083ae00a3","modified":1627705500578},{"_id":"themes/butterfly/README_CN.md","hash":"459d6f3200863021bee1fe72a719aef236fb4090","modified":499162500000},{"_id":"themes/butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":499162500000},{"_id":"themes/butterfly/languages/default.yml","hash":"7ca673fb629ea74f5ba5e75b4f0f95248cfb5090","modified":499162500000},{"_id":"themes/butterfly/languages/en.yml","hash":"cd333235ff1648a6bf58dfafc81f2c57672a15a5","modified":499162500000},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"741e522b2387f94764a73844e7b084cc7e927c54","modified":499162500000},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"79a50c40d9f5463f1fa42aa870ac6b8b84540412","modified":499162500000},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":499162500000},{"_id":"themes/butterfly/layout/category.pug","hash":"60c1b795b6e227b5dd81963b51d29d1b81d0bf49","modified":499162500000},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":499162500000},{"_id":"themes/butterfly/layout/page.pug","hash":"82aa988527a11835e7ac86ce4f23b8cd20014dfa","modified":499162500000},{"_id":"themes/butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":499162500000},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":499162500000},{"_id":"themes/butterfly/README.md","hash":"cedd13fcd8c75a68742265dd8eced4087e940ffd","modified":499162500000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":499162500000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":499162500000},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"7d378e328a53cc99d5acc9682dce53f5eb61537d","modified":499162500000},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"4156224c47bfc2482281ac4e4df701c30476ff00","modified":499162500000},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"6e14ca75b7775da88e89f8fc2e72aa1a14e2a4ee","modified":1664976871407},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"1377952022ee0a9eaa7a2fd1098f1571efc468d9","modified":499162500000},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"6f2608c4d93d3d10ae6b2cd7f8918f303f024321","modified":499162500000},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":499162500000},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"2d0453adf92a3fd3466cf0793f14685d17b8b51d","modified":499162500000},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"8dafc2dcd8c33f70a546fee443f0b6d80b3cd243","modified":499162500000},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":499162500000},{"_id":"themes/butterfly/scripts/events/init.js","hash":"018aa446265fe627301b1d53d7cba4f4ff1960ac","modified":499162500000},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":499162500000},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"4cc2d517195c8779471d326ada09f9371cbad4dd","modified":499162500000},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"9821872007cf57efae4b728dc575ef9d004547bb","modified":499162500000},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":499162500000},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":499162500000},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"65f2442e04c4defd16e7c1e67701d3bb41d9577a","modified":499162500000},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":499162500000},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"54b9324e3506dcc9c9991ef5e11e37e66e21594f","modified":499162500000},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"b816ded1451f28c7c54151ffe6c259b110253ae3","modified":499162500000},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"94826ea6bcc4d2304199adae12c4e2b272caf529","modified":499162500000},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"f33858ffb9e88191e644796e11d2f901eb332308","modified":499162500000},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":499162500000},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":499162500000},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"35f073021db93699fcac9ef351e26c59c31aadf7","modified":499162500000},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":499162500000},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":499162500000},{"_id":"themes/butterfly/source/css/background.css","hash":"322e0afa6751deec5b84526f2caf99065ecc306b","modified":1641300368042},{"_id":"themes/butterfly/source/css/icon.css","hash":"936554c3085e4f42417970622babf75fc77acc4d","modified":1627789842502},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":499162500000},{"_id":"themes/butterfly/source/css/var.styl","hash":"40c3f64422205a24e68ce1ad8fe8163f24fdd525","modified":499162500000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":499162500000},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":499162500000},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":499162500000},{"_id":"themes/butterfly/source/img/5.webp","hash":"f44b98e706ba1b96c172073f8fe894f9543fa9fc","modified":1593695469646},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":499162500000},{"_id":"themes/butterfly/source/img/8-1.jpg","hash":"8b3552d4453e781a78e95bba30301f1e152a9266","modified":1592995734194},{"_id":"themes/butterfly/source/img/avtar.jpg","hash":"574fb19de8ce94ba7ce2390ff3db927e0a2535f4","modified":1627730402285},{"_id":"themes/butterfly/source/img/favicon.png","hash":"96a194a9ecb161770dab8da7792c9b7bcaa8861e","modified":1591186528000},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":499162500000},{"_id":"themes/butterfly/source/img/java.webp","hash":"fd19ad7051dfc084a950ed8e265477a589afabcf","modified":1593695380088},{"_id":"themes/butterfly/source/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":499162500000},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":499162500000},{"_id":"themes/butterfly/source/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":499162500000},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":499162500000},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"4def0aab9e2172ad1f29abd1535d8e08ff23aa0b","modified":499162500000},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"90d01b88d0f406d00184960b1afe9230aec2ebe6","modified":499162500000},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"889ef16fa34a39e5533bc170e62f20f3450cc522","modified":499162500000},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":499162500000},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":499162500000},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"e55f8bdb876d5429a908498db1307b94094c0d06","modified":499162500000},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":499162500000},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":499162500000},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":499162500000},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"24370508ee87f14418e8f06e9d79ad8c52a342c4","modified":499162500000},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"c205b9fd72b2fe19e6d15c5b5ab0fb38c653032e","modified":499162500000},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"92f81a437c9db49f7ebcf608bc09488ecdb55a21","modified":499162500000},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":499162500000},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":499162500000},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":499162500000},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":499162500000},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"4c3c5cb69b3aead8c232cb0fbc251929f28aad75","modified":499162500000},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":499162500000},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"b53a2d4f9c37b375a4446d2273dcfb7712d91b3e","modified":499162500000},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":499162500000},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"dbec869c62135695495703a29ad7655e9965d461","modified":499162500000},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":499162500000},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"5b404356f311d2ee36478291ca3553210867b738","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"933cb710d2dbcea25c6426a57c6f49d2f48b792c","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"d50e5c22cd6bc3c378bc581918136746cfa3447f","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"0366c658cdcff839aa1df2e2d252a03a53fd427e","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"27afd2274bd5f2cbbf1bad9f0afe2b2b72c213ca","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":499162500000},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"eda47f3e807a466ba8275627ea936c5100c43818","modified":499162500000},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"e211efbd1952d4b1b881287aa43423133c1d166e","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"b5525891f6affd02c1ea3b2327c026882efe428b","modified":499162500000},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":499162500000},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"85e72c70a0cef29e40be1968f5d23b06c6f8e3aa","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"7feb755ca7c22da36bbad11e74ecd95fdcf3b879","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"dd8cdf639ba2b726437c77fa7aa8d5edbabe8f9b","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"98235fcda3b87ad6f7e91eafbed94d0d6ae847ca","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"90fe01c968696a9f791cb2b84fca621cbbb56f47","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"d748951d9fbcd04dda839085af78b01b8fa04cba","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"0551c5893d1589a3d17ce161e50ecb1d724cc6e8","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"ea1ba40dd5954c2ed718a126336fb7f94da4e66f","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"7a072589e6097dbe942783131964f2372fdf1eb6","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"2c5fb77c448ce0a734040c8ce532b28fed688899","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"f1b63892baafa48ab872bc79671d57aafd511f6c","modified":499162500000},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"978c397d0966eaf9e6e2afd13866f8f4900b509f","modified":499162500000},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"4e629f510b73f998ab208b739c5bd7dcd168d1a7","modified":499162500000},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"f59a9a0059d5261251bdd6de45aa97dd2d11e633","modified":499162500000},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"b0488ceacde74af139d66c8db5cb36cc21737b9b","modified":499162500000},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":499162500000},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"97fec1e814f88237862f4d800a35362b802f6625","modified":499162500000},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":499162500000},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"2cc49d3f6a6beb9f7bff93e292f88aa5681da1d0","modified":499162500000},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":499162500000},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"7c4152162a03aa8331a783df5695e4ebbb816a8c","modified":499162500000},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"ae9336bf31cdad08ff586ead4295912a96563c76","modified":499162500000},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"f168f5c669978f633abe118cdcc4a12cfc883c01","modified":499162500000},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"6befe4c51b86d0c1de130beeecad9e28d6442713","modified":499162500000},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"1c3f9d7efc3b9dfcfa8926a1132d0c44ffc7d4b2","modified":499162500000},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"53ecae272e16223a436c497abbf25dd5f0fc4aaa","modified":499162500000},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":499162500000},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"21964fdd6d74ffbea519418bab65024aee5f3736","modified":499162500000},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":499162500000},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"f741e85295ce15c70a6027ec15a542636dd5dcca","modified":499162500000},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":499162500000},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":499162500000},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":499162500000},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":499162500000},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"400ce038548d6f9ddb486150c724c87b6923a88b","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"2e52c64e89f16267596a8465841dd46f51820982","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"c46a932257212f82e4a9974fbbc5de8878c8b383","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0b7571919e8ad51285deda56a1868fccf8c563d7","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"da9813f8dc0d388869c15413cf056012cfb69e1a","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"bafb3d5710824caa59a56017afb058fd2b4eac65","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"16378d8646ea3f4ac99c18f0296dd85b13f9d775","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"2b45fe09d5b591dca156b76dae99981f8d8e1c61","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"36f3c603d2a2ecddaa6d2675a89d76ad94968f72","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f9b00ead54573ba6e6eb33481588af144aab648d","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"a47d8f9f593091cc91192c0c49deaa2c0d2317fd","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"3f3a3cd8bea2103dedd754f767aca5cb84d5f586","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"b443d6b16baf3ea250041342cc0361a42a412b7f","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"34088a15655704d12e9b1807b47b3f6a860c9eec","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"cb38ffe911023092a90a28f2ba8317a92b22cd0c","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"59b4c26a827ace5a54855881d199977103ff6f50","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"a2bc2601b7e0ae5caf1fc51a07390562d928620a","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"d8f59e94eafc669c49349561dc5bbea3915aecb7","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"613280d61b8ab9612014ec016ae3d3698d36fd1a","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":499162500000},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":499162500000},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"8c0726fb8d9a497d2f900b0be2845efaa68e3d87","modified":499162500000},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"89cbcc8e087788ecec18b5fa58710afacdb7d080","modified":499162500000},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":499162500000},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"917e0e399e117217184ca63d3eb5c4843bcccf7b","modified":499162500000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":499162500000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"e0e7065124ef0d99f8322a47bc47838982e04ad0","modified":499162500000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":499162500000},{"_id":"themes/butterfly/source/img/1.jpg","hash":"962b77f05c807cb5dc78e5fc1d1b264674845e80","modified":1592315728937},{"_id":"themes/butterfly/source/img/3.jpg","hash":"8633b03de61c303306a84e62dd0f31c0a35fc135","modified":1592914039224},{"_id":"public/baidu_urls.txt","hash":"c73c845bad0093f4411c614496f42b8235881e71","modified":1664971913395},{"_id":"public/atom.xml","hash":"bcf94c4a22f687b681fb66fa7d3a191b58dc2f8b","modified":1664971913395},{"_id":"public/baidusitemap.xml","hash":"afdf1451df463fc5a41ca40d27600f0b704f270b","modified":1664971913395},{"_id":"public/search.xml","hash":"78f607183798fcbbc83a3160f467bf1a336dc70e","modified":1641300090834},{"_id":"public/sitemap.xml","hash":"0bb44f1c68305be7a384508ed99306800234a2d3","modified":1665017906441},{"_id":"public/categories/index.html","hash":"b656af6581c8afa038438a813a8b0fb041f0bb58","modified":1665017906441},{"_id":"public/about/index.html","hash":"fd9d60e9abeb087823ee5d0630d24923cd971a1e","modified":1665017906441},{"_id":"public/messageboard/index.html","hash":"abea92a9de0a8fed0680daf965e130ea14306049","modified":1665017906441},{"_id":"public/photo/index.html","hash":"d1952132cee00ba7510bd558ee608bd6e1845d2a","modified":1665017906441},{"_id":"public/tags/index.html","hash":"3b11720506691ca80bafd898bf7ed93452fcfe9e","modified":1665018504646},{"_id":"public/photo/2020/index.html","hash":"2ea49e1c262f3d06ea05e1fd343fc9725786b462","modified":1665017906441},{"_id":"public/photo/gd/index.html","hash":"c6ee57196def6a94c10464cca5477be79078a9a0","modified":1665017906441},{"_id":"public/photo/gmzr/index.html","hash":"e66dbb74c9c0122b6679061c1e480ee809b0dd37","modified":1665017906441},{"_id":"public/link/index.html","hash":"3135b2b0ed57f636f9fa3bd19bc8e4da04c538b3","modified":1665017906441},{"_id":"public/mood/index.html","hash":"02c787312464582a6b784f3dd0b1d7b5f7ff2738","modified":1665017906441},{"_id":"public/posts/4a17b156.html","hash":"ed7b3da205476bb09a73ca0b787127a8c24871e5","modified":1665017906441},{"_id":"public/posts/53415.html","hash":"2e612d1f4c737ffc31c4d11fa7eeeaa85c84302c","modified":1665017906441},{"_id":"public/posts/5700.html","hash":"5a74c7b3c4639c326aaf5d7bfcf2cf44cc450e56","modified":1665017906441},{"_id":"public/posts/55803.html","hash":"3ac618707dbb6cfb80baa93add5a0268b668087a","modified":1665017906441},{"_id":"public/posts/65180.html","hash":"6498b6d503ed74f825f3e516c377c5b9dda9dfd7","modified":1665017906441},{"_id":"public/posts/39064.html","hash":"a8c1e767f0e37f5225619440ba4f52fdc1319523","modified":1665017906441},{"_id":"public/posts/55041.html","hash":"087906bd9651c63e72be7f26478adb8576e02454","modified":1665017906441},{"_id":"public/posts/5440.html","hash":"a2ea115690f157d9d3e2c6f83b889391fc543ae4","modified":1665017906441},{"_id":"public/posts/188331.html","hash":"a7bd71bcc989dd0c8b68bda054b72d7ba24e4c15","modified":1665017906441},{"_id":"public/archives/index.html","hash":"b4b8a49019d714e34a9d302863354679b3a7e103","modified":1665018504646},{"_id":"public/archives/2020/index.html","hash":"62f50b3c12a736bda1af04f04117042f58762c1d","modified":1665018504646},{"_id":"public/archives/2020/06/index.html","hash":"4ecf9fa20ede7ff27d22f5d1d55ad6ef9383d54d","modified":1665018504646},{"_id":"public/archives/2020/07/index.html","hash":"41c9174bea6bfb97eb0e219d5a27c1110f5ba035","modified":1665018504646},{"_id":"public/archives/2021/index.html","hash":"c7d0660ba5602c14eb3c1d300ee0f689f0f4ef92","modified":1641305548893},{"_id":"public/archives/2021/08/index.html","hash":"64108706ffc172cc7373d973264b55dc1e7386d1","modified":1641305548893},{"_id":"public/categories/技术/index.html","hash":"b71696ba62120fc0b1b29a061e446dbffdfa62d8","modified":1665018504646},{"_id":"public/categories/文章/index.html","hash":"ffd8594f56a960eb5bcf6f9d0247b396eefab97b","modified":1665018504646},{"_id":"public/index.html","hash":"b940b356915b1907e0270276f08d7145d38182f0","modified":1665018504646},{"_id":"public/tags/java/index.html","hash":"1e95605fc310694f655eed4dcb5cb26f9243e369","modified":1665018504646},{"_id":"public/tags/基础/index.html","hash":"dc6852dc5b9af2619e7524d3d01bb71038f35f86","modified":1665018504646},{"_id":"public/tags/Github/index.html","hash":"94c114f02c5d16dc1879164d7b220d5f4755a042","modified":1665018504646},{"_id":"public/tags/进制/index.html","hash":"02fadc33eb5bd74cf32268409f86c4896d7e9dcb","modified":1665018504646},{"_id":"public/tags/书籍/index.html","hash":"3198217ca356daefc0c7dfa0b7afce30f592abe3","modified":1665018504646},{"_id":"public/robots.txt","hash":"e0010cf16d364af26c72b7f4ab6e9f18e7e3b8a4","modified":1641300090834},{"_id":"public/CNAME","hash":"94c02d28ad3b91add7f53ec599aacd98424f5884","modified":1641300090834},{"_id":"public/img/5.webp","hash":"f44b98e706ba1b96c172073f8fe894f9543fa9fc","modified":1641300090834},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1641300090834},{"_id":"public/img/8-1.jpg","hash":"8b3552d4453e781a78e95bba30301f1e152a9266","modified":1641300090834},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1641300090834},{"_id":"public/img/avtar.jpg","hash":"574fb19de8ce94ba7ce2390ff3db927e0a2535f4","modified":1641300090834},{"_id":"public/img/favicon.png","hash":"96a194a9ecb161770dab8da7792c9b7bcaa8861e","modified":1641300090834},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1641300090834},{"_id":"public/img/java.webp","hash":"fd19ad7051dfc084a950ed8e265477a589afabcf","modified":1641300090834},{"_id":"public/css/background.css","hash":"e2f35705cdb164b844212ff9fab8470e8daeeb1c","modified":1641301106692},{"_id":"public/css/icon.css","hash":"936554c3085e4f42417970622babf75fc77acc4d","modified":1641300090834},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641300090834},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1641300090834},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1641300090834},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1641300090834},{"_id":"public/css/index.css","hash":"82ae9417c9d803902ad0e52709f1ebfaefa901d4","modified":1641300090834},{"_id":"public/img/1.jpg","hash":"962b77f05c807cb5dc78e5fc1d1b264674845e80","modified":1641300090834},{"_id":"public/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1641300090834},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1641300090834},{"_id":"public/img/3.jpg","hash":"8633b03de61c303306a84e62dd0f31c0a35fc135","modified":1641300090834},{"_id":"source/photo/2022/index.md","hash":"0416672cb4ec801e808b304025b6b40ffe0fbdf0","modified":1641300878979},{"_id":"public/photo/2022/index.html","hash":"7b2cf8885e8e990bb9db95c5d55dd7f42abb37f3","modified":1665017906441},{"_id":"public/archives/2022/index.html","hash":"86c4bd9a5f84aab730b786d3c67aae6e97dbb778","modified":1665018504646},{"_id":"public/archives/2022/01/index.html","hash":"1c7aa054d376d978816f1f65f774ab81923da64c","modified":1665018504646}],"Category":[{"name":"技术","_id":"cky03p47s00040cuma195cfb2"},{"name":"文章","_id":"cky03p490000r0cumc5ydbecm"}],"Data":[{"_id":"link","data":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}],"Page":[{"title":"分类","date":"2018-01-04T16:00:00.000Z","comments":0,"type":"categories","aside":false,"_content":"\n","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-01-05 00:00:00\ncomments: false\ntype: \"categories\"\naside: false\n---\n\n","updated":"2021-08-01T02:53:08.714Z","path":"categories/index.html","layout":"page","_id":"cky03p47d00000cum408th85a","content":"","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"cover":"https://www.qiaoyihe.com/img/1.jpg","excerpt":"","more":""},{"date":"2020-06-01T13:00:32.000Z","comments":0,"aside":false,"title":"关于乔一禾","_content":"- 2020.06.01 基于hexo搭建好了第一版博客\n- 2020.06.05 更换了博客主题为Butterfly,并且完善了博客各项功能\n- 2020.06.17 升级博客主题Butterfly版本为3.0.0-RC-1\n感谢作者[Jerryc](https://jerryc.me/posts/21cfbf15), 主题地址:[传送门](https://github.com/jerryc127/hexo-theme-butterfly)\n- 2020.06.30 添加随机背景图，去掉Banner图，去掉首页页脚背景，修改Valine样式\n- 2020.07.01 添加每日打卡\n- 2021.07.08 购买域名qiaoyihe.com\n- 2021.08.01 更换域名为qiaoyihe.com，更新Butterfly版本为v3.8.3，删除每日打卡，增加渐变背景，渐变页脚，评论由valine更换为Twikoo\n- 2022.10.05 购买并更换域名为yyisq.com\n- 2021.10.05 购买域名yyisq.cc\n\n---\n# 关于我\n- 性别：男\n- 爱好：折腾、折腾、折腾再折腾\n- 坐标：地球\n- 目标: 后端开发工程师\n---","source":"about/index.md","raw":"---\ndate: 2020-06-01 21:00:32\ncomments: false\naside: false\ntitle: 关于乔一禾\n---\n- 2020.06.01 基于hexo搭建好了第一版博客\n- 2020.06.05 更换了博客主题为Butterfly,并且完善了博客各项功能\n- 2020.06.17 升级博客主题Butterfly版本为3.0.0-RC-1\n感谢作者[Jerryc](https://jerryc.me/posts/21cfbf15), 主题地址:[传送门](https://github.com/jerryc127/hexo-theme-butterfly)\n- 2020.06.30 添加随机背景图，去掉Banner图，去掉首页页脚背景，修改Valine样式\n- 2020.07.01 添加每日打卡\n- 2021.07.08 购买域名qiaoyihe.com\n- 2021.08.01 更换域名为qiaoyihe.com，更新Butterfly版本为v3.8.3，删除每日打卡，增加渐变背景，渐变页脚，评论由valine更换为Twikoo\n- 2022.10.05 购买并更换域名为yyisq.com\n- 2021.10.05 购买域名yyisq.cc\n\n---\n# 关于我\n- 性别：男\n- 爱好：折腾、折腾、折腾再折腾\n- 坐标：地球\n- 目标: 后端开发工程师\n---","updated":"2022-10-05T12:35:00.325Z","path":"about/index.html","_id":"cky03p47o00020cumdhbf7eyd","layout":"page","content":"<ul>\n<li>2020.06.01 基于hexo搭建好了第一版博客</li>\n<li>2020.06.05 更换了博客主题为Butterfly,并且完善了博客各项功能</li>\n<li>2020.06.17 升级博客主题Butterfly版本为3.0.0-RC-1<br>感谢作者<a href=\"https://jerryc.me/posts/21cfbf15\">Jerryc</a>, 主题地址:<a href=\"https://github.com/jerryc127/hexo-theme-butterfly\">传送门</a></li>\n<li>2020.06.30 添加随机背景图，去掉Banner图，去掉首页页脚背景，修改Valine样式</li>\n<li>2020.07.01 添加每日打卡</li>\n<li>2021.07.08 购买域名qiaoyihe.com</li>\n<li>2021.08.01 更换域名为qiaoyihe.com，更新Butterfly版本为v3.8.3，删除每日打卡，增加渐变背景，渐变页脚，评论由valine更换为Twikoo</li>\n<li>2022.10.05 购买并更换域名为yyisq.com</li>\n<li>2021.10.05 购买域名yyisq.cc</li>\n</ul>\n<hr>\n<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><ul>\n<li>性别：男</li>\n<li>爱好：折腾、折腾、折腾再折腾</li>\n<li>坐标：地球</li>\n<li>目标: 后端开发工程师</li>\n</ul>\n<hr>\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"cover":"https://www.yyisq.com/img/3.jpg","excerpt":"","more":"<ul>\n<li>2020.06.01 基于hexo搭建好了第一版博客</li>\n<li>2020.06.05 更换了博客主题为Butterfly,并且完善了博客各项功能</li>\n<li>2020.06.17 升级博客主题Butterfly版本为3.0.0-RC-1<br>感谢作者<a href=\"https://jerryc.me/posts/21cfbf15\">Jerryc</a>, 主题地址:<a href=\"https://github.com/jerryc127/hexo-theme-butterfly\">传送门</a></li>\n<li>2020.06.30 添加随机背景图，去掉Banner图，去掉首页页脚背景，修改Valine样式</li>\n<li>2020.07.01 添加每日打卡</li>\n<li>2021.07.08 购买域名qiaoyihe.com</li>\n<li>2021.08.01 更换域名为qiaoyihe.com，更新Butterfly版本为v3.8.3，删除每日打卡，增加渐变背景，渐变页脚，评论由valine更换为Twikoo</li>\n<li>2022.10.05 购买并更换域名为yyisq.com</li>\n<li>2021.10.05 购买域名yyisq.cc</li>\n</ul>\n<hr>\n<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><ul>\n<li>性别：男</li>\n<li>爱好：折腾、折腾、折腾再折腾</li>\n<li>坐标：地球</li>\n<li>目标: 后端开发工程师</li>\n</ul>\n<hr>\n"},{"date":"2021-07-31T08:47:24.000Z","type":"link","aside":false,"title":"友情链接","_content":"---\n## 友链申请格式\n- Blog 名字：乔一禾\n- Blog 地址：https://www.yyisq.com\n- Blog 头像：https://www.yyisq.com/img/avtar.jpg\n- Blog 简介：一个记录学习笔记的地方\n\n\n\n","source":"link/index.md","raw":"\n---\ndate: 2021-07-31 16:47:24\ntype: \"link\"\naside: false\ntitle: 友情链接\n---\n---\n## 友链申请格式\n- Blog 名字：乔一禾\n- Blog 地址：https://www.yyisq.com\n- Blog 头像：https://www.yyisq.com/img/avtar.jpg\n- Blog 简介：一个记录学习笔记的地方\n\n\n\n","updated":"2022-10-05T12:31:22.971Z","path":"link/index.html","_id":"cky03p47w00060cumak0o21af","comments":1,"layout":"page","content":"<hr>\n<h2 id=\"友链申请格式\"><a href=\"#友链申请格式\" class=\"headerlink\" title=\"友链申请格式\"></a>友链申请格式</h2><ul>\n<li>Blog 名字：乔一禾</li>\n<li>Blog 地址：<a href=\"https://www.yyisq.com/\">https://www.yyisq.com</a></li>\n<li>Blog 头像：<a href=\"https://www.yyisq.com/img/avtar.jpg\">https://www.yyisq.com/img/avtar.jpg</a></li>\n<li>Blog 简介：一个记录学习笔记的地方</li>\n</ul>\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"cover":"https://www.yyisq.com/img/3.jpg","excerpt":"","more":"<hr>\n<h2 id=\"友链申请格式\"><a href=\"#友链申请格式\" class=\"headerlink\" title=\"友链申请格式\"></a>友链申请格式</h2><ul>\n<li>Blog 名字：乔一禾</li>\n<li>Blog 地址：<a href=\"https://www.yyisq.com/\">https://www.yyisq.com</a></li>\n<li>Blog 头像：<a href=\"https://www.yyisq.com/img/avtar.jpg\">https://www.yyisq.com/img/avtar.jpg</a></li>\n<li>Blog 简介：一个记录学习笔记的地方</li>\n</ul>\n"},{"title":"留言板","date":"2018-01-04T16:00:00.000Z","aside":false,"_content":"---\n\n<div align=center>\n<span style='color: #FE2E2E;font-size:20px;'>有什么想说的话都写在这里吧！</span>\n</div>","source":"messageboard/index.md","raw":"---\ntitle: 留言板\ndate: 2018-01-05 00:00:00\naside: false\n---\n---\n\n<div align=center>\n<span style='color: #FE2E2E;font-size:20px;'>有什么想说的话都写在这里吧！</span>\n</div>","updated":"2021-08-01T07:31:49.154Z","path":"messageboard/index.html","comments":1,"layout":"page","_id":"cky03p47z00080cum7s42fpy8","content":"<hr>\n<div align=center>\n<span style='color: #FE2E2E;font-size:20px;'>有什么想说的话都写在这里吧！</span>\n</div>","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"cover":"https://www.qiaoyihe.com/img/1.jpg","excerpt":"","more":"<hr>\n<div align=center>\n<span style='color: #FE2E2E;font-size:20px;'>有什么想说的话都写在这里吧！</span>\n</div>"},{"title":"相册","type":"相册","comments":0,"aside":false,"date":"2020-06-06T11:46:50.000Z","_content":"# 关于生活\n<div class=\"gallery-group-main\">\n{% galleryGroup '2021' '随手记录的图片' '/photo/2020' https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2020.jpg %}\n{% galleryGroup '2022' '随手记录的图片' '/photo/2022' https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2022.jpg %}\n</div>\n\n# 关于动漫\n\n<div class=\"gallery-group-main\">\n{% galleryGroup '鬼刀' '关于鬼刀的图片' '/photo/gd' https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd.jpg %}\n\n{% galleryGroup '鬼灭之刃' '关于鬼灭之刃的图片' '/photo/gmzr' https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr.jpg %}\n</div>\n","source":"photo/index.md","raw":"---\ntitle: 相册\ntype: 相册\ncomments: false\naside: false\ndate: 2020-06-06 19:46:50\n---\n# 关于生活\n<div class=\"gallery-group-main\">\n{% galleryGroup '2021' '随手记录的图片' '/photo/2020' https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2020.jpg %}\n{% galleryGroup '2022' '随手记录的图片' '/photo/2022' https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2022.jpg %}\n</div>\n\n# 关于动漫\n\n<div class=\"gallery-group-main\">\n{% galleryGroup '鬼刀' '关于鬼刀的图片' '/photo/gd' https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd.jpg %}\n\n{% galleryGroup '鬼灭之刃' '关于鬼灭之刃的图片' '/photo/gmzr' https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr.jpg %}\n</div>\n","updated":"2022-01-04T12:54:30.888Z","path":"photo/index.html","_id":"cky03p483000a0cumbuk39z0o","layout":"page","content":"<h1 id=\"关于生活\"><a href=\"#关于生活\" class=\"headerlink\" title=\"关于生活\"></a>关于生活</h1><div class=\"gallery-group-main\">\n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2020.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">2021</div>\n  <p>随手记录的图片</p>\n  <a href='/photo/2020'></a>\n  </figcaption>\n  </figure>\n  \n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2022.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">2022</div>\n  <p>随手记录的图片</p>\n  <a href='/photo/2022'></a>\n  </figcaption>\n  </figure>\n  \n</div>\n\n<h1 id=\"关于动漫\"><a href=\"#关于动漫\" class=\"headerlink\" title=\"关于动漫\"></a>关于动漫</h1><div class=\"gallery-group-main\">\n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">鬼刀</div>\n  <p>关于鬼刀的图片</p>\n  <a href='/photo/gd'></a>\n  </figcaption>\n  </figure>\n  \n\n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">鬼灭之刃</div>\n  <p>关于鬼灭之刃的图片</p>\n  <a href='/photo/gmzr'></a>\n  </figcaption>\n  </figure>\n  \n</div>\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"cover":"https://www.qiaoyihe.com/img/3.jpg","excerpt":"","more":"<h1 id=\"关于生活\"><a href=\"#关于生活\" class=\"headerlink\" title=\"关于生活\"></a>关于生活</h1><div class=\"gallery-group-main\">\n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2020.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">2021</div>\n  <p>随手记录的图片</p>\n  <a href='/photo/2020'></a>\n  </figcaption>\n  </figure>\n  \n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2022.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">2022</div>\n  <p>随手记录的图片</p>\n  <a href='/photo/2022'></a>\n  </figcaption>\n  </figure>\n  \n</div>\n\n<h1 id=\"关于动漫\"><a href=\"#关于动漫\" class=\"headerlink\" title=\"关于动漫\"></a>关于动漫</h1><div class=\"gallery-group-main\">\n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">鬼刀</div>\n  <p>关于鬼刀的图片</p>\n  <a href='/photo/gd'></a>\n  </figcaption>\n  </figure>\n  \n\n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">鬼灭之刃</div>\n  <p>关于鬼灭之刃的图片</p>\n  <a href='/photo/gmzr'></a>\n  </figcaption>\n  </figure>\n  \n</div>\n"},{"title":"标签","date":"2018-01-04T16:00:00.000Z","type":"tags","comments":0,"aside":false,"_content":"\n","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-01-05 00:00:00\ntype: \"tags\"\ncomments: false\naside: false\n---\n\n","updated":"2021-08-01T02:52:53.321Z","path":"tags/index.html","layout":"page","_id":"cky03p488000e0cum58z93gwb","content":"","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"cover":"https://www.qiaoyihe.com/img/1.jpg","excerpt":"","more":""},{"comments":0,"aside":false,"_content":"{% gallery %}\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2020/1.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2020/2.jpg)\n\n{% endgallery %}\n\n","source":"photo/2020/index.md","raw":"---\ncomments: false\naside: false\n---\n{% gallery %}\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2020/1.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2020/2.jpg)\n\n{% endgallery %}\n\n","date":"2022-01-04T10:55:44.956Z","updated":"2021-08-02T11:23:48.319Z","path":"photo/2020/index.html","title":"","layout":"page","_id":"cky03p48c000g0cumgt7e2if4","content":"<div class=\"justified-gallery\"><p><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2020/1.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2020/2.jpg\"></p>\n          </div>\n\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"cover":"https://www.qiaoyihe.com/img/1.jpg","excerpt":"","more":"<div class=\"justified-gallery\"><p><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2020/1.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2020/2.jpg\"></p>\n          </div>\n\n"},{"title":"心情墙","type":"心情墙","noDate":"true","comments":0,"aside":false,"_content":"\n<script src=\"https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"></script>\n<link type=\"text/css\" rel=\"styleSheet\"  href=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/css/mood.css\" />\n<center>  \n<section class=\"timeline\" style=\"padding-bottom: 50px\">\n<ul>\n<li class=\"in-view\">\n\t<div>\n\t<time>2021/1/4</time>\n\t<div class=\"discovery\">\n\t\t<span >come</span>\n\t\t<p> 认真复习！</p>\n\t</div>\n</li>\n<li class=\"in-view\">\n\t<div>\n\t<time>2021/1/4</time>\n\t<div class=\"discovery\">\n\t\t<span >come</span>\n\t\t<p> 认真复习！</p>\n\t</div>\n</li>\n<li class=\"in-view\">\n\t<div>\n\t<time>2021/1/4</time>\n\t<div class=\"discovery\">\n\t\t<span >come</span>\n\t\t<p> 认真复习！</p>\n\t</div>\n</li>\n<li class=\"in-view\">\n\t<div>\n\t<time>2021/1/4</time>\n\t<div class=\"discovery\">\n\t\t<span >come</span>\n\t\t<p> 认真复习！</p>\n\t</div>\n</li>\n<li class=\"in-view\">\n\t<div>\n\t<time>2020/7/1</time>\n\t<div class=\"discovery\">\n\t\t<span >行动起来</span>\n\t\t<p> 倒计时30天考试！</p>\n\t</div>\n</li>\n<li class=\"in-view\">\n\t<div>\n\t<time>2020/6/5</time>\n\t<div class=\"discovery\">\n\t\t<span >心情墙</span>\n\t\t<p> 博客添加心情墙，记录生活中的点滴😁！</p>\n\t</div>\n</li>\n\n            \n</ul>\n</section>\n\n<script>\n\n        $(function () {\n            function isEmpty(obj) {\n                if (typeof obj == \"undefined\" || obj == null || obj == \"\") {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n\n        })\n        var items = document.querySelectorAll(\".timeline li\");\n\n        function isElementInViewport(el) {\n            var rect = el.getBoundingClientRect();\n            return (\n                rect.top >= 0 &&\n                rect.left >= 0 &&\n                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n                rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n            );\n        }\n\n        function callbackFunc() {\n            for (var i = 0; i < items.length; i++) {\n                if (isElementInViewport(items[i])) {\n                    if (!items[i].classList.contains(\"in-view\")) {\n                        items[i].classList.add(\"in-view\");\n                    }\n                } else if (items[i].classList.contains(\"in-view\")) {\n                    items[i].classList.remove(\"in-view\");\n                }\n            }\n        }\n\n        window.addEventListener(\"load\", callbackFunc);\n        window.addEventListener(\"scroll\", callbackFunc);\n    </script>\n\n  ","source":"mood/index.md","raw":"---\ntitle: 心情墙\ntype: 心情墙\nnoDate: 'true'\ncomments: 'false'\naside: false\n---\n\n<script src=\"https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"></script>\n<link type=\"text/css\" rel=\"styleSheet\"  href=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/css/mood.css\" />\n<center>  \n<section class=\"timeline\" style=\"padding-bottom: 50px\">\n<ul>\n<li class=\"in-view\">\n\t<div>\n\t<time>2021/1/4</time>\n\t<div class=\"discovery\">\n\t\t<span >come</span>\n\t\t<p> 认真复习！</p>\n\t</div>\n</li>\n<li class=\"in-view\">\n\t<div>\n\t<time>2021/1/4</time>\n\t<div class=\"discovery\">\n\t\t<span >come</span>\n\t\t<p> 认真复习！</p>\n\t</div>\n</li>\n<li class=\"in-view\">\n\t<div>\n\t<time>2021/1/4</time>\n\t<div class=\"discovery\">\n\t\t<span >come</span>\n\t\t<p> 认真复习！</p>\n\t</div>\n</li>\n<li class=\"in-view\">\n\t<div>\n\t<time>2021/1/4</time>\n\t<div class=\"discovery\">\n\t\t<span >come</span>\n\t\t<p> 认真复习！</p>\n\t</div>\n</li>\n<li class=\"in-view\">\n\t<div>\n\t<time>2020/7/1</time>\n\t<div class=\"discovery\">\n\t\t<span >行动起来</span>\n\t\t<p> 倒计时30天考试！</p>\n\t</div>\n</li>\n<li class=\"in-view\">\n\t<div>\n\t<time>2020/6/5</time>\n\t<div class=\"discovery\">\n\t\t<span >心情墙</span>\n\t\t<p> 博客添加心情墙，记录生活中的点滴😁！</p>\n\t</div>\n</li>\n\n            \n</ul>\n</section>\n\n<script>\n\n        $(function () {\n            function isEmpty(obj) {\n                if (typeof obj == \"undefined\" || obj == null || obj == \"\") {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n\n        })\n        var items = document.querySelectorAll(\".timeline li\");\n\n        function isElementInViewport(el) {\n            var rect = el.getBoundingClientRect();\n            return (\n                rect.top >= 0 &&\n                rect.left >= 0 &&\n                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n                rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n            );\n        }\n\n        function callbackFunc() {\n            for (var i = 0; i < items.length; i++) {\n                if (isElementInViewport(items[i])) {\n                    if (!items[i].classList.contains(\"in-view\")) {\n                        items[i].classList.add(\"in-view\");\n                    }\n                } else if (items[i].classList.contains(\"in-view\")) {\n                    items[i].classList.remove(\"in-view\");\n                }\n            }\n        }\n\n        window.addEventListener(\"load\", callbackFunc);\n        window.addEventListener(\"scroll\", callbackFunc);\n    </script>\n\n  ","date":"2022-01-04T12:17:36.836Z","updated":"2022-01-04T12:17:36.836Z","path":"mood/index.html","layout":"page","_id":"cky03p48x000m0cum4f9420jl","content":"<script src=\"https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"></script>\n<link type=\"text/css\" rel=\"styleSheet\"  href=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/css/mood.css\" />\n<center>  \n<section class=\"timeline\" style=\"padding-bottom: 50px\">\n<ul>\n<li class=\"in-view\">\n    <div>\n    <time>2021/1/4</time>\n    <div class=\"discovery\">\n        <span >come</span>\n        <p> 认真复习！</p>\n    </div>\n</li>\n<li class=\"in-view\">\n    <div>\n    <time>2021/1/4</time>\n    <div class=\"discovery\">\n        <span >come</span>\n        <p> 认真复习！</p>\n    </div>\n</li>\n<li class=\"in-view\">\n    <div>\n    <time>2021/1/4</time>\n    <div class=\"discovery\">\n        <span >come</span>\n        <p> 认真复习！</p>\n    </div>\n</li>\n<li class=\"in-view\">\n    <div>\n    <time>2021/1/4</time>\n    <div class=\"discovery\">\n        <span >come</span>\n        <p> 认真复习！</p>\n    </div>\n</li>\n<li class=\"in-view\">\n    <div>\n    <time>2020/7/1</time>\n    <div class=\"discovery\">\n        <span >行动起来</span>\n        <p> 倒计时30天考试！</p>\n    </div>\n</li>\n<li class=\"in-view\">\n    <div>\n    <time>2020/6/5</time>\n    <div class=\"discovery\">\n        <span >心情墙</span>\n        <p> 博客添加心情墙，记录生活中的点滴😁！</p>\n    </div>\n</li>\n\n            \n</ul>\n</section>\n\n<script>\n\n        $(function () {\n            function isEmpty(obj) {\n                if (typeof obj == \"undefined\" || obj == null || obj == \"\") {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n\n        })\n        var items = document.querySelectorAll(\".timeline li\");\n\n        function isElementInViewport(el) {\n            var rect = el.getBoundingClientRect();\n            return (\n                rect.top >= 0 &&\n                rect.left >= 0 &&\n                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n                rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n            );\n        }\n\n        function callbackFunc() {\n            for (var i = 0; i < items.length; i++) {\n                if (isElementInViewport(items[i])) {\n                    if (!items[i].classList.contains(\"in-view\")) {\n                        items[i].classList.add(\"in-view\");\n                    }\n                } else if (items[i].classList.contains(\"in-view\")) {\n                    items[i].classList.remove(\"in-view\");\n                }\n            }\n        }\n\n        window.addEventListener(\"load\", callbackFunc);\n        window.addEventListener(\"scroll\", callbackFunc);\n    </script>\n\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"cover":"https://www.qiaoyihe.com/img/3.jpg","excerpt":"","more":"<script src=\"https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"></script>\n<link type=\"text/css\" rel=\"styleSheet\"  href=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/css/mood.css\" />\n<center>  \n<section class=\"timeline\" style=\"padding-bottom: 50px\">\n<ul>\n<li class=\"in-view\">\n    <div>\n    <time>2021/1/4</time>\n    <div class=\"discovery\">\n        <span >come</span>\n        <p> 认真复习！</p>\n    </div>\n</li>\n<li class=\"in-view\">\n    <div>\n    <time>2021/1/4</time>\n    <div class=\"discovery\">\n        <span >come</span>\n        <p> 认真复习！</p>\n    </div>\n</li>\n<li class=\"in-view\">\n    <div>\n    <time>2021/1/4</time>\n    <div class=\"discovery\">\n        <span >come</span>\n        <p> 认真复习！</p>\n    </div>\n</li>\n<li class=\"in-view\">\n    <div>\n    <time>2021/1/4</time>\n    <div class=\"discovery\">\n        <span >come</span>\n        <p> 认真复习！</p>\n    </div>\n</li>\n<li class=\"in-view\">\n    <div>\n    <time>2020/7/1</time>\n    <div class=\"discovery\">\n        <span >行动起来</span>\n        <p> 倒计时30天考试！</p>\n    </div>\n</li>\n<li class=\"in-view\">\n    <div>\n    <time>2020/6/5</time>\n    <div class=\"discovery\">\n        <span >心情墙</span>\n        <p> 博客添加心情墙，记录生活中的点滴😁！</p>\n    </div>\n</li>\n\n            \n</ul>\n</section>\n\n<script>\n\n        $(function () {\n            function isEmpty(obj) {\n                if (typeof obj == \"undefined\" || obj == null || obj == \"\") {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n\n        })\n        var items = document.querySelectorAll(\".timeline li\");\n\n        function isElementInViewport(el) {\n            var rect = el.getBoundingClientRect();\n            return (\n                rect.top >= 0 &&\n                rect.left >= 0 &&\n                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n                rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n            );\n        }\n\n        function callbackFunc() {\n            for (var i = 0; i < items.length; i++) {\n                if (isElementInViewport(items[i])) {\n                    if (!items[i].classList.contains(\"in-view\")) {\n                        items[i].classList.add(\"in-view\");\n                    }\n                } else if (items[i].classList.contains(\"in-view\")) {\n                    items[i].classList.remove(\"in-view\");\n                }\n            }\n        }\n\n        window.addEventListener(\"load\", callbackFunc);\n        window.addEventListener(\"scroll\", callbackFunc);\n    </script>\n\n"},{"comments":0,"aside":false,"_content":"{% gallery %}\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/1.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/2.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/3.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/4.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/5.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/6.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/7.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/8.jpg)\n{% endgallery %}\n","source":"photo/gd/index.md","raw":"---\ncomments: false\naside: false\n---\n{% gallery %}\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/1.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/2.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/3.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/4.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/5.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/6.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/7.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/8.jpg)\n{% endgallery %}\n","date":"2022-01-04T10:55:44.957Z","updated":"2021-08-02T11:23:56.278Z","path":"photo/gd/index.html","title":"","layout":"page","_id":"cky03p490000q0cum4al18m5u","content":"<div class=\"justified-gallery\"><p><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/1.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/2.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/3.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/4.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/5.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/6.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/7.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/8.jpg\"></p>\n          </div>\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"cover":"https://www.qiaoyihe.com/img/3.jpg","excerpt":"","more":"<div class=\"justified-gallery\"><p><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/1.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/2.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/3.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/4.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/5.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/6.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/7.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gd/8.jpg\"></p>\n          </div>\n"},{"aside":false,"comments":0,"_content":"{% gallery %}\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/0.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/1.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/2.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/3.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/4.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/5.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/6.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/7.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/9.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/10.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/11.jpg)\n\n{% endgallery %}\n\n","source":"photo/gmzr/index.md","raw":"---\naside: false\ncomments: false\n---\n{% gallery %}\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/0.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/1.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/2.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/3.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/4.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/5.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/6.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/7.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/9.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/10.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/11.jpg)\n\n{% endgallery %}\n\n","date":"2022-01-04T10:55:44.957Z","updated":"2021-08-02T11:24:03.664Z","path":"photo/gmzr/index.html","title":"","layout":"page","_id":"cky03p492000v0cum3yi65wbn","content":"<div class=\"justified-gallery\"><p><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/0.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/1.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/2.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/3.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/4.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/5.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/6.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/7.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/9.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/10.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/11.jpg\"></p>\n          </div>\n\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"cover":"https://www.qiaoyihe.com/img/1.jpg","excerpt":"","more":"<div class=\"justified-gallery\"><p><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/0.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/1.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/2.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/3.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/4.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/5.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/6.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/7.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/9.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/10.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/gmzr/11.jpg\"></p>\n          </div>\n\n"},{"comments":0,"aside":false,"_content":"{% gallery %}\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2022/1.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2022/2.jpg)\n\n{% endgallery %}\n\n","source":"photo/2022/index.md","raw":"---\ncomments: false\naside: false\n---\n{% gallery %}\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2022/1.jpg)\n![](https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2022/2.jpg)\n\n{% endgallery %}\n\n","date":"2022-01-04T12:54:38.979Z","updated":"2022-01-04T12:54:38.979Z","path":"photo/2022/index.html","_id":"cky03z0830000hsum7xtv72ho","title":"","layout":"page","content":"<div class=\"justified-gallery\"><p><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2022/1.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2022/2.jpg\"></p>\n          </div>\n\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"cover":"https://www.qiaoyihe.com/img/3.jpg","excerpt":"","more":"<div class=\"justified-gallery\"><p><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2022/1.jpg\"><br><img src=\"https://cdn.jsdelivr.net/gh/qiaoyihe/Figure-bed/xc/2022/2.jpg\"></p>\n          </div>\n\n"}],"Post":[{"title":"Java数据类型","cover":"/img/java.webp","abbrlink":188331,"date":"2020-06-01T14:00:45.000Z","_content":"\nJava是一种强类型语言，每个变量都必须声明其类型。\nJava语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\nJava变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。\n变量在使用前必须对其声明, 只有在变量声明以后，才能为其分配相应长度的存储单元,声明格式为： \n```Java\nString name = “Java”,int num = 12;\n```\n### 基本数据类型：\n\n### 整数型：\nbyte：\nbyte 数据类型是8位、有符号的，以二进制补码表示的整数；\n最小值是 -128（-2^7）；\n最大值是 127（2^7-1）；\nbyte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n例子：byte a = 12，byte b = -12。\n\n### short：\nshort 数据类型是 16 位、有符号的以二进制补码表示的整数\n最小值是 -32768（-2^15）；\n最大值是 32767（2^15 - 1）；\nShort 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n例子：short s = 10000，short r = -10000。\n\n### int：\nint 数据类型是32位、有符号的以二进制补码表示的整数；\n最小值是 -2,147,483,648（-2^31）；\n最大值是 2,147,483,647（2^31 - 1）；\n一般地整型变量默认为 int 类型；\n例子：int a = 10000, int b = -20000。\n\n### long：\nlong 数据类型是 64 位、有符号的以二进制补码表示的整数；\n最小值是 -9,223,372,036,854,775,808（-2^63）；\n最大值是 9,223,372,036,854,775,807（2^63 -1）；\n这种类型主要使用在需要比较大整数的系统上；\n例子： long a = 100000L，Long b = -100000L。\n\"L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。\n\n### 浮点类型\n\n### float：\nfloat 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\nfloat 在储存大型浮点数组的时候可节省内存空间；\n浮点数不能用来表示精确的值，如货币；\n例子：float f1 = 123.4f。\n\n### double：\ndouble 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；\n浮点数的默认类型为double类型；\ndouble类型同样不能表示精确的值，如货币；\n例子：double d1 = 123.4。\n\n### 引用类型\n\n### char：\nchar类型是一个单一的 16 位 Unicode 字符；\n最小值是 \\u0000（即为0）；\n最大值是 \\uffff（即为65,535）；\nchar 数据类型可以储存任何字符；\n例子：char letter = 'C';。\n### 布尔类型\n\n### boolean：\nboolean数据类型表示一位的信息；\n只有两个取值：true 和 false；\n这种类型只作为一种标志来记录 true/false 情况；\n默认值是 false；\n例子：boolean one = true。\n\n### 内存中占据的存储大小：\n![Java](https://i.loli.net/2020/06/03/yPIv9wcZ4MqGphk.png)\n整数类型：\nbyte<short<int<long\n浮点型：\nfloat<double\n引用类型：\nchar\n布尔型 ：\nboolean","source":"_posts/2.md","raw":"---\ntitle: Java数据类型\ncategories: 技术\ntags:\n  - java\n  - 基础\ncover: '/img/java.webp'\nabbrlink: 188331\ndate: 2020-06-01 22:00:45\n---\n\nJava是一种强类型语言，每个变量都必须声明其类型。\nJava语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\nJava变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。\n变量在使用前必须对其声明, 只有在变量声明以后，才能为其分配相应长度的存储单元,声明格式为： \n```Java\nString name = “Java”,int num = 12;\n```\n### 基本数据类型：\n\n### 整数型：\nbyte：\nbyte 数据类型是8位、有符号的，以二进制补码表示的整数；\n最小值是 -128（-2^7）；\n最大值是 127（2^7-1）；\nbyte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n例子：byte a = 12，byte b = -12。\n\n### short：\nshort 数据类型是 16 位、有符号的以二进制补码表示的整数\n最小值是 -32768（-2^15）；\n最大值是 32767（2^15 - 1）；\nShort 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n例子：short s = 10000，short r = -10000。\n\n### int：\nint 数据类型是32位、有符号的以二进制补码表示的整数；\n最小值是 -2,147,483,648（-2^31）；\n最大值是 2,147,483,647（2^31 - 1）；\n一般地整型变量默认为 int 类型；\n例子：int a = 10000, int b = -20000。\n\n### long：\nlong 数据类型是 64 位、有符号的以二进制补码表示的整数；\n最小值是 -9,223,372,036,854,775,808（-2^63）；\n最大值是 9,223,372,036,854,775,807（2^63 -1）；\n这种类型主要使用在需要比较大整数的系统上；\n例子： long a = 100000L，Long b = -100000L。\n\"L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。\n\n### 浮点类型\n\n### float：\nfloat 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\nfloat 在储存大型浮点数组的时候可节省内存空间；\n浮点数不能用来表示精确的值，如货币；\n例子：float f1 = 123.4f。\n\n### double：\ndouble 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；\n浮点数的默认类型为double类型；\ndouble类型同样不能表示精确的值，如货币；\n例子：double d1 = 123.4。\n\n### 引用类型\n\n### char：\nchar类型是一个单一的 16 位 Unicode 字符；\n最小值是 \\u0000（即为0）；\n最大值是 \\uffff（即为65,535）；\nchar 数据类型可以储存任何字符；\n例子：char letter = 'C';。\n### 布尔类型\n\n### boolean：\nboolean数据类型表示一位的信息；\n只有两个取值：true 和 false；\n这种类型只作为一种标志来记录 true/false 情况；\n默认值是 false；\n例子：boolean one = true。\n\n### 内存中占据的存储大小：\n![Java](https://i.loli.net/2020/06/03/yPIv9wcZ4MqGphk.png)\n整数类型：\nbyte<short<int<long\n浮点型：\nfloat<double\n引用类型：\nchar\n布尔型 ：\nboolean","slug":"2","published":1,"updated":"2021-08-01T07:40:33.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky03p47j00010cumergrcm09","content":"<p>Java是一种强类型语言，每个变量都必须声明其类型。<br>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。<br>变量在使用前必须对其声明, 只有在变量声明以后，才能为其分配相应长度的存储单元,声明格式为： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = “Java”,<span class=\"keyword\">int</span> num = <span class=\"number\">12</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本数据类型：\"><a href=\"#基本数据类型：\" class=\"headerlink\" title=\"基本数据类型：\"></a>基本数据类型：</h3><h3 id=\"整数型：\"><a href=\"#整数型：\" class=\"headerlink\" title=\"整数型：\"></a>整数型：</h3><p>byte：<br>byte 数据类型是8位、有符号的，以二进制补码表示的整数；<br>最小值是 -128（-2^7）；<br>最大值是 127（2^7-1）；<br>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；<br>例子：byte a = 12，byte b = -12。</p>\n<h3 id=\"short：\"><a href=\"#short：\" class=\"headerlink\" title=\"short：\"></a>short：</h3><p>short 数据类型是 16 位、有符号的以二进制补码表示的整数<br>最小值是 -32768（-2^15）；<br>最大值是 32767（2^15 - 1）；<br>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；<br>例子：short s = 10000，short r = -10000。</p>\n<h3 id=\"int：\"><a href=\"#int：\" class=\"headerlink\" title=\"int：\"></a>int：</h3><p>int 数据类型是32位、有符号的以二进制补码表示的整数；<br>最小值是 -2,147,483,648（-2^31）；<br>最大值是 2,147,483,647（2^31 - 1）；<br>一般地整型变量默认为 int 类型；<br>例子：int a = 10000, int b = -20000。</p>\n<h3 id=\"long：\"><a href=\"#long：\" class=\"headerlink\" title=\"long：\"></a>long：</h3><p>long 数据类型是 64 位、有符号的以二进制补码表示的整数；<br>最小值是 -9,223,372,036,854,775,808（-2^63）；<br>最大值是 9,223,372,036,854,775,807（2^63 -1）；<br>这种类型主要使用在需要比较大整数的系统上；<br>例子： long a = 100000L，Long b = -100000L。<br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</p>\n<h3 id=\"浮点类型\"><a href=\"#浮点类型\" class=\"headerlink\" title=\"浮点类型\"></a>浮点类型</h3><h3 id=\"float：\"><a href=\"#float：\" class=\"headerlink\" title=\"float：\"></a>float：</h3><p>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；<br>float 在储存大型浮点数组的时候可节省内存空间；<br>浮点数不能用来表示精确的值，如货币；<br>例子：float f1 = 123.4f。</p>\n<h3 id=\"double：\"><a href=\"#double：\" class=\"headerlink\" title=\"double：\"></a>double：</h3><p>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；<br>浮点数的默认类型为double类型；<br>double类型同样不能表示精确的值，如货币；<br>例子：double d1 = 123.4。</p>\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><h3 id=\"char：\"><a href=\"#char：\" class=\"headerlink\" title=\"char：\"></a>char：</h3><p>char类型是一个单一的 16 位 Unicode 字符；<br>最小值是 \\u0000（即为0）；<br>最大值是 \\uffff（即为65,535）；<br>char 数据类型可以储存任何字符；<br>例子：char letter = ‘C’;。</p>\n<h3 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h3><h3 id=\"boolean：\"><a href=\"#boolean：\" class=\"headerlink\" title=\"boolean：\"></a>boolean：</h3><p>boolean数据类型表示一位的信息；<br>只有两个取值：true 和 false；<br>这种类型只作为一种标志来记录 true/false 情况；<br>默认值是 false；<br>例子：boolean one = true。</p>\n<h3 id=\"内存中占据的存储大小：\"><a href=\"#内存中占据的存储大小：\" class=\"headerlink\" title=\"内存中占据的存储大小：\"></a>内存中占据的存储大小：</h3><p><img src=\"https://i.loli.net/2020/06/03/yPIv9wcZ4MqGphk.png\" alt=\"Java\"><br>整数类型：<br>byte&lt;short&lt;int&lt;long<br>浮点型：<br>float&lt;double<br>引用类型：<br>char<br>布尔型 ：<br>boolean</p>\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"excerpt":"","more":"<p>Java是一种强类型语言，每个变量都必须声明其类型。<br>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。<br>变量在使用前必须对其声明, 只有在变量声明以后，才能为其分配相应长度的存储单元,声明格式为： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = “Java”,<span class=\"keyword\">int</span> num = <span class=\"number\">12</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本数据类型：\"><a href=\"#基本数据类型：\" class=\"headerlink\" title=\"基本数据类型：\"></a>基本数据类型：</h3><h3 id=\"整数型：\"><a href=\"#整数型：\" class=\"headerlink\" title=\"整数型：\"></a>整数型：</h3><p>byte：<br>byte 数据类型是8位、有符号的，以二进制补码表示的整数；<br>最小值是 -128（-2^7）；<br>最大值是 127（2^7-1）；<br>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；<br>例子：byte a = 12，byte b = -12。</p>\n<h3 id=\"short：\"><a href=\"#short：\" class=\"headerlink\" title=\"short：\"></a>short：</h3><p>short 数据类型是 16 位、有符号的以二进制补码表示的整数<br>最小值是 -32768（-2^15）；<br>最大值是 32767（2^15 - 1）；<br>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；<br>例子：short s = 10000，short r = -10000。</p>\n<h3 id=\"int：\"><a href=\"#int：\" class=\"headerlink\" title=\"int：\"></a>int：</h3><p>int 数据类型是32位、有符号的以二进制补码表示的整数；<br>最小值是 -2,147,483,648（-2^31）；<br>最大值是 2,147,483,647（2^31 - 1）；<br>一般地整型变量默认为 int 类型；<br>例子：int a = 10000, int b = -20000。</p>\n<h3 id=\"long：\"><a href=\"#long：\" class=\"headerlink\" title=\"long：\"></a>long：</h3><p>long 数据类型是 64 位、有符号的以二进制补码表示的整数；<br>最小值是 -9,223,372,036,854,775,808（-2^63）；<br>最大值是 9,223,372,036,854,775,807（2^63 -1）；<br>这种类型主要使用在需要比较大整数的系统上；<br>例子： long a = 100000L，Long b = -100000L。<br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</p>\n<h3 id=\"浮点类型\"><a href=\"#浮点类型\" class=\"headerlink\" title=\"浮点类型\"></a>浮点类型</h3><h3 id=\"float：\"><a href=\"#float：\" class=\"headerlink\" title=\"float：\"></a>float：</h3><p>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；<br>float 在储存大型浮点数组的时候可节省内存空间；<br>浮点数不能用来表示精确的值，如货币；<br>例子：float f1 = 123.4f。</p>\n<h3 id=\"double：\"><a href=\"#double：\" class=\"headerlink\" title=\"double：\"></a>double：</h3><p>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；<br>浮点数的默认类型为double类型；<br>double类型同样不能表示精确的值，如货币；<br>例子：double d1 = 123.4。</p>\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><h3 id=\"char：\"><a href=\"#char：\" class=\"headerlink\" title=\"char：\"></a>char：</h3><p>char类型是一个单一的 16 位 Unicode 字符；<br>最小值是 \\u0000（即为0）；<br>最大值是 \\uffff（即为65,535）；<br>char 数据类型可以储存任何字符；<br>例子：char letter = ‘C’;。</p>\n<h3 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h3><h3 id=\"boolean：\"><a href=\"#boolean：\" class=\"headerlink\" title=\"boolean：\"></a>boolean：</h3><p>boolean数据类型表示一位的信息；<br>只有两个取值：true 和 false；<br>这种类型只作为一种标志来记录 true/false 情况；<br>默认值是 false；<br>例子：boolean one = true。</p>\n<h3 id=\"内存中占据的存储大小：\"><a href=\"#内存中占据的存储大小：\" class=\"headerlink\" title=\"内存中占据的存储大小：\"></a>内存中占据的存储大小：</h3><p><img src=\"https://i.loli.net/2020/06/03/yPIv9wcZ4MqGphk.png\" alt=\"Java\"><br>整数类型：<br>byte&lt;short&lt;int&lt;long<br>浮点型：<br>float&lt;double<br>引用类型：<br>char<br>布尔型 ：<br>boolean</p>\n"},{"title":"Github初始化配置","abbrlink":5440,"date":"2020-06-05T12:18:05.000Z","cover":"https://www.qiaoyihe.com/img/3.jpg","_content":"\n### 初次安装 git 配置用户名和邮箱\n```\ngit config --global user.name \"xxx\"\ngit config --global user.email \"xxx@qq.com\"\n```\n## git 使用 ssh 密钥\ngit 支持 https 和 git 两种传输协议，GitHub 分享链接时会有两种协议可选。\n  - 使用 https 协议，每次 pull、push 都会提示要输入密码\n  - 使用 git 协议，然后使用 ssh 密钥，这样免去每次都输密码的麻烦\n初次使用 git 的用户要使用 git 协议大概需要三个步骤\n### 生成密钥对\n大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。\n```\ncd ~/.ssh\nls\n```\n看一下有没有 id_rsa 和 id_rsa.pub(或者是 id_dsa 和 id_dsa.pub 之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。\n\n假如没有这些文件，甚至连.ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：\n```\nssh-keygen -t rsa -C <xxx@qq.com>\nCreates a new ssh key using the provided email \\# Generating public/private rsa key pair.\nEnter file in which to save the key (/home/you/.ssh/id_rsa):\n```\n按Enter,然后，会提示你输入密码，如下 (建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)：\n```\nEnter same passphrase again: [Type passphrase again]\n```\n到此为止，你本地的密钥对就生成了。\n\n#### 添加公钥到你的远程仓库（GitHub）\n```\ncat ~/.ssh/id_rsa.pub\nssh-rsa xxx admin\\@admin-PC\n```\n##### SSH Key \n登陆你的 GitHub 帐户，点击你的头像，然后 Settings -> 左栏点击 SSH and GPG keys -> 点击 New SSH key -> 然后你复制上面的公钥内容（上面全部），粘贴进“Key”文本域内。title域，自己随便起个名字。 -> 点击 Add key。\n###### 验证 key \n```\nssh -T <git@github.com>\nHi xxx! You've successfully authenticated, but GitHub does not \\# provide shell\naccess.\n```","source":"_posts/3.md","raw":"---\ntitle: Github初始化配置\nabbrlink: 5440\ndate: 2020-06-05 20:18:05\ncategories: 技术\ncover: \ntags:\n  - Github\n---\n\n### 初次安装 git 配置用户名和邮箱\n```\ngit config --global user.name \"xxx\"\ngit config --global user.email \"xxx@qq.com\"\n```\n## git 使用 ssh 密钥\ngit 支持 https 和 git 两种传输协议，GitHub 分享链接时会有两种协议可选。\n  - 使用 https 协议，每次 pull、push 都会提示要输入密码\n  - 使用 git 协议，然后使用 ssh 密钥，这样免去每次都输密码的麻烦\n初次使用 git 的用户要使用 git 协议大概需要三个步骤\n### 生成密钥对\n大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。\n```\ncd ~/.ssh\nls\n```\n看一下有没有 id_rsa 和 id_rsa.pub(或者是 id_dsa 和 id_dsa.pub 之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。\n\n假如没有这些文件，甚至连.ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：\n```\nssh-keygen -t rsa -C <xxx@qq.com>\nCreates a new ssh key using the provided email \\# Generating public/private rsa key pair.\nEnter file in which to save the key (/home/you/.ssh/id_rsa):\n```\n按Enter,然后，会提示你输入密码，如下 (建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)：\n```\nEnter same passphrase again: [Type passphrase again]\n```\n到此为止，你本地的密钥对就生成了。\n\n#### 添加公钥到你的远程仓库（GitHub）\n```\ncat ~/.ssh/id_rsa.pub\nssh-rsa xxx admin\\@admin-PC\n```\n##### SSH Key \n登陆你的 GitHub 帐户，点击你的头像，然后 Settings -> 左栏点击 SSH and GPG keys -> 点击 New SSH key -> 然后你复制上面的公钥内容（上面全部），粘贴进“Key”文本域内。title域，自己随便起个名字。 -> 点击 Add key。\n###### 验证 key \n```\nssh -T <git@github.com>\nHi xxx! You've successfully authenticated, but GitHub does not \\# provide shell\naccess.\n```","slug":"3","published":1,"updated":"2021-08-01T08:03:10.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky03p47p00030cum9lu9bgw2","content":"<h3 id=\"初次安装-git-配置用户名和邮箱\"><a href=\"#初次安装-git-配置用户名和邮箱\" class=\"headerlink\" title=\"初次安装 git 配置用户名和邮箱\"></a>初次安装 git 配置用户名和邮箱</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;xxx&quot;</span><br><span class=\"line\">git config --global user.email &quot;xxx@qq.com&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"git-使用-ssh-密钥\"><a href=\"#git-使用-ssh-密钥\" class=\"headerlink\" title=\"git 使用 ssh 密钥\"></a>git 使用 ssh 密钥</h2><p>git 支持 https 和 git 两种传输协议，GitHub 分享链接时会有两种协议可选。</p>\n<ul>\n<li>使用 https 协议，每次 pull、push 都会提示要输入密码</li>\n<li>使用 git 协议，然后使用 ssh 密钥，这样免去每次都输密码的麻烦<br>初次使用 git 的用户要使用 git 协议大概需要三个步骤<h3 id=\"生成密钥对\"><a href=\"#生成密钥对\" class=\"headerlink\" title=\"生成密钥对\"></a>生成密钥对</h3>大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/.ssh</span><br><span class=\"line\">ls</span><br></pre></td></tr></table></figure>\n看一下有没有 id_rsa 和 id_rsa.pub(或者是 id_dsa 和 id_dsa.pub 之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。</li>\n</ul>\n<p>假如没有这些文件，甚至连.ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &lt;xxx@qq.com&gt;</span><br><span class=\"line\">Creates a new ssh key using the provided email \\# Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (/home/you/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>\n<p>按Enter,然后，会提示你输入密码，如下 (建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure>\n<p>到此为止，你本地的密钥对就生成了。</p>\n<h4 id=\"添加公钥到你的远程仓库（GitHub）\"><a href=\"#添加公钥到你的远程仓库（GitHub）\" class=\"headerlink\" title=\"添加公钥到你的远程仓库（GitHub）\"></a>添加公钥到你的远程仓库（GitHub）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br><span class=\"line\">ssh-rsa xxx admin\\@admin-PC</span><br></pre></td></tr></table></figure>\n<h5 id=\"SSH-Key\"><a href=\"#SSH-Key\" class=\"headerlink\" title=\"SSH Key\"></a>SSH Key</h5><p>登陆你的 GitHub 帐户，点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key -&gt; 然后你复制上面的公钥内容（上面全部），粘贴进“Key”文本域内。title域，自己随便起个名字。 -&gt; 点击 Add key。</p>\n<h6 id=\"验证-key\"><a href=\"#验证-key\" class=\"headerlink\" title=\"验证 key\"></a>验证 key</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T &lt;git@github.com&gt;</span><br><span class=\"line\">Hi xxx! You&#x27;ve successfully authenticated, but GitHub does not \\# provide shell</span><br><span class=\"line\">access.</span><br></pre></td></tr></table></figure>","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"excerpt":"","more":"<h3 id=\"初次安装-git-配置用户名和邮箱\"><a href=\"#初次安装-git-配置用户名和邮箱\" class=\"headerlink\" title=\"初次安装 git 配置用户名和邮箱\"></a>初次安装 git 配置用户名和邮箱</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;xxx&quot;</span><br><span class=\"line\">git config --global user.email &quot;xxx@qq.com&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"git-使用-ssh-密钥\"><a href=\"#git-使用-ssh-密钥\" class=\"headerlink\" title=\"git 使用 ssh 密钥\"></a>git 使用 ssh 密钥</h2><p>git 支持 https 和 git 两种传输协议，GitHub 分享链接时会有两种协议可选。</p>\n<ul>\n<li>使用 https 协议，每次 pull、push 都会提示要输入密码</li>\n<li>使用 git 协议，然后使用 ssh 密钥，这样免去每次都输密码的麻烦<br>初次使用 git 的用户要使用 git 协议大概需要三个步骤<h3 id=\"生成密钥对\"><a href=\"#生成密钥对\" class=\"headerlink\" title=\"生成密钥对\"></a>生成密钥对</h3>大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/.ssh</span><br><span class=\"line\">ls</span><br></pre></td></tr></table></figure>\n看一下有没有 id_rsa 和 id_rsa.pub(或者是 id_dsa 和 id_dsa.pub 之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。</li>\n</ul>\n<p>假如没有这些文件，甚至连.ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &lt;xxx@qq.com&gt;</span><br><span class=\"line\">Creates a new ssh key using the provided email \\# Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (/home/you/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>\n<p>按Enter,然后，会提示你输入密码，如下 (建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure>\n<p>到此为止，你本地的密钥对就生成了。</p>\n<h4 id=\"添加公钥到你的远程仓库（GitHub）\"><a href=\"#添加公钥到你的远程仓库（GitHub）\" class=\"headerlink\" title=\"添加公钥到你的远程仓库（GitHub）\"></a>添加公钥到你的远程仓库（GitHub）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br><span class=\"line\">ssh-rsa xxx admin\\@admin-PC</span><br></pre></td></tr></table></figure>\n<h5 id=\"SSH-Key\"><a href=\"#SSH-Key\" class=\"headerlink\" title=\"SSH Key\"></a>SSH Key</h5><p>登陆你的 GitHub 帐户，点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key -&gt; 然后你复制上面的公钥内容（上面全部），粘贴进“Key”文本域内。title域，自己随便起个名字。 -&gt; 点击 Add key。</p>\n<h6 id=\"验证-key\"><a href=\"#验证-key\" class=\"headerlink\" title=\"验证 key\"></a>验证 key</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T &lt;git@github.com&gt;</span><br><span class=\"line\">Hi xxx! You&#x27;ve successfully authenticated, but GitHub does not \\# provide shell</span><br><span class=\"line\">access.</span><br></pre></td></tr></table></figure>"},{"title":"进制转换","abbrlink":55041,"date":"2020-06-06T13:42:17.000Z","cover":"/img/java.webp","_content":"# 进制区分\n\n  进制 |     组成              | 例如 \n-----  | ---- | ----  \n2进制  |只有0和1组成 　　　    |　101010\n8进制  |以0开头,0~7组成 　　   |  01234\n10进制 |以1~9开头,0~9组成    　|　100\n16进制 |以0X开头,0~9或者a~f组成|  0x12c\n\n# 进制转换\n\n## 十进制转二进制\n十进制数除2取余法即十进制数除2，余数为权位上的数，得到的商值继续除2，依此步骤继续向下运算直到商为0为止。\n\n## 二进制转十进制\n把二进制数按权展开,相加即得十进制数。\n\n## 二进制转八进制\n\n3位二进制数按权展开相加得到1位八进制数,（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。\n\n## 八进制转成二进制\n\n八进制数通过除2取余法，得到二进制数，对每个八进制为3个二进制，不足时在最左边补零。\n\n## 二进制转十六进制\n\n与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）\n\n## 十进制与八进制与十六进制之间的转换\n\n### 十进制转八进制或者十六进制有两种方法\n\n2：间接法—把十进制转成二进制，然后再由二进制转成八进制或者十六进制。这里不再做图片用法解释。\n\n1：把十进制转八进制或者十六进制按照除8或者16取余，直到商为0为止。\n\n## 八进制或者十六进制转成十进制\n\n把八进制、十六进制数按权展开、相加即得十进制数。\n","source":"_posts/4.md","raw":"---\ntitle: 进制转换\ncategories: 技术\ntags:\n  - java\n  - 基础\n  - 进制\nabbrlink: 55041\ndate: 2020-06-06 21:42:17\ncover: '/img/java.webp'\n---\n# 进制区分\n\n  进制 |     组成              | 例如 \n-----  | ---- | ----  \n2进制  |只有0和1组成 　　　    |　101010\n8进制  |以0开头,0~7组成 　　   |  01234\n10进制 |以1~9开头,0~9组成    　|　100\n16进制 |以0X开头,0~9或者a~f组成|  0x12c\n\n# 进制转换\n\n## 十进制转二进制\n十进制数除2取余法即十进制数除2，余数为权位上的数，得到的商值继续除2，依此步骤继续向下运算直到商为0为止。\n\n## 二进制转十进制\n把二进制数按权展开,相加即得十进制数。\n\n## 二进制转八进制\n\n3位二进制数按权展开相加得到1位八进制数,（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。\n\n## 八进制转成二进制\n\n八进制数通过除2取余法，得到二进制数，对每个八进制为3个二进制，不足时在最左边补零。\n\n## 二进制转十六进制\n\n与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）\n\n## 十进制与八进制与十六进制之间的转换\n\n### 十进制转八进制或者十六进制有两种方法\n\n2：间接法—把十进制转成二进制，然后再由二进制转成八进制或者十六进制。这里不再做图片用法解释。\n\n1：把十进制转八进制或者十六进制按照除8或者16取余，直到商为0为止。\n\n## 八进制或者十六进制转成十进制\n\n把八进制、十六进制数按权展开、相加即得十进制数。\n","slug":"4","published":1,"updated":"2021-08-01T07:41:46.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky03p47x00070cum2thybj1g","content":"<h1 id=\"进制区分\"><a href=\"#进制区分\" class=\"headerlink\" title=\"进制区分\"></a>进制区分</h1><table>\n<thead>\n<tr>\n<th>进制</th>\n<th>组成</th>\n<th>例如</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2进制</td>\n<td>只有0和1组成</td>\n<td>101010</td>\n</tr>\n<tr>\n<td>8进制</td>\n<td>以0开头,0~7组成</td>\n<td>01234</td>\n</tr>\n<tr>\n<td>10进制</td>\n<td>以1<del>9开头,0</del>9组成</td>\n<td>100</td>\n</tr>\n<tr>\n<td>16进制</td>\n<td>以0X开头,0<del>9或者a</del>f组成</td>\n<td>0x12c</td>\n</tr>\n</tbody></table>\n<h1 id=\"进制转换\"><a href=\"#进制转换\" class=\"headerlink\" title=\"进制转换\"></a>进制转换</h1><h2 id=\"十进制转二进制\"><a href=\"#十进制转二进制\" class=\"headerlink\" title=\"十进制转二进制\"></a>十进制转二进制</h2><p>十进制数除2取余法即十进制数除2，余数为权位上的数，得到的商值继续除2，依此步骤继续向下运算直到商为0为止。</p>\n<h2 id=\"二进制转十进制\"><a href=\"#二进制转十进制\" class=\"headerlink\" title=\"二进制转十进制\"></a>二进制转十进制</h2><p>把二进制数按权展开,相加即得十进制数。</p>\n<h2 id=\"二进制转八进制\"><a href=\"#二进制转八进制\" class=\"headerlink\" title=\"二进制转八进制\"></a>二进制转八进制</h2><p>3位二进制数按权展开相加得到1位八进制数,（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。</p>\n<h2 id=\"八进制转成二进制\"><a href=\"#八进制转成二进制\" class=\"headerlink\" title=\"八进制转成二进制\"></a>八进制转成二进制</h2><p>八进制数通过除2取余法，得到二进制数，对每个八进制为3个二进制，不足时在最左边补零。</p>\n<h2 id=\"二进制转十六进制\"><a href=\"#二进制转十六进制\" class=\"headerlink\" title=\"二进制转十六进制\"></a>二进制转十六进制</h2><p>与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）</p>\n<h2 id=\"十进制与八进制与十六进制之间的转换\"><a href=\"#十进制与八进制与十六进制之间的转换\" class=\"headerlink\" title=\"十进制与八进制与十六进制之间的转换\"></a>十进制与八进制与十六进制之间的转换</h2><h3 id=\"十进制转八进制或者十六进制有两种方法\"><a href=\"#十进制转八进制或者十六进制有两种方法\" class=\"headerlink\" title=\"十进制转八进制或者十六进制有两种方法\"></a>十进制转八进制或者十六进制有两种方法</h3><p>2：间接法—把十进制转成二进制，然后再由二进制转成八进制或者十六进制。这里不再做图片用法解释。</p>\n<p>1：把十进制转八进制或者十六进制按照除8或者16取余，直到商为0为止。</p>\n<h2 id=\"八进制或者十六进制转成十进制\"><a href=\"#八进制或者十六进制转成十进制\" class=\"headerlink\" title=\"八进制或者十六进制转成十进制\"></a>八进制或者十六进制转成十进制</h2><p>把八进制、十六进制数按权展开、相加即得十进制数。</p>\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"excerpt":"","more":"<h1 id=\"进制区分\"><a href=\"#进制区分\" class=\"headerlink\" title=\"进制区分\"></a>进制区分</h1><table>\n<thead>\n<tr>\n<th>进制</th>\n<th>组成</th>\n<th>例如</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2进制</td>\n<td>只有0和1组成</td>\n<td>101010</td>\n</tr>\n<tr>\n<td>8进制</td>\n<td>以0开头,0~7组成</td>\n<td>01234</td>\n</tr>\n<tr>\n<td>10进制</td>\n<td>以1<del>9开头,0</del>9组成</td>\n<td>100</td>\n</tr>\n<tr>\n<td>16进制</td>\n<td>以0X开头,0<del>9或者a</del>f组成</td>\n<td>0x12c</td>\n</tr>\n</tbody></table>\n<h1 id=\"进制转换\"><a href=\"#进制转换\" class=\"headerlink\" title=\"进制转换\"></a>进制转换</h1><h2 id=\"十进制转二进制\"><a href=\"#十进制转二进制\" class=\"headerlink\" title=\"十进制转二进制\"></a>十进制转二进制</h2><p>十进制数除2取余法即十进制数除2，余数为权位上的数，得到的商值继续除2，依此步骤继续向下运算直到商为0为止。</p>\n<h2 id=\"二进制转十进制\"><a href=\"#二进制转十进制\" class=\"headerlink\" title=\"二进制转十进制\"></a>二进制转十进制</h2><p>把二进制数按权展开,相加即得十进制数。</p>\n<h2 id=\"二进制转八进制\"><a href=\"#二进制转八进制\" class=\"headerlink\" title=\"二进制转八进制\"></a>二进制转八进制</h2><p>3位二进制数按权展开相加得到1位八进制数,（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。</p>\n<h2 id=\"八进制转成二进制\"><a href=\"#八进制转成二进制\" class=\"headerlink\" title=\"八进制转成二进制\"></a>八进制转成二进制</h2><p>八进制数通过除2取余法，得到二进制数，对每个八进制为3个二进制，不足时在最左边补零。</p>\n<h2 id=\"二进制转十六进制\"><a href=\"#二进制转十六进制\" class=\"headerlink\" title=\"二进制转十六进制\"></a>二进制转十六进制</h2><p>与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）</p>\n<h2 id=\"十进制与八进制与十六进制之间的转换\"><a href=\"#十进制与八进制与十六进制之间的转换\" class=\"headerlink\" title=\"十进制与八进制与十六进制之间的转换\"></a>十进制与八进制与十六进制之间的转换</h2><h3 id=\"十进制转八进制或者十六进制有两种方法\"><a href=\"#十进制转八进制或者十六进制有两种方法\" class=\"headerlink\" title=\"十进制转八进制或者十六进制有两种方法\"></a>十进制转八进制或者十六进制有两种方法</h3><p>2：间接法—把十进制转成二进制，然后再由二进制转成八进制或者十六进制。这里不再做图片用法解释。</p>\n<p>1：把十进制转八进制或者十六进制按照除8或者16取余，直到商为0为止。</p>\n<h2 id=\"八进制或者十六进制转成十进制\"><a href=\"#八进制或者十六进制转成十进制\" class=\"headerlink\" title=\"八进制或者十六进制转成十进制\"></a>八进制或者十六进制转成十进制</h2><p>把八进制、十六进制数按权展开、相加即得十进制数。</p>\n"},{"title":"你想清楚了吗","abbrlink":39064,"date":"2020-06-07T03:13:52.000Z","cover":"/img/5.webp","_content":"\n所以，想清楚了吗？\n怀疑的就再想清楚，\n想清楚了就别再犹豫。\n\n到底你，\n是怎样的你。\n你想要的是什么，\n\n然后，\n给自己多一点信心，\n对自己多一点尊重。\n相信自己所做的决择。\n\n因为你，\n得决定你想要什么，\n不要让别人带给你的想象\n左右你的目标。\n\n让自己，\n为自己而活，为值得的而活，\n别再为别人所得到所拥有，\n而自己没必要的一切而烦恼。","source":"_posts/5.md","raw":"---\ntitle: 你想清楚了吗\ncategories: 文章\nabbrlink: 39064\ndate: 2020-06-07 11:13:52\ntags:\ncover: '/img/5.webp'\n\n\n---\n\n所以，想清楚了吗？\n怀疑的就再想清楚，\n想清楚了就别再犹豫。\n\n到底你，\n是怎样的你。\n你想要的是什么，\n\n然后，\n给自己多一点信心，\n对自己多一点尊重。\n相信自己所做的决择。\n\n因为你，\n得决定你想要什么，\n不要让别人带给你的想象\n左右你的目标。\n\n让自己，\n为自己而活，为值得的而活，\n别再为别人所得到所拥有，\n而自己没必要的一切而烦恼。","slug":"5","published":1,"updated":"2021-08-01T07:45:15.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky03p48100090cum1xdlgn8p","content":"<p>所以，想清楚了吗？<br>怀疑的就再想清楚，<br>想清楚了就别再犹豫。</p>\n<p>到底你，<br>是怎样的你。<br>你想要的是什么，</p>\n<p>然后，<br>给自己多一点信心，<br>对自己多一点尊重。<br>相信自己所做的决择。</p>\n<p>因为你，<br>得决定你想要什么，<br>不要让别人带给你的想象<br>左右你的目标。</p>\n<p>让自己，<br>为自己而活，为值得的而活，<br>别再为别人所得到所拥有，<br>而自己没必要的一切而烦恼。</p>\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"excerpt":"","more":"<p>所以，想清楚了吗？<br>怀疑的就再想清楚，<br>想清楚了就别再犹豫。</p>\n<p>到底你，<br>是怎样的你。<br>你想要的是什么，</p>\n<p>然后，<br>给自己多一点信心，<br>对自己多一点尊重。<br>相信自己所做的决择。</p>\n<p>因为你，<br>得决定你想要什么，<br>不要让别人带给你的想象<br>左右你的目标。</p>\n<p>让自己，<br>为自己而活，为值得的而活，<br>别再为别人所得到所拥有，<br>而自己没必要的一切而烦恼。</p>\n"},{"title":"Java equals和==的区别","cover":"/img/java.webp","abbrlink":65180,"date":"2020-06-16T10:01:58.000Z","_content":"# ==\n==不要和=搞混了,=是一个赋值\n而==是一个比较运算符，基本数据类型比较的是值，引用数据类型比较的值是地址值。\n这个运算符的两边如果都是基本数据类型,判断的是基本数据类型的值是否相等\n比如:\n```\nint i=1;\nint n=1;\nSystem.out.println(i==j);//返回值为true\n```\n# equals\nequals()是一个方法，只能比较引用数据类型。重写前比较的是地址值，重写后比一般是比较对象的属性。\n如果没有重写equals方法,就是继承自Object的equals方法,Object类中的equals方法判断的是地址\n判断String类型的数据除外,Object类中的equals方法在判断String类型数据时,判断的是内容\n```\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n```","source":"_posts/6.md","raw":"---\ntitle: Java equals和==的区别\ncategories: 技术\ntags:\n  - java\n  - 基础\ncover: '/img/java.webp'\nabbrlink: 65180\ndate: 2020-06-16 18:01:58\n---\n# ==\n==不要和=搞混了,=是一个赋值\n而==是一个比较运算符，基本数据类型比较的是值，引用数据类型比较的值是地址值。\n这个运算符的两边如果都是基本数据类型,判断的是基本数据类型的值是否相等\n比如:\n```\nint i=1;\nint n=1;\nSystem.out.println(i==j);//返回值为true\n```\n# equals\nequals()是一个方法，只能比较引用数据类型。重写前比较的是地址值，重写后比一般是比较对象的属性。\n如果没有重写equals方法,就是继承自Object的equals方法,Object类中的equals方法判断的是地址\n判断String类型的数据除外,Object类中的equals方法在判断String类型数据时,判断的是内容\n```\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n```","slug":"6","published":1,"updated":"2021-08-01T07:40:58.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky03p483000b0cumfey86ehe","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h1><p>==不要和=搞混了,=是一个赋值<br>而==是一个比较运算符，基本数据类型比较的是值，引用数据类型比较的值是地址值。<br>这个运算符的两边如果都是基本数据类型,判断的是基本数据类型的值是否相等<br>比如:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i=1;</span><br><span class=\"line\">int n=1;</span><br><span class=\"line\">System.out.println(i==j);//返回值为true</span><br></pre></td></tr></table></figure>\n<h1 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals\"></a>equals</h1><p>equals()是一个方法，只能比较引用数据类型。重写前比较的是地址值，重写后比一般是比较对象的属性。<br>如果没有重写equals方法,就是继承自Object的equals方法,Object类中的equals方法判断的是地址<br>判断String类型的数据除外,Object类中的equals方法在判断String类型数据时,判断的是内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean equals(Object anObject) &#123;</span><br><span class=\"line\">        if (this == anObject) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (anObject instanceof String) &#123;</span><br><span class=\"line\">            String anotherString = (String)anObject;</span><br><span class=\"line\">            int n = value.length;</span><br><span class=\"line\">            if (n == anotherString.value.length) &#123;</span><br><span class=\"line\">                char v1[] = value;</span><br><span class=\"line\">                char v2[] = anotherString.value;</span><br><span class=\"line\">                int i = 0;</span><br><span class=\"line\">                while (n-- != 0) &#123;</span><br><span class=\"line\">                    if (v1[i] != v2[i])</span><br><span class=\"line\">                        return false;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h1><p>==不要和=搞混了,=是一个赋值<br>而==是一个比较运算符，基本数据类型比较的是值，引用数据类型比较的值是地址值。<br>这个运算符的两边如果都是基本数据类型,判断的是基本数据类型的值是否相等<br>比如:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i=1;</span><br><span class=\"line\">int n=1;</span><br><span class=\"line\">System.out.println(i==j);//返回值为true</span><br></pre></td></tr></table></figure>\n<h1 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals\"></a>equals</h1><p>equals()是一个方法，只能比较引用数据类型。重写前比较的是地址值，重写后比一般是比较对象的属性。<br>如果没有重写equals方法,就是继承自Object的equals方法,Object类中的equals方法判断的是地址<br>判断String类型的数据除外,Object类中的equals方法在判断String类型数据时,判断的是内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean equals(Object anObject) &#123;</span><br><span class=\"line\">        if (this == anObject) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (anObject instanceof String) &#123;</span><br><span class=\"line\">            String anotherString = (String)anObject;</span><br><span class=\"line\">            int n = value.length;</span><br><span class=\"line\">            if (n == anotherString.value.length) &#123;</span><br><span class=\"line\">                char v1[] = value;</span><br><span class=\"line\">                char v2[] = anotherString.value;</span><br><span class=\"line\">                int i = 0;</span><br><span class=\"line\">                while (n-- != 0) &#123;</span><br><span class=\"line\">                    if (v1[i] != v2[i])</span><br><span class=\"line\">                        return false;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>"},{"title":"java循环","cover":"/img/java.webp","abbrlink":55803,"date":"2020-06-23T11:45:34.000Z","_content":"# 循环的定义：\n利用计算机来执行多次重复的操作\n# 循环的分类：\n## for循环：\nfor(初始A;条件判断B;循环操作C){\n//循环体D\n}\nfor循环执行流程：\n第一次： A>B(true)>D>C\n第二次： B(true)>D>C\n第三次： B(true)>D>C\n...\n第n次: B(false) 结束整个循环\n比如：\n```\nfor(int i = 0;i<10;i++){\n​     System.out.println(\"Hello World\");\n}\n```\n## while循环：\nwhile(条件表达式（布尔类型）){\n//条件满足执行\n}\n比如：\n```\nint i = 0;\nwhile(i < 10){\n  System.out.println(\"Hello World\");\n  i++;\n}\n```","source":"_posts/7.md","raw":"---\ntitle: java循环\ncategories: 技术\ntags:\n  - java\n  - 基础\ncover: '/img/java.webp'\nabbrlink: 55803\ndate: 2020-06-23 19:45:34\n---\n# 循环的定义：\n利用计算机来执行多次重复的操作\n# 循环的分类：\n## for循环：\nfor(初始A;条件判断B;循环操作C){\n//循环体D\n}\nfor循环执行流程：\n第一次： A>B(true)>D>C\n第二次： B(true)>D>C\n第三次： B(true)>D>C\n...\n第n次: B(false) 结束整个循环\n比如：\n```\nfor(int i = 0;i<10;i++){\n​     System.out.println(\"Hello World\");\n}\n```\n## while循环：\nwhile(条件表达式（布尔类型）){\n//条件满足执行\n}\n比如：\n```\nint i = 0;\nwhile(i < 10){\n  System.out.println(\"Hello World\");\n  i++;\n}\n```","slug":"7","published":1,"updated":"2021-08-01T07:44:14.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky03p489000f0cumctz4eolr","content":"<h1 id=\"循环的定义：\"><a href=\"#循环的定义：\" class=\"headerlink\" title=\"循环的定义：\"></a>循环的定义：</h1><p>利用计算机来执行多次重复的操作</p>\n<h1 id=\"循环的分类：\"><a href=\"#循环的分类：\" class=\"headerlink\" title=\"循环的分类：\"></a>循环的分类：</h1><h2 id=\"for循环：\"><a href=\"#for循环：\" class=\"headerlink\" title=\"for循环：\"></a>for循环：</h2><p>for(初始A;条件判断B;循环操作C){<br>//循环体D<br>}<br>for循环执行流程：<br>第一次： A&gt;B(true)&gt;D&gt;C<br>第二次： B(true)&gt;D&gt;C<br>第三次： B(true)&gt;D&gt;C<br>…<br>第n次: B(false) 结束整个循环<br>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i = 0;i&lt;10;i++)&#123;</span><br><span class=\"line\">​     System.out.println(&quot;Hello World&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"while循环：\"><a href=\"#while循环：\" class=\"headerlink\" title=\"while循环：\"></a>while循环：</h2><p>while(条件表达式（布尔类型）){<br>//条件满足执行<br>}<br>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 0;</span><br><span class=\"line\">while(i &lt; 10)&#123;</span><br><span class=\"line\">  System.out.println(&quot;Hello World&quot;);</span><br><span class=\"line\">  i++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"excerpt":"","more":"<h1 id=\"循环的定义：\"><a href=\"#循环的定义：\" class=\"headerlink\" title=\"循环的定义：\"></a>循环的定义：</h1><p>利用计算机来执行多次重复的操作</p>\n<h1 id=\"循环的分类：\"><a href=\"#循环的分类：\" class=\"headerlink\" title=\"循环的分类：\"></a>循环的分类：</h1><h2 id=\"for循环：\"><a href=\"#for循环：\" class=\"headerlink\" title=\"for循环：\"></a>for循环：</h2><p>for(初始A;条件判断B;循环操作C){<br>//循环体D<br>}<br>for循环执行流程：<br>第一次： A&gt;B(true)&gt;D&gt;C<br>第二次： B(true)&gt;D&gt;C<br>第三次： B(true)&gt;D&gt;C<br>…<br>第n次: B(false) 结束整个循环<br>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i = 0;i&lt;10;i++)&#123;</span><br><span class=\"line\">​     System.out.println(&quot;Hello World&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"while循环：\"><a href=\"#while循环：\" class=\"headerlink\" title=\"while循环：\"></a>while循环：</h2><p>while(条件表达式（布尔类型）){<br>//条件满足执行<br>}<br>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 0;</span><br><span class=\"line\">while(i &lt; 10)&#123;</span><br><span class=\"line\">  System.out.println(&quot;Hello World&quot;);</span><br><span class=\"line\">  i++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"《解忧杂货店》读后感","abbrlink":5700,"date":"2020-06-24T09:38:54.000Z","cover":"https://z3.ax1x.com/2021/08/01/Wzkylt.jpg","_content":"\n# 简介：\n![](/img/8-1.jpg)\n《解忧杂货店》是日本作家东野圭吾写作的长篇小说。2011年于《小说野性时代》连载，于2012年3月由角川书店发行单行本。\n\n该书讲述了在僻静街道旁的一家杂货店，只要写下烦恼投进店前门卷帘门的投信口，第二天就会在店后的牛奶箱里得到回答：因男友身患绝症，年轻女孩月兔在爱情与梦想间徘徊；松冈克郎为了音乐梦想离家漂泊，却在现实中寸步难行；少年浩介面临家庭巨变，挣扎在亲情与未来的迷茫中……他们将困惑写成信投进杂货店，奇妙的事情随即不断发生。\n\n该书获得第七届中央公论文艺奖、苹果日报翻译小说销售排行榜连续两季第二名，荣登纪伊国屋、诚品、博客来、金石堂各大排行榜第1名，亚马逊中国2015年度畅销图书榜第二。\n\n同名华语电影于2017年上映。2017年12月15日，亚马逊中国发布基于亚马逊阅读大数据产生的一系列年度阅读榜单。其中，东野圭吾的《解忧杂货店》连续4年上榜，又一次成为2017年亚马逊最畅销图书。\n# 读后感：\n\n故事开头，三个无业青年盗窃因车抛锚，在天亮之前暂避到废弃的杂货店里，无意中在店里的牛奶箱里接到了一封来自于过去的咨询信。\n原来这个杂货店在三十多年前，是一家帮人解决烦恼的杂货店，晚年丧偶的店主通过回复一封封求助的来信，重新找到了被需要的感觉。因缘际会，店主去世之后的来信，就这样来到了他们的手中。而那种被人信任和需要的感觉，是他们在很久以来都没有感受过的。\n因此，他们开始以‘浪矢杂货店’的名义给人回信——尽管错别字很多，语气也很粗鲁不文，但是他们也像浪矢爷爷一样真心对待这些信，一封封来自过去的困惑，迷茫，通过牛奶箱来到了现在，不知不觉的，这些信改变了过去那些人的人生，也改变了信箱这头三个青年的人生。\n\n东野圭吾采用了截然不同的角度来分别讲述这四个故事，分开看独立成章，连起来又对情节起到了层层推进的作用。四个故事中出现的人物，都隐隐的和\"浪矢杂货店”以及孤儿院”丸光园”有着千丝万缕的联系，其间每个人不经意的选择和行为，都像投入水面的石子一样，造成了持续不断的涟漪，这些涟漪不断扩大，渐渐形成了牢不可破的羁绊，过去未来终于交汇。\n\n浪矢爷爷曾经和他的儿子说，“很多时候，咨询的人心里已经有了答案，来咨询只是想确认自己的决定是对的。”他们只是迷途的羔羊，手中都有地图，却没有去看，或是不知道自己的位置，所以回信的人只要点出他们的羁绊所在，他们就知道该如何走下去。但是敦也他们三人则是一张白纸，因为没有羁绊，所以即使想决定目的地，也不知道路在哪里。\n\n“地图是一张白纸，这当然很伤脑筋，任何人都会不知所措。可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己，一切都是自由的，在你面前是无限的可能。”这是浪矢爷爷最后回复的一封咨询信，是给未来这三位接班人的信。经由这封信，他们也终于理清了自己身上隐形的羁绊，并且心甘情愿地背负起这甜蜜的负担——为所有需要自己的、相信自己的人去努力，如果没有的话，那么就要努力证明自己来获得别人的认可，变成会令别人需要和相信的存在，这是他们所选择的路，也是我们应该去走的路。","source":"_posts/8.md","raw":"---\ntitle: 《解忧杂货店》读后感\nabbrlink: 5700\ncategories: 文章\ndate: 2020-06-24 17:38:54\ntags:\n  - 书籍\ncover: 'https://z3.ax1x.com/2021/08/01/Wzkylt.jpg'\n---\n\n# 简介：\n![](/img/8-1.jpg)\n《解忧杂货店》是日本作家东野圭吾写作的长篇小说。2011年于《小说野性时代》连载，于2012年3月由角川书店发行单行本。\n\n该书讲述了在僻静街道旁的一家杂货店，只要写下烦恼投进店前门卷帘门的投信口，第二天就会在店后的牛奶箱里得到回答：因男友身患绝症，年轻女孩月兔在爱情与梦想间徘徊；松冈克郎为了音乐梦想离家漂泊，却在现实中寸步难行；少年浩介面临家庭巨变，挣扎在亲情与未来的迷茫中……他们将困惑写成信投进杂货店，奇妙的事情随即不断发生。\n\n该书获得第七届中央公论文艺奖、苹果日报翻译小说销售排行榜连续两季第二名，荣登纪伊国屋、诚品、博客来、金石堂各大排行榜第1名，亚马逊中国2015年度畅销图书榜第二。\n\n同名华语电影于2017年上映。2017年12月15日，亚马逊中国发布基于亚马逊阅读大数据产生的一系列年度阅读榜单。其中，东野圭吾的《解忧杂货店》连续4年上榜，又一次成为2017年亚马逊最畅销图书。\n# 读后感：\n\n故事开头，三个无业青年盗窃因车抛锚，在天亮之前暂避到废弃的杂货店里，无意中在店里的牛奶箱里接到了一封来自于过去的咨询信。\n原来这个杂货店在三十多年前，是一家帮人解决烦恼的杂货店，晚年丧偶的店主通过回复一封封求助的来信，重新找到了被需要的感觉。因缘际会，店主去世之后的来信，就这样来到了他们的手中。而那种被人信任和需要的感觉，是他们在很久以来都没有感受过的。\n因此，他们开始以‘浪矢杂货店’的名义给人回信——尽管错别字很多，语气也很粗鲁不文，但是他们也像浪矢爷爷一样真心对待这些信，一封封来自过去的困惑，迷茫，通过牛奶箱来到了现在，不知不觉的，这些信改变了过去那些人的人生，也改变了信箱这头三个青年的人生。\n\n东野圭吾采用了截然不同的角度来分别讲述这四个故事，分开看独立成章，连起来又对情节起到了层层推进的作用。四个故事中出现的人物，都隐隐的和\"浪矢杂货店”以及孤儿院”丸光园”有着千丝万缕的联系，其间每个人不经意的选择和行为，都像投入水面的石子一样，造成了持续不断的涟漪，这些涟漪不断扩大，渐渐形成了牢不可破的羁绊，过去未来终于交汇。\n\n浪矢爷爷曾经和他的儿子说，“很多时候，咨询的人心里已经有了答案，来咨询只是想确认自己的决定是对的。”他们只是迷途的羔羊，手中都有地图，却没有去看，或是不知道自己的位置，所以回信的人只要点出他们的羁绊所在，他们就知道该如何走下去。但是敦也他们三人则是一张白纸，因为没有羁绊，所以即使想决定目的地，也不知道路在哪里。\n\n“地图是一张白纸，这当然很伤脑筋，任何人都会不知所措。可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己，一切都是自由的，在你面前是无限的可能。”这是浪矢爷爷最后回复的一封咨询信，是给未来这三位接班人的信。经由这封信，他们也终于理清了自己身上隐形的羁绊，并且心甘情愿地背负起这甜蜜的负担——为所有需要自己的、相信自己的人去努力，如果没有的话，那么就要努力证明自己来获得别人的认可，变成会令别人需要和相信的存在，这是他们所选择的路，也是我们应该去走的路。","slug":"8","published":1,"updated":"2021-08-01T07:43:41.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky03p48e000h0cumdeebbqmv","content":"<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1><p><img src=\"/img/8-1.jpg\"><br>《解忧杂货店》是日本作家东野圭吾写作的长篇小说。2011年于《小说野性时代》连载，于2012年3月由角川书店发行单行本。</p>\n<p>该书讲述了在僻静街道旁的一家杂货店，只要写下烦恼投进店前门卷帘门的投信口，第二天就会在店后的牛奶箱里得到回答：因男友身患绝症，年轻女孩月兔在爱情与梦想间徘徊；松冈克郎为了音乐梦想离家漂泊，却在现实中寸步难行；少年浩介面临家庭巨变，挣扎在亲情与未来的迷茫中……他们将困惑写成信投进杂货店，奇妙的事情随即不断发生。</p>\n<p>该书获得第七届中央公论文艺奖、苹果日报翻译小说销售排行榜连续两季第二名，荣登纪伊国屋、诚品、博客来、金石堂各大排行榜第1名，亚马逊中国2015年度畅销图书榜第二。</p>\n<p>同名华语电影于2017年上映。2017年12月15日，亚马逊中国发布基于亚马逊阅读大数据产生的一系列年度阅读榜单。其中，东野圭吾的《解忧杂货店》连续4年上榜，又一次成为2017年亚马逊最畅销图书。</p>\n<h1 id=\"读后感：\"><a href=\"#读后感：\" class=\"headerlink\" title=\"读后感：\"></a>读后感：</h1><p>故事开头，三个无业青年盗窃因车抛锚，在天亮之前暂避到废弃的杂货店里，无意中在店里的牛奶箱里接到了一封来自于过去的咨询信。<br>原来这个杂货店在三十多年前，是一家帮人解决烦恼的杂货店，晚年丧偶的店主通过回复一封封求助的来信，重新找到了被需要的感觉。因缘际会，店主去世之后的来信，就这样来到了他们的手中。而那种被人信任和需要的感觉，是他们在很久以来都没有感受过的。<br>因此，他们开始以‘浪矢杂货店’的名义给人回信——尽管错别字很多，语气也很粗鲁不文，但是他们也像浪矢爷爷一样真心对待这些信，一封封来自过去的困惑，迷茫，通过牛奶箱来到了现在，不知不觉的，这些信改变了过去那些人的人生，也改变了信箱这头三个青年的人生。</p>\n<p>东野圭吾采用了截然不同的角度来分别讲述这四个故事，分开看独立成章，连起来又对情节起到了层层推进的作用。四个故事中出现的人物，都隐隐的和”浪矢杂货店”以及孤儿院”丸光园”有着千丝万缕的联系，其间每个人不经意的选择和行为，都像投入水面的石子一样，造成了持续不断的涟漪，这些涟漪不断扩大，渐渐形成了牢不可破的羁绊，过去未来终于交汇。</p>\n<p>浪矢爷爷曾经和他的儿子说，“很多时候，咨询的人心里已经有了答案，来咨询只是想确认自己的决定是对的。”他们只是迷途的羔羊，手中都有地图，却没有去看，或是不知道自己的位置，所以回信的人只要点出他们的羁绊所在，他们就知道该如何走下去。但是敦也他们三人则是一张白纸，因为没有羁绊，所以即使想决定目的地，也不知道路在哪里。</p>\n<p>“地图是一张白纸，这当然很伤脑筋，任何人都会不知所措。可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己，一切都是自由的，在你面前是无限的可能。”这是浪矢爷爷最后回复的一封咨询信，是给未来这三位接班人的信。经由这封信，他们也终于理清了自己身上隐形的羁绊，并且心甘情愿地背负起这甜蜜的负担——为所有需要自己的、相信自己的人去努力，如果没有的话，那么就要努力证明自己来获得别人的认可，变成会令别人需要和相信的存在，这是他们所选择的路，也是我们应该去走的路。</p>\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"excerpt":"","more":"<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1><p><img src=\"/img/8-1.jpg\"><br>《解忧杂货店》是日本作家东野圭吾写作的长篇小说。2011年于《小说野性时代》连载，于2012年3月由角川书店发行单行本。</p>\n<p>该书讲述了在僻静街道旁的一家杂货店，只要写下烦恼投进店前门卷帘门的投信口，第二天就会在店后的牛奶箱里得到回答：因男友身患绝症，年轻女孩月兔在爱情与梦想间徘徊；松冈克郎为了音乐梦想离家漂泊，却在现实中寸步难行；少年浩介面临家庭巨变，挣扎在亲情与未来的迷茫中……他们将困惑写成信投进杂货店，奇妙的事情随即不断发生。</p>\n<p>该书获得第七届中央公论文艺奖、苹果日报翻译小说销售排行榜连续两季第二名，荣登纪伊国屋、诚品、博客来、金石堂各大排行榜第1名，亚马逊中国2015年度畅销图书榜第二。</p>\n<p>同名华语电影于2017年上映。2017年12月15日，亚马逊中国发布基于亚马逊阅读大数据产生的一系列年度阅读榜单。其中，东野圭吾的《解忧杂货店》连续4年上榜，又一次成为2017年亚马逊最畅销图书。</p>\n<h1 id=\"读后感：\"><a href=\"#读后感：\" class=\"headerlink\" title=\"读后感：\"></a>读后感：</h1><p>故事开头，三个无业青年盗窃因车抛锚，在天亮之前暂避到废弃的杂货店里，无意中在店里的牛奶箱里接到了一封来自于过去的咨询信。<br>原来这个杂货店在三十多年前，是一家帮人解决烦恼的杂货店，晚年丧偶的店主通过回复一封封求助的来信，重新找到了被需要的感觉。因缘际会，店主去世之后的来信，就这样来到了他们的手中。而那种被人信任和需要的感觉，是他们在很久以来都没有感受过的。<br>因此，他们开始以‘浪矢杂货店’的名义给人回信——尽管错别字很多，语气也很粗鲁不文，但是他们也像浪矢爷爷一样真心对待这些信，一封封来自过去的困惑，迷茫，通过牛奶箱来到了现在，不知不觉的，这些信改变了过去那些人的人生，也改变了信箱这头三个青年的人生。</p>\n<p>东野圭吾采用了截然不同的角度来分别讲述这四个故事，分开看独立成章，连起来又对情节起到了层层推进的作用。四个故事中出现的人物，都隐隐的和”浪矢杂货店”以及孤儿院”丸光园”有着千丝万缕的联系，其间每个人不经意的选择和行为，都像投入水面的石子一样，造成了持续不断的涟漪，这些涟漪不断扩大，渐渐形成了牢不可破的羁绊，过去未来终于交汇。</p>\n<p>浪矢爷爷曾经和他的儿子说，“很多时候，咨询的人心里已经有了答案，来咨询只是想确认自己的决定是对的。”他们只是迷途的羔羊，手中都有地图，却没有去看，或是不知道自己的位置，所以回信的人只要点出他们的羁绊所在，他们就知道该如何走下去。但是敦也他们三人则是一张白纸，因为没有羁绊，所以即使想决定目的地，也不知道路在哪里。</p>\n<p>“地图是一张白纸，这当然很伤脑筋，任何人都会不知所措。可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己，一切都是自由的，在你面前是无限的可能。”这是浪矢爷爷最后回复的一封咨询信，是给未来这三位接班人的信。经由这封信，他们也终于理清了自己身上隐形的羁绊，并且心甘情愿地背负起这甜蜜的负担——为所有需要自己的、相信自己的人去努力，如果没有的话，那么就要努力证明自己来获得别人的认可，变成会令别人需要和相信的存在，这是他们所选择的路，也是我们应该去走的路。</p>\n"},{"title":"Hello World","sticky":1,"cover":"https://z3.ax1x.com/2021/08/01/WxOLPU.jpg","abbrlink":"4a17b156","description":"这是一个记录学习笔记和分享奇奇怪怪的地方！","_content":"# Welcome\nWelcome to [乔一禾](https://www.qiaoyihe.com/)! 这是一个记录学习笔记和分享奇奇怪怪的地方！","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\nsticky: 1\ncover: 'https://z3.ax1x.com/2021/08/01/WxOLPU.jpg'\nabbrlink: 4a17b156\ndescription: 这是一个记录学习笔记和分享奇奇怪怪的地方！\n---\n# Welcome\nWelcome to [乔一禾](https://www.qiaoyihe.com/)! 这是一个记录学习笔记和分享奇奇怪怪的地方！","slug":"hello-world","published":1,"date":"2022-01-04T13:41:15.453Z","updated":"2022-01-04T14:24:55.891Z","_id":"cky03p48y000n0cumhd2beo2j","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Welcome\"><a href=\"#Welcome\" class=\"headerlink\" title=\"Welcome\"></a>Welcome</h1><p>Welcome to <a href=\"https://www.qiaoyihe.com/\">乔一禾</a>! 这是一个记录学习笔记和分享奇奇怪怪的地方！</p>\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"excerpt":"","more":"<h1 id=\"Welcome\"><a href=\"#Welcome\" class=\"headerlink\" title=\"Welcome\"></a>Welcome</h1><p>Welcome to <a href=\"https://www.qiaoyihe.com/\">乔一禾</a>! 这是一个记录学习笔记和分享奇奇怪怪的地方！</p>\n"},{"title":"java入门阶级,每个 Java 初学者都应该收藏","abbrlink":53415,"date":"2020-07-13T13:02:27.000Z","description":"Java 基础和 Java 面向对象编程","cover":"/img/java.webp","_content":"\n这么说吧，在我眼里，Java 就是最流行的编程语言，没有之一（PHP 往一边站）。不仅岗位多，容易找到工作，关键是薪资水平也到位，不学 Java 亏得慌，对吧？\n那可能零基础学编程的小伙伴就会头疼了，网上关于 Java 的大部分技术文章都不够幽默，不够风趣，不够系列，急需要一份能看得进去的学习手册，那我觉得我肝的这份手册正好符合要求，并且会一直持续更新下去。\n第一版的内容暂时包含两方面，Java 基础和 Java 面向对象编程。来吧，先上目录，一睹为快。\n01、Java 基本语法简介\n02、Java 基本数据类型简介\n03、Java main() 方法简介\n04、Java 的流程控制语句\n05、Java 包的简介\n06、Java 到底是值传递还是引用传递\n07、Java 的类和对象\n08、Java 构造方法\n09、Java 抽象类\n10、Java 接口\n11、Java 继承\n12、this 关键字\n13、super 关键字\n14、重写和重载\n15、static 关键字\n16、Java 枚举\n17、final 关键字\n目录欣赏完了，接下来就是拜读精华内容的时间，搬个小板凳，认认真真好好学吧，学到就是赚到！\n\n\n# 一、Java 基本语法简介\n## 01、数据类型\nJava 有 2 种数据类型，一种是基本数据类型，一种是引用类型。\n基本数据类型用于存储简单类型的数据，比如说，int、long、byte、short 用于存储整数，float、double 用于存储浮点数，char 用于存储字符，boolean 用于存储布尔值。\n不同的基本数据类型，有不同的默认值和大小，来个表格感受下。\n\n\n数据类型|默认值|大小\n-- | --|--\nboolean |false|1比特\nchar|0|2字节\nbyte|0|1字节\nshort|0|2字节\nint|0|4字节\nlong|0L|8字节\nfloat|0.0f|4字节\ndouble|0.0 |8字节\n\n引用类型用于存储对象（null 表示没有值的对象）的引用，String 是引用类型的最佳代表，比如说 String cmower = \"沉默王二\"。\n\n## 02、声明变量\n要声明一个变量，必须指定它的名字和类型，来看一个简单的示例：\n```\nint age;\nString name;\n```\ncount 和 name 在声明后会得到一个默认值，按照它们的数据类型——不能是局部变量（否则 Java 编译器会在你使用变量的时候提醒要先赋值），必须是类成员变量。\n```\npublic class SyntaxLocalVariable {\n    int age;\n    String name;\n\n    public static void main(String[] args) {\n        SyntaxLocalVariable syntax = new SyntaxLocalVariable();\n        System.out.println(syntax.age); // 输出 0\n        System.out.println(syntax.name);  // 输出 null\n    }\n}\n```\n也可以在声明一个变量后使用“=”操作符进行赋值，就像下面这样：\n```\nint age = 18;\nString name = \"沉默王二\";\n```\n我们定义了 2 个变量，int 类型的 age 和 String 类型的 name，age 赋值 18，name 赋值为“沉默王二”。\n每行代码后面都跟了一个“;”，表示当前语句结束了。\n在 Java 中，变量最好遵守命名约定，这样能提高代码的可阅读性。\n\n- 以字母、下划线（_）或者美元符号（$）开头\n- 不能使用 Java 的保留字，比如说 int 不能作为变量名\n\n## 03、数组\n数组在 Java 中占据着重要的位置，它是很多集合类的底层实现。数组属于引用类型，它用来存储一系列指定类型的数据。\n声明数组的一般语法如下所示：\n```\ntype[] identiier = new type[length];\n```\ntype 可以是任意的基本数据类型或者引用类型。来看下面这个例子：\n```\npublic class ArraysDemo {\n    public static void main(String[] args) {\n        int [] nums = new int[10];\n        nums[0] = 18;\n        nums[1] = 19;\n        System.out.println(nums[0]);\n    }\n}\n```\n数组的索引从 0 开始，第一个元素的索引为 0，第二个元素的索引为 1。为什么要这样设计？感兴趣的话，你可以去探究一下。\n通过变量名[索引]的方式可以访问数组指定索引处的元素，赋值或者取值是一样的。\n\n## 04、关键字\n关键字属于保留字，在 Java 中具有特殊的含义，比如说 public、final、static、new 等等，它们不能用来作为变量名。为了便于你作为参照，我列举了 48 个常用的关键字，你可以瞅一瞅。\n\n1： abstract： abstract 关键字用于声明抽象类——可以有抽象和非抽象方法。\n\n2： boolean： boolean 关键字用于将变量声明为布尔值类型，它只有 true 和 false 两个值。\n\n3： break： break 关键字用于中断循环或 switch 语句。\n\n4： byte： byte 关键字用于声明一个可以容纳 8 个比特的变量。\n\n5： case： case 关键字用于在 switch 语句中标记条件的值。\n\n6： catch： catch 关键字用于捕获 try 语句中的异常。\n\n7： char： char 关键字用于声明一个可以容纳无符号 16 位比特的 Unicode 字符的变量。\n\n8： class： class 关键字用于声明一个类。\n\n9： continue： continue 关键字用于继续下一个循环。它可以在指定条件下跳过其余代码。\n\n10：default： default 关键字用于指定 switch 语句中除去 case 条件之外的默认代码块。\n\n11：do： do 关键字通常和 while 关键字配合使用，do 后紧跟循环体。\n\n12：double： double 关键字用于声明一个可以容纳 64 位浮点数的变量。\n\n13：else： else 关键字用于指示 if 语句中的备用分支。\n\n14：enum： enum（枚举）关键字用于定义一组固定的常量。\n\n15：extends： extends 关键字用于指示一个类是从另一个类或接口继承的。\n\n16：final： final 关键字用于指示该变量是不可更改的。\n\n17：finally： finally 关键字和 try-catch 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。\n\n18：float： float 关键字用于声明一个可以容纳 32 位浮点数的变量。\n\n19：for： for 关键字用于启动一个 for 循环，如果循环次数是固定的，建议使用 for 循环。\n\n20：if： if 关键字用于指定条件，如果条件为真，则执行对应代码。\n\n21：implements： implements 关键字用于实现接口。\n\n22：import： import 关键字用于导入对应的类或者接口。\n\n23：instanceof： instanceof 关键字用于判断对象是否属于某个类型（class）。\n\n24：int： int 关键字用于声明一个可以容纳 32 位带符号的整数变量。\n\n25：interface： interface 关键字用于声明接口——只能具有抽象方法。\n\n26：long： long 关键字用于声明一个可以容纳 64 位整数的变量。\n\n27：native： native 关键字用于指定一个方法是通过调用本机接口（非 Java）实现的。\n\n28：new： new 关键字用于创建一个新的对象。\n\n29：null： 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null。\n\n30：package： package 关键字用于声明类所在的包。\n\n31：private： private 关键字是一个访问修饰符，表示方法或变量只对当前类可见。\n\n32：protected： protected 关键字也是一个访问修饰符，表示方法或变量对同一包内的类和所有子类可见。\n\n33：public： public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。\n\n34：return： return 关键字用于在代码执行完成后返回（一个值）。\n\n35：short： short 关键字用于声明一个可以容纳 16 位整数的变量。\n\n36：static： static 关键字表示该变量或方法是静态变量或静态方法。\n\n37：strictfp：  strictfp 关键字并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。\n\n38：super： super 关键字可用于调用父类的方法或者变量。\n\n39：switch： switch 关键字通常用于三个（以上）的条件判断。\n\n40：synchronized： synchronized 关键字用于指定多线程代码中的同步方法、变量或者代码块。\n\n41：this： this 关键字可用于在方法或构造函数中引用当前对象。\n\n42：throw： throw 关键字主动抛出异常。\n\n43：throws： throws 关键字用于声明异常。\n\n44：transient： transient 关键字在序列化的使用用到，它修饰的字段不会被序列化。\n\n45：try： try 关键字用于包裹要捕获异常的代码块。\n\n46：void： void 关键字用于指定方法没有返回值。\n\n47：volatile： volatile 关键字保证了不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n\n48：while： 如果循环次数不固定，建议使用 while 循环。\n![](https://www.qyihe.xyz/images/post/10.1.jpg)\n## 05、操作符\n除去“=”赋值操作符，Java 中还有很多其他作用的操作符，我们来大致看一下。\n### ①、算术运算符\n\n-  +（加号）\n-  –（减号）\n-  *（乘号）\n-  /（除号）\n-  ％（取余）\n\n来看一个例子：\n```\npublic class ArithmeticOperator {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 5;\n        \n        System.out.println(a + b);//15  \n        System.out.println(a - b);//5  \n        System.out.println(a * b);//50  \n        System.out.println(a / b);//2  \n        System.out.println(a % b);//0  \n    }\n}\n```\n“+”号比较特殊，还可以用于字符串拼接，来看一个例子：\n```\nString result = \"沉默王二\" + \"一枚有趣的程序员\";\n```\n### ②、逻辑运算符\n逻辑运算符通常用于布尔表达式，常见的有：\n\n- &&（AND）多个条件中只要有一个为 false 结果就为 false\n- ||（OR）多个条件只要有一个为 true 结果就为 true\n- !（NOT）条件如果为 true，加上“!”就为 false，否则，反之。\n\n来看一个例子：\n```\npublic class LogicalOperator {\n    public static void main(String[] args) {\n        int a=10;\n        int b=5;\n        int c=20;\n        System.out.println(a<b&&a<c);//false\n        System.out.println(a>b||a<c);//true\n        System.out.println(!(a<b)); // true\n    }\n}\n```\n### ③、比较运算符\n\n-  < (小于)\n-  <= (小于或者等于)\n-  >(大于)\n-  >= (大于或者等于)\n-  == (相等)\n-  != (不等)\n\n## 06、程序结构\nJava 中最小的程序单元叫做类，一个类可以有一个或者多个字段（也叫作成员变量），还可以有一个或者多个方法，甚至还可以有一些内部类。\n如果一个类想要执行，就必须有一个 main 方法——程序运行的入口，就好像人的嘴一样，嗯，可以这么牵强的理解一下。\n```\npublic class StructureProgram {\n    public static void main(String[] args) {\n        System.out.println(\"没有成员变量，只有一个 main 方法\");\n    }\n}\n```\n- 类名叫做 StructureProgram，在它里面，只有一个 main 方法。\n- {} 之间的代码称之为代码块。\n- 以上源代码将会保存在一个后缀名为 java 的文件中。\n\n## 07、编译然后执行代码\n通常，一些教程在介绍这块内容的时候，建议你通过命令行中先执行 javac 命令将源代码编译成字节码文件，然后再执行 java 命令指定代码。\n但我不希望这个糟糕的局面再继续下去了——新手安装配置 JDK 真的蛮需要勇气和耐心的，稍有不慎，没入门就先放弃了。况且，在命令行中编译源代码会遇到很多莫名其妙的错误，这对新手是极其致命的——如果你再遇到这种老式的教程，可以吐口水了。\n好的方法，就是去下载 IntelliJ IDEA，简称 IDEA，它被业界公认为最好的 Java 集成开发工具，尤其在智能代码助手、代码自动提示、代码重构、代码版本管理(Git、SVN、Maven)、单元测试、代码分析等方面有着亮眼的发挥。IDEA 产于捷克（位于东欧），开发人员以严谨著称。IDEA 分为社区版和付费版两个版本，新手直接下载社区版就足够用了。\n安装成功后，可以开始敲代码了，然后直接右键运行（连保存都省了），结果会在 Run 面板中显示，如下图所示。\n![](https://www.qyihe.xyz/images/post/10.2.jpg)\n想查看反编译后的字节码的话，可以在 src 的同级目录 target/classes 的包路径下找到一个 StructureProgram.class 的文件（如果找不到的话，在目录上右键选择「Reload from Disk」）。\n可以双击打开它。\n```\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\npackage com.cmower.baeldung.basic;\n\npublic class StructureProgram {\n    public StructureProgram() {\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"没有成员变量，只有一个 main 方法\");\n    }\n}\n```\nIDEA 默认会用 Fernflower 将 class 字节码反编译为我们可以看得懂的 Java 代码。实际上，class 字节码（请安装 show bytecode 插件）长下面这个样子：\n```\n// class version 57.65535 (-65479)\n// access flags 0x21\npublic class com/cmower/baeldung/basic/StructureProgram {\n\n  // compiled from: StructureProgram.java\n\n  // access flags 0x1\n  public <init>()V\n   L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.<init> ()V\n    RETURN\n   L1\n    LOCALVARIABLE this Lcom/cmower/baeldung/basic/StructureProgram; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n  // access flags 0x9\n  public static main([Ljava/lang/String;)V\n   L0\n    LINENUMBER 5 L0\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"\\u6ca1\\u6709\\u6210\\u5458\\u53d8\\u91cf\\uff0c\\u53ea\\u6709\\u4e00\\u4e2a main \\u65b9\\u6cd5\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n   L1\n    LINENUMBER 6 L1\n    RETURN\n   L2\n    LOCALVARIABLE args [Ljava/lang/String; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n```\n新手看起来还是有些懵逼的，建议过过眼瘾就行了。\n![](https://www.qyihe.xyz/images/post/10.3.jpg)\n# 二、Java 基本数据类型简介\n## 01、布尔\n布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：\n```\nboolean flag = true;\n```\n## 02、byte\nbyte 的取值范围在 -128 和 127 之间，包含 127。最小值为 -128，最大值为 127，默认值为 0。\n在网络传输的过程中，为了节省空间，常用字节来作为数据的传输方式。代码示例：\n```\nbyte a = 10;\nbyte b = -10;\n```\n## 03、short\nshort 的取值范围在 -32,768 和 32,767 之间，包含 32,767。最小值为 -32,768，最大值为 32,767，默认值为 0。代码示例：\n```\nshort s = 10000;\nshort r = -5000;\n```\n## 04、int\nint 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间，默认值为 0。如果没有特殊需求，整形数据就用 int。代码示例：\n```\nint a = 100000;\nint b = -200000;\n```\n## 05、long\nlong 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间，默认值为 0。如果 int 存储不下，就用 long，整形数据就用 int。代码示例：\n```\nlong a = 100000L; \nlong b = -200000L;\n```\n为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。\n## 06、float\nfloat 是单精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围是无限的，默认值为 0.0f。float 不适合用于精确的数值，比如说货币。代码示例：\n```\nfloat f1 = 234.5f;\n```\n为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。\n## 07、double\ndouble 是双精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围也是无限的，默认值为 0.0。double 同样不适合用于精确的数值，比如说货币。代码示例：\n```\ndouble d1 = 12.3\n```\n那精确的数值用什么表示呢？最好使用 BigDecimal，它可以表示一个任意大小且精度完全准确的浮点数。针对货币类型的数值，也可以先乘以 100 转成整形进行处理。\nTips：单精度是这样的格式，1 位符号，8 位指数，23 位小数，有效位数为 7 位。\n![](https://www.qyihe.xyz/images/post/10.4.jpg)\n双精度是这样的格式，1 位符号，11 位指数，52 为小数，有效位数为 16 位。\n![](https://www.qyihe.xyz/images/post/10.5.jpg)\n取值范围取决于指数位，计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。\n\n>一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。\n\n## 08、char\nchar 可以表示一个 16 位的 Unicode 字符，其值范围在 '\\u0000'（0）和 '\\uffff'（65,535）（包含）之间。代码示例：\n```\nchar letterA = 'A'; // 用英文的单引号包裹住。\n```\n# 三、Java main() 方法简介\n每个程序都需要一个入口，对于 Java 程序来说，入口就是 main 方法。\n```\npublic static void main(String[] args) {\n\n}\n```\n- public、static、void 这 3 个关键字在前面的内容已·经介绍过了，如果觉得回去找比较麻烦的话，这里再贴一下：\n\n- public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。\n\n- static 关键字表示该变量或方法是静态变量或静态方法，可以直接通过类访问，不需要实例化对象来访问。\n\n- void 关键字用于指定方法没有返回值。\n\n另外，main 关键字为方法的名字，Java 虚拟机在执行程序时会寻找这个标识符；args 为 main() 方法的参数名，它的类型为一个 String 数组，也就是说，在使用 java 命令执行程序的时候，可以给 main() 方法传递字符串数组作为参数。\n```\njava HelloWorld 沉默王二 沉默王三\n```\njavac 命令用来编译程序，java 命令用来执行程序，HelloWorld 为这段程序的类名，沉默王二和沉默王三为字符串数组，中间通过空格隔开，然后就可以在 main() 方法中通过 args[0] 和 args[1] 获取传递的参数值了。\n```\npublic class HelloWorld {\n    public static void main(String[] args) {\n        if (\"沉默王二\".equals(args[0])) {\n            \n        }\n        \n        if (\"沉默王三\".equals(args[1])) {\n            \n        }\n    }\n}\n```\nmain() 方法的写法并不是唯一的，还有其他几种变体，尽管它们可能并不常见，可以简单来了解一下。\n\n第二种，把方括号 [] 往 args 靠近而不是 String 靠近：\n```\npublic static void main(String []args) { \n\n}\n```\n第三种，把方括号 [] 放在 args 的右侧：\n```\npublic static void main(String args[]) {\n\n}\n```\n第四种，还可以把数组形式换成可变参数的形式：\n```\npublic static void main(String...args) { \n\n}\n```\n第五种，在 main() 方法上添加另外一个修饰符 strictfp，用于强调在处理浮点数时的兼容性：\n```\npublic strictfp static void main(String[] args) { \n\n}\n```\n也可以在 main() 方法上添加 final 关键字或者 synchronized 关键字。\n\n第六种，还可以为 args 参数添加 final 关键字：\n```\npublic static void main(final String[] args) { \n\n}\n```\n第七种，最复杂的一种，所有可以添加的关键字统统添加上：\n```\nfinal static synchronized strictfp void main(final String[] args) { \n\n}\n```\n当然了，并不需要为了装逼特意把 main() 方法写成上面提到的这些形式，使用 IDE 提供的默认形式就可以了。\n# 四、Java 的流程控制语句\n- 在 Java 中，有三种类型的流程控制语句：\n\n- 条件分支，用于在两个或者多个条件之间做出选择，常见的有 if/else/else if、三元运算符和 switch 语句。\n\n- 循环或者遍历，常见的有 for、while 和 do-while。\n\n- break 和 continue，用于跳出循环或者跳过进入下一轮循环。\n\n## if 语句\nif 语句的格式如下：\n```\nif(布尔表达式){  \n// 如果条件为 true，则执行这块代码\n} \n```\n画个流程图表示一下：\n![](https://www.qyihe.xyz/images/post/10.6.jpg)\n来写个示例：\n```\npublic class IfExample {\n    public static void main(String[] args) {\n        int age = 20;\n        if (age < 30) {\n            System.out.println(\"青春年华\");\n        }\n    }\n}\n```\n输出：\n```\n青春年华\n```\n## if-else 语句\nif-else 语句的格式如下:\n```\nif(布尔表达式){  \n// 条件为 true 时执行的代码块\n}else{  \n// 条件为 false  时执行的代码块\n}  \n```\n画个流程图表示一下：\n![](https://www.qyihe.xyz/images/post/10.7.jpg)\n来写个示例：\n```\npublic class IfElseExample {\n    public static void main(String[] args) {\n        int age = 31;\n        if (age < 30) {\n            System.out.println(\"青春年华\");\n        } else {\n            System.out.println(\"而立之年\");\n        }\n    }\n}\n```\n输出：\n```\n而立之年\n```\n除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：\n```\npublic class LeapYear {\n    public static void main(String[] args) {\n        int year = 2020;\n        if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n            System.out.println(\"闰年\");\n        } else {\n            System.out.println(\"普通年份\");\n        }\n    }\n}\n```\n输出：\n```\n闰年\n```\n如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。\n```\npublic class IfElseTernaryExample {\n    public static void main(String[] args) {\n        int num = 13;\n        String result = (num % 2 == 0) ? \"偶数\" : \"奇数\";\n        System.out.println(result);\n    }\n}\n```\n输出：\n```\n奇数\n```\n## if-else-if 语句\nif-else-if 语句的格式如下：\n```\nif(条件1){  \n// 条件1 为 true 时执行的代码\n}else if(条件2){  \n// 条件2 为 true 时执行的代码\n}  \nelse if(条件3){  \n// 条件3 为 true 时执行的代码\n}  \n...  \nelse{  \n// 以上条件均为 false 时执行的代码\n} \n```\n画个流程图表示一下：\n![](https://www.qyihe.xyz/images/post/10.8.jpg)\n来写个示例：\n```\npublic class IfElseIfExample {\n    public static void main(String[] args) {\n        int age = 31;\n        if (age < 30) {\n            System.out.println(\"青春年华\");\n        } else if (age >= 30 && age < 40 ) {\n            System.out.println(\"而立之年\");\n        } else if (age >= 40 && age < 50 ) {\n            System.out.println(\"不惑之年\");\n        } else {\n            System.out.println(\"知天命\");\n        }\n    }\n}\n```\n输出：\n```\n而立之年\n```\n## if 嵌套语句\nif 嵌套语句的格式如下：\n```\nif(外侧条件){    \n     // 外侧条件为 true 时执行的代码 \n          if(内侧条件){  \n             // 内侧条件为 true 时执行的代码\n    }    \n}  \n```\n画个流程图表示一下：\n![](https://www.qyihe.xyz/images/post/10.9.jpg)\n来写个示例：\n```\npublic class NestedIfExample {\n    public static void main(String[] args) {\n        int age = 20;\n        boolean isGirl = true;\n        if (age >= 20) {\n            if (isGirl) {\n                System.out.println(\"女生法定结婚年龄\");\n            }\n        }\n    }\n}\n```\n输出：\n```\n女生法定结婚年龄\n```\n## switch 语句的格式：\n```\nswitch(变量) {    \ncase 可选值1:    \n // 可选值1匹配后执行的代码;    \n break;  // 该关键字是可选项\ncase 可选值2:    \n // 可选值2匹配后执行的代码;    \n break;  // 该关键字是可选项\n......    \n    \ndefault: // 该关键字是可选项     \n // 所有可选值都不匹配后执行的代码 \n}    \n```\n\n- 变量可以有 1 个或者 N 个值。\n\n- 值类型必须和变量类型是一致的，并且值是确定的。\n\n- 值必须是唯一的，不能重复，否则编译会出错。\n\n- break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。\n\n- default 关键字也是可选的。\n![](https://www.qyihe.xyz/images/post/10.10.jpg)\n画个流程图：\n\n来个示例：\n```\npublic class Switch1 {\n    public static void main(String[] args) {\n        int age = 20;\n        switch (age) {\n            case 20 :\n                System.out.println(\"上学\");\n                break;\n            case 24 :\n                System.out.println(\"苏州工作\");\n                break;\n            case 30 :\n                System.out.println(\"洛阳工作\");\n                break;\n            default:\n                System.out.println(\"未知\");\n                break; // 可省略\n        }\n    }\n}\n```\n输出：\n```\n上学\n```\n当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：\n```\npublic class Switch2 {\n    public static void main(String[] args) {\n        String name = \"沉默王二\";\n        switch (name) {\n            case \"詹姆斯\":\n                System.out.println(\"篮球运动员\");\n                break;\n            case \"穆里尼奥\":\n                System.out.println(\"足球教练\");\n                break;\n            case \"沉默王二\":\n            case \"沉默王三\":\n                System.out.println(\"乒乓球爱好者\");\n                break;\n            default:\n                throw new IllegalArgumentException(\n                        \"名字没有匹配项\");\n\n        }\n    }\n}\n```\n输出：\n```\n乒乓球爱好者\n```\n枚举作为 switch 语句的变量也很常见，来看例子：\n```\npublic class SwitchEnumDemo {\n    public enum PlayerTypes {\n        TENNIS,\n        FOOTBALL,\n        BASKETBALL,\n        UNKNOWN\n    }\n\n    public static void main(String[] args) {\n        System.out.println(createPlayer(PlayerTypes.BASKETBALL));\n    }\n\n    private static String createPlayer(PlayerTypes playerType) {\n        switch (playerType) {\n            case TENNIS:\n                return \"网球运动员费德勒\";\n            case FOOTBALL:\n                return \"足球运动员C罗\";\n            case BASKETBALL:\n                return \"篮球运动员詹姆斯\";\n            case UNKNOWN:\n                throw new IllegalArgumentException(\"未知\");\n            default:\n                throw new IllegalArgumentException(\n                        \"运动员类型: \" + playerType);\n\n        }\n    }\n}\n```\n输出：\n```\n篮球运动员詹姆斯\n```\n## 循环语句比较\n\n\n\n比较方式|for   |while  |do-while\n-----   | ---- | ----  | ----\n简介 |for 循环的次数是固定的 |while 循环的次数是不固定的，并且需要条件为 true |do-while 循环的次数也不固定，但会至少执行一次循环，无聊条件是否为 true\n何时使用 |循环次数固定的 |循环次数是不固定的 |循环次数不固定，并且循环体至少要执行一次\n语法 |for(init:condition;++/--) {// 要执行的代码} |while(condition){// 要执行的代码} |do{//要执行的代码}while(condition);\n\n## 普通的 for 循环\n普通的 for 循环可以分为 4 个部分：\n（1）初始变量：循环开始执行时的初始条件。\n（2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。\n（3）循环体：循环每次要执行的代码块，直到条件变为 false。\n（4）自增/自减：初识变量变化的方式。\n来看一下普通 for 循环的格式：\n```\nfor(初识变量;条件;自增/自减){  \n// 循环体\n}  \n```\n画个流程图：\n![](https://www.qyihe.xyz/images/post/10.11.jpg)\n来个示例：\n```\npublic class ForExample {\n    public static void main(String[] args) {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"沉默王二好帅啊\");\n        }\n    }\n}\n```\n输出：\n```\n沉默王二好帅啊\n沉默王二好帅啊\n沉默王二好帅啊\n沉默王二好帅啊\n沉默王二好帅啊\n```\n循环语句还可以嵌套呢，这样就可以打印出更好玩的呢。\n```\npublic class PyramidForExample {\n    public static void main(String[] args) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0;j<= i;j++) {\n                System.out.print(\"❤\");\n            }\n            System.out.println();\n        }\n    }\n}\n```\n打印出什么玩意呢？\n```\n❤\n❤❤\n❤❤❤\n❤❤❤❤\n❤❤❤❤❤\n```\n## for-each\nfor-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：\n```\nfor(元素类型 元素 : 数组或集合){  \n// 要执行的代码\n}  \n```\n来看一下示例：\n```\npublic class ForEachExample {\n    public static void main(String[] args) {\n        String[] strs = {\"沉默王二\", \"一枚有趣的程序员\"};\n\n        for (String str : strs) {\n            System.out.println(str);\n        }\n    }\n}\n```\n输出：\n```\n沉默王二\n一枚有趣的程序员\n```\n## 无限 for 循环\n想不想体验一下无限 for 循环的威力，也就是死循环？\n```\npublic class InfinitiveForExample {\n    public static void main(String[] args) {\n        for(;;){\n            System.out.println(\"停不下来。。。。\");\n        }\n    }\n}\n```\n输出：\n```\n停不下来。。。。\n停不下来。。。。\n停不下来。。。。\n停不下来。。。。\n```\n一旦运行起来，就停不下来了，除非强制停止。\n## while 循环\n```\nwhile(条件){  \n//循环体  \n}  \n```\n画个流程图：\n![](https://www.qyihe.xyz/images/post/10.12.jpg)\n来个示例：\n```\npublic class WhileExample {\n    public static void main(String[] args) {\n        int i = 0;\n        while (true) {\n            System.out.println(\"沉默王二\");\n            i++;\n            if (i == 5) {\n                break;\n            }\n        }\n    }\n}\n```\n猜猜会输出几次？\n```\n沉默王二\n沉默王二\n沉默王二\n沉默王二\n沉默王二\n```\n## do-while 循环\n```\ndo{  \n// 循环体\n}while(提交); \n```\n画个流程图：\n![](https://www.qyihe.xyz/images/post/10.13.jpg)\n来个示例：\n```\npublic class DoWhileExample {\n    public static void main(String[] args) {\n        int i = 0;\n        do {\n            System.out.println(\"沉默王二\");\n            i++;\n            if (i == 5) {\n                break;\n            }\n        } while (true);\n    }\n}\n```\n程序输出结果如下所示：\n```\n沉默王二\n沉默王二\n沉默王二\n沉默王二\n沉默王二\n```\n## break\nbreak 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。\n可以将 break 关键字用于所有类型循环语句中，比如说 for 循环，while 循环，以及 do-while 循环。\n来画个流程图感受一下：\n![](https://www.qyihe.xyz/images/post/10.14.jpg)\n用在 for 循环中的示例：\n```\nfor (int i = 1; i <= 10; i++) {\n    if (i == 5) {\n        break;\n    }\n    System.out.println(i);\n}\n```\n用在嵌套 for 循环中的示例：\n```\nfor (int i = 1; i <= 3; i++) {\n    for (int j = 1; j <= 3; j++) {\n        if (i == 2 && j == 2) {\n            break;\n        }\n        System.out.println(i + \" \" + j);\n    }\n}\n```\n用在 while 循环中的示例：\n```\nint i = 1;\nwhile (i <= 10) {\n    if (i == 5) {\n        i++;\n        break;\n    }\n    System.out.println(i);\n    i++;\n}\n```\n用在 do-while 循环中的示例：\n```\nint j = 1;\ndo {\n    if (j == 5) { \n        j++;\n        break;\n    }\n    System.out.println(j);\n    j++;\n} while (j <= 10);\n```\n## continue\n当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。\n来个示例：\n```\npublic class ContinueDemo {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 10; i++) {\n            if (i == 5) {\n                // 使用 continue 关键字\n                continue;// 5 将会被跳过\n            }\n            System.out.println(i);\n        }\n    }\n}\n```\n输出：\n```\n1\n2\n3\n4\n6\n7\n8\n9\n10\n```\n5 真的被跳过了。\n再来个循环嵌套的例子。\n```\npublic class ContinueInnerDemo {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 3; i++) {\n            for (int j = 1; j <= 3; j++) {\n                if (i == 2 && j == 2) {\n                    //  当i=2，j=2时跳过\n                    continue;\n                }\n                System.out.println(i + \" \" + j);\n            }\n        }\n    }\n}\n```\n打印出什么玩意呢？\n```\n1 1\n1 2\n1 3\n2 1\n2 3\n3 1\n3 2\n3 3\n```\n“2 2” 没有输出，被跳过了。\n再来看一下 while 循环时 continue 的使用示例：\n```\npublic class ContinueWhileDemo {\n    public static void main(String[] args) {\n        int i = 1;\n        while (i <= 10) {\n            if (i == 5) {\n                i++;\n                continue;\n            }\n            System.out.println(i);\n            i++;\n        }\n    }\n}\n```\n输出：\n```\n1\n2\n3\n4\n6\n7\n8\n9\n10\n```\n注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。\n最后，再来看一下 do-while 循环时 continue 的使用示例：\n```\npublic class ContinueDoWhileDemo {\n    public static void main(String[] args) {\n        int i=1;\n        do{\n            if(i==5){\n                i++;\n                continue;\n            }\n            System.out.println(i);\n            i++;\n        }while(i<=10);\n    }\n}\n```\n输出：\n```\n1\n2\n3\n4\n6\n7\n8\n9\n10\n```\n注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。\n# 五、Java 包的简介\n在 Java 中，我们使用 package（包）对相关的类、接口和子包进行分组。这样做的好处有：\n\n- 使相关类型更容易查找\n- 避免命名冲突，比如说 com.itwanger.Hello 和 com.itwangsan.Hello 不同\n- 通过包和访问权限控制符来限定类的可见性\n\n## 01、创建一个包\n```\npackage com.itwanger;\n```\n可以使用 package 关键字来定义一个包名，需要注意的是，这行代码必须处于一个类中的第一行。强烈建议在包中声明类，不要缺省，否则就失去了包结构的带来的好处。\n包的命名应该遵守以下规则：\n\n- 应该全部是小写字母\n- 可以包含多个单词，单词之间使用“.”连接，比如说 java.lang\n- 名称由公司名或者组织名确定，采用倒序的方式，比如说，我个人博客的域名是 www.itwanger.com，所以我创建的包名是就是 com.itwanger.xxxx。\n\n每个包或者子包都在磁盘上有自己的目录结构，如果 Java 文件时在 com.itwanger.xxxx 包下，那么该文件所在的目录结构就应该是 com->itwanger->xxxx。\n## 02、使用包\n让我们在名为 test 的子包里新建一个 Cmower 类：\n```\npackage com.itwanger.test;\n\npublic class Cmower {\n    private String name;\n    private int age;\n}\n```\n如果需要在另外一个包中使用 Cmower 类，就需要通过 import 关键字将其引入。有两种方式可供选择，第一种，使用 * 导入包下所有的类：\n```\nimport com.itwanger.test.*;\n```\n第二种，使用类名导入该类：\n```\nimport com.itwanger.test.Cmower;\n```\nJava 和第三方类库提供了很多包可供使用，可以通过上述的方式导入类库使用。\n```\npackage com.itwanger.test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CmowerTest {\n    public static void main(String[] args) {\n        List<Cmower> list = new ArrayList<>();\n        list.add(new Cmower());\n    }\n}\n```\n## 03、全名\n有时，我们可能会使用来自不同包下的两个具有相同名称的类。例如，我们可能同时使用 java.sql.Date 和 java.util.Date。当我们遇到命名冲突时，我们需要对至少一个类使用全名（包名+类名）。\n\n```List<com.itwanger.test.Cmower> list1 = new ArrayList<>();\nlist.add(new com.itwanger.test.Cmower());\n```\n# 六、Java 到底是值传递还是引用传递\n将参数传递给方法有两种常见的方式，一种是“值传递”，一种是“引用传递”。C 语言本身只支持值传递，它的衍生品 C++ 既支持值传递，也支持引用传递，而 Java 只支持值传递。\n## 01、值传递 VS 引用传递\n首先，我们必须要搞清楚，到底什么是值传递，什么是引用传递，否则，讨论 Java 到底是值传递还是引用传递就显得毫无意义。\n当一个参数按照值的方式在两个方法之间传递时，调用者和被调用者其实是用的两个不同的变量——被调用者中的变量（原始值）是调用者中变量的一份拷贝，对它们当中的任何一个变量修改都不会影响到另外一个变量。\n而当一个参数按照引用传递的方式在两个方法之间传递时，调用者和被调用者其实用的是同一个变量，当该变量被修改时，双方都是可见的。\nJava 程序员之所以容易搞混值传递和引用传递，主要是因为 Java 有两种数据类型，一种是基本类型，比如说 int，另外一种是引用类型，比如说 String。\n基本类型的变量存储的都是实际的值，而引用类型的变量存储的是对象的引用——指向了对象在内存中的地址。值和引用存储在 stack（栈）中，而对象存储在 heap（堆）中。\n![](https://www.qyihe.xyz/images/post/10.15.jpg)\n之所以有这个区别，是因为：\n\n- 栈的优势是，存取速度比堆要快，仅次于直接位于 CPU 中的寄存器。但缺点是，栈中的数据大小与生存周期必须是确定的。\n- 堆的优势是可以动态地分配内存大小，生存周期也不必事先告诉编译器，Java 的垃圾回收器会自动收走那些不再使用的数据。但由于要在运行时动态分配内存，存取速度较慢。\n\n## 02、基本类型的参数传递\n众所周知，Java 有 8 种基本数据类型，分别是 int、long、byte、short、float、double 、char 和 boolean。它们的值直接存储在栈中，每当作为参数传递时，都会将原始值（实参）复制一份新的出来，给形参用。形参将会在被调用方法结束时从栈中清除。\n来看下面这段代码：\n```\npublic class PrimitiveTypeDemo {\n    public static void main(String[] args) {\n        int age = 18;\n        modify(age);\n        System.out.println(age);\n    }\n\n    private static void modify(int age1) {\n        age1 = 30;\n    }\n}\n```\n（1）main 方法中的 age 是基本类型，所以它的值 18 直接存储在栈中。\n（2）调用 modify() 方法的时候，将为实参 age 创建一个副本（形参 age1），它的值也为 18，不过是在栈中的其他位置。\n（3）对形参 age 的任何修改都只会影响它自身而不会影响实参。\n![](https://www.qyihe.xyz/images/post/10.16.jpg)\n## 03、引用类型的参数传递\n来看一段创建引用类型变量的代码：\n```\nWriter writer = new Writer(18, \"沉默王二\");\n```\nwriter 是对象吗？还是对象的引用？为了搞清楚这个问题，我们可以把上面的代码拆分为两行代码：\n```\nWriter writer;\nwriter = new Writer(18, \"沉默王二\");\n```\n假如 writer 是对象的话，就不需要通过 new 关键字创建对象了，对吧？那也就是说，writer 并不是对象，在“=”操作符执行之前，它仅仅是一个变量。那谁是对象呢？new Writer(18, \"沉默王二\")，它是对象，存储于堆中；然后，“=”操作符将对象的引用赋值给了 writer 变量，于是 writer 此时应该叫对象引用，它存储在栈中，保存了对象在堆中的地址。\n每当引用类型作为参数传递时，都会创建一个对象引用（实参）的副本（形参），该形参保存的地址和实参一样。\n来看下面这段代码：\n```\npublic class ReferenceTypeDemo {\n    public static void main(String[] args) {\n        Writer a = new Writer(18);\n        Writer b = new Writer(18);\n        modify(a, b);\n\n        System.out.println(a.getAge());\n        System.out.println(b.getAge());\n    }\n\n    private static void modify(Writer a1, Writer b1) {\n        a1.setAge(30);\n\n        b1 = new Writer(18);\n        b1.setAge(30);\n    }\n}\n```\n（1）在调用 modify() 方法之前，实参 a 和 b 指向的对象是不一样的，尽管 age 都为 18。\n![](https://www.qyihe.xyz/images/post/10.17.jpg)\n（2）在调用 modify() 方法时，实参 a 和 b 都在栈中创建了一个新的副本，分别是 a1 和 b1，但指向的对象是一致的（a 和 a1 指向对象 a，b 和 b1 指向对象 b）。\n![](https://www.qyihe.xyz/images/post/10.18.jpg)\n（3）在 modify() 方法中，修改了形参 a1 的 age 为 30，意味着对象 a 的 age 从 18 变成了 30，而实参 a 指向的也是对象 a，所以 a 的 age 也变成了 30；形参 b1 指向了一个新的对象，随后 b1 的 age 被修改为 30。\n![](https://www.qyihe.xyz/images/post/10.19.jpg)\n修改 a1 的 age，意味着同时修改了 a 的 age，因为它们指向的对象是一个；修改 b1 的 age，对 b 却没有影响，因为它们指向的对象是两个。\n程序输出的结果如下所示：\n```\n30\n18\n```\n果然和我们的分析是吻合的。\n# 七、Java 的类和对象\n类和对象是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。对象可以是现实中看得见的任何物体（一只特立独行的猪），也可以是想象中的任何虚拟物体（能七十二变的孙悟空），Java 通过类（class）来定义这些物体，有什么状态（通过字段，或者叫成员变量定义，比如说猪的颜色是纯色还是花色），有什么行为（通过方法定义，比如说猪会吃，会睡觉）。\n来，让我来定义一个简单的类给你看看。\n```\npublic class Pig {\n    private String color;\n\n    public void eat() {\n        System.out.println(\"吃\");\n    }\n}\n```\n默认情况下，每个 Java 类都会有一个空的构造方法，尽管它在源代码中是缺省的，但却可以通过反编译字节码看到它。\n```\npublic class Pig {\n    private String color;\n\n    public Pig() {\n    }\n\n    public void eat() {\n        System.out.println(\"吃\");\n    }\n}\n```\n没错，就是多出来的那个 public Pig() {}，参数是空的，方法体是空的。我们可以通过 new 关键字利用这个构造方法来创建一个对象，代码如下所示：\n ```\n Pig pig = new Pig();\n ```\n当然了，我们也可以主动添加带参的构造方法。\n```\npublic class Pig {\n    private String color;\n\n    public Pig(String color) {\n        this.color = color;\n    }\n\n    public void eat() {\n        System.out.println(\"吃\");\n    }\n}\n```\n这时候，再查看反编译后的字节码时，你会发现缺省的无参构造方法消失了——和源代码一模一样。\n```\npublic class Pig {\n    private String color;\n\n    public Pig(String color) {\n        this.color = color;\n    }\n\n    public void eat() {\n        System.out.println(\"吃\");\n    }\n}\n```\n这意味着无法通过 new Pig() 来创建对象了——编译器会提醒你追加参数。\n![](https://www.qyihe.xyz/images/post/10.20.jpg)\n比如说你将代码修改为 new Pig(\"纯白色\")，或者添加无参的构造方法。\n```\npublic class Pig {\n    private String color;\n\n    public Pig(String color) {\n        this.color = color;\n    }\n\n    public Pig() {\n    }\n\n    public void eat() {\n        System.out.println(\"吃\");\n    }\n}\n```\n使用无参构造方法创建的对象状态默认值为 null（color 字符串为引用类型），如果是基本类型的话，默认值为对应基本类型的默认值，比如说 int 为 0，更详细的见下图。\n![](https://www.qyihe.xyz/images/post/10.21.jpg)\n（图片中有一处错误，boolean 的默认值为 false）\n接下来，我们来创建多个 Pig 对象，它的颜色各不相同。\n```\npublic class PigTest {\n    public static void main(String[] args) {\n        Pig pigNoColor = new Pig();\n        Pig pigWhite = new Pig(\"纯白色\");\n        Pig pigBlack = new Pig(\"纯黑色\");\n    }\n}\n```\n你看，我们创建了 3 个不同花色的 Pig 对象，全部来自于一个类，由此可见类的重要性，只需要定义一次，就可以多次使用。\n那假如我想改变对象的状态呢？该怎么办？目前毫无办法，因为没有任何可以更改状态的方法，直接修改 color 是行不通的，因为它的访问权限修饰符是 private 的。\n最好的办法就是为 Pig 类追加 getter/setter 方法，就像下面这样：\n```\npublic String getColor() {\n    return color;\n}\n\npublic void setColor(String color) {\n    this.color = color;\n}\n```\n通过 setColor() 方法来修改，通过 getColor() 方法获取状态，它们的权限修饰符是 public 的。\n```\nPig pigNoColor = new Pig();\npigNoColor.setColor(\"花色\");\nSystem.out.println(pigNoColor.getColor()); // 花色\n```\n为什么要这样设计呢？可以直接将 color 字段的访问权限修饰符换成是 public 的啊，不就和 getter/setter 一样的效果了吗？\n因为有些情况，某些字段是不允许被随意修改的，它只有在对象创建的时候初始化一次，比如说猪的年龄，它只能每年长一岁（举个例子），没有月光宝盒让它变回去。\n```\nprivate int age;\n\npublic int getAge() {\n    return age;\n}\n\npublic void increaseAge() {\n    this.age++;\n}\n```\n你看，age 就没有 setter 方法，只有一个每年可以调用一次的 increaseAge() 方法和 getter 方法。如果把 age 的访问权限修饰符更改为 public，age 就完全失去控制了，可以随意将其重置为 0 或者负数。\n访问权限修饰符对于 Java 来说，非常重要，目前共有四种：public、private、protected 和 default（缺省）。\n一个类只能使用 public 或者 default 修饰，public 修饰的类你之前已经见到过了，现在我来定义一个缺省权限修饰符的类给你欣赏一下。\n```\nclass Dog {\n}\n```\n哈哈，其实也没啥可以欣赏的。缺省意味着这个类可以被同一个包下的其他类进行访问；而 public 意味着这个类可以被所有包下的类进行访问。\n假如硬要通过 private 和 protected 来修饰类的话，编译器会生气的，它不同意。\n![](https://www.qyihe.xyz/images/post/10.22.jpg)\nprivate 可以用来修饰类的构造方法、字段和方法，只能被当前类进行访问。protected 也可以用来修饰类的构造方法、字段和方法，但它的权限范围更宽一些，可以被同一个包中的类进行访问，或者当前类的子类。\n可以通过下面这张图来对比一下四个权限修饰符之间的差别：\n![](https://www.qyihe.xyz/images/post/10.23.jpg)\n\n- 同一个类中，不管是哪种权限修饰符，都可以访问；\n- 同一个包下，private 修饰的无法访问；\n- 子类可以访问 public 和 protected 修饰的；\n- public 修饰符面向世界，哈哈，可以被所有的地方访问到。\n![](https://www.qyihe.xyz/images/post/10.24.jpg)\n# 八、Java 构造方法\n假设现在有一个 Writer 类，它有两个字段，姓名和年纪：\n```\npublic class Writer {\n    private String name;\n    private int age;\n\n    @Override\n    public String toString() {\n        return \"Writer{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n```\n重写了 toString() 方法，用于打印 Writer 类的详情。由于没有构造方法，意味着当我们创建 Writer 对象时，它的字段值并没有初始化：\n```\nWriter writer = new Writer();\nSystem.out.println(writer.toString());\n```\n输出结果如下所示：\n```\nWriter{name='null', age=0}\n```\nname 是字符串类型，所以默认值为 null，age 为 int 类型，所以默认值为 0。\n让我们为 Writer 类主动加一个无参的构造方法：\n```\npublic Writer() {\n    this.name = \"\";\n    this.age = 0;\n}\n```\n构造方法也是一个方法，只不过它没有返回值，默认返回创建对象的类型。需要注意的是，当前构造方法没有参数，它被称为无参构造方法。如果我们没有主动创建无参构造方法的话，编译器会隐式地自动添加一个无参的构造方法。这就是为什么，一开始虽然没有构造方法，却可以使用 new Writer() 创建对象的原因，只不过，所有的字段都被初始化成了默认值。\n接下来，让我们添加一个有参的构造方法：\n```\npublic Writer(String name, int age) {\n    this.name = name;\n    this.age = age;\n}\n```\n现在，我们创建 Writer 对象的时候就可以通过对字段值初始化值了。\n```\nWriter writer1 = new Writer(\"沉默王二\",18);\nSystem.out.println(writer1.toString());\n```\n来看一下打印结果：\n```\nWriter{name='沉默王二', age=18}\n```\n可以根据字段的数量添加不同参数数量的构造方法，比如说，我们可以单独为 name 字段添加一个构造方法：\n```\npublic Writer(String name) {\n    this.name = name;\n}\n```\n为了能够兼顾 age 字段，我们可以通过 this 关键字调用其他的构造方法：\n```\npublic Writer(String name) {\n    this(name,18);\n}\n```\n把作者的年龄都默认初始化为 18。如果需要使用父类的构造方法，还可以使用 super 关键字，手册后面有详细的介绍。\n# 九、Java 抽象类\n当我们要完成的任务是确定的，但具体的方式需要随后开个会投票的话，Java 的抽象类就派上用场了。这句话怎么理解呢？搬个小板凳坐好，听我来给你讲讲。\n![](https://www.qyihe.xyz/images/post/10.25.jpg)\n## 01、抽象类的 5 个关键点\n（1）定义抽象类的时候需要用到关键字 abstract，放在 class 关键字前。\n```\npublic abstract class AbstractPlayer {\n}\n```\n关于抽象类的命名，阿里出品的 Java 开发手册上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，记住了哦。\n（2）抽象类不能被实例化，但可以有子类。\n尝试通过 new 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。\n![](https://www.qyihe.xyz/images/post/10.26.jpg)\n通过 extends 关键字可以继承抽象类，继承后，BasketballPlayer 类就是 AbstractPlayer 的子类。\n```\npublic class BasketballPlayer extends AbstractPlayer {\n}\n```\n（3）如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。\n当在一个普通类（没有使用 abstract 关键字修饰）中定义了抽象方法，编译器就会有两处错误提示。\n第一处在类级别上，提醒你“这个类必须通过 abstract 关键字定义”，or 的那个信息没必要，见下图。\n![](https://www.qyihe.xyz/images/post/10.27.jpg)\n第二处在方法级别上，提醒你“抽象方法所在的类不是抽象的”，见下图。\n![](https://www.qyihe.xyz/images/post/10.28.jpg)\n（4）抽象类可以同时声明抽象方法和具体方法，也可以什么方法都没有，但没必要。就像下面这样：\n```\npublic abstract class AbstractPlayer {\n    abstract void play();\n    \n    public void sleep() {\n        System.out.println(\"运动员也要休息而不是挑战极限\");\n    }\n}\n```\n（5）抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类中定义了 play() 方法，子类中就必须实现。\n```\npublic class BasketballPlayer extends AbstractPlayer {\n    @Override\n    void play() {\n        System.out.println(\"我是张伯伦，篮球场上得过 100 分\");\n    }\n}\n```\n如果没有实现的话，编译器会提醒你“子类必须实现抽象方法”，见下图。\n![](https://www.qyihe.xyz/images/post/10.29.jpg)\n## 02、什么时候用抽象类\n与抽象类息息相关的还有一个概念，就是接口，我们留到下一篇文章中详细说，因为要说的知识点还是蛮多的。你现在只需要有这样一个概念就好，接口是对行为的抽象，抽象类是对整个类（包含成员变量和行为）进行抽象。\n（是不是有点明白又有点不明白，别着急，翘首以盼地等下一篇文章出炉吧）\n除了接口之外，还有一个概念就是具体的类，就是不通过 abstract 修饰的普通类，见下面这段代码中的定义。\n```\npublic class BasketballPlayer {\n   public void play() {\n        System.out.println(\"我是詹姆斯，现役第一人\");\n    }\n}\n```\n有接口，有具体类，那什么时候该使用抽象类呢？\n（1）我们希望一些通用的功能被多个子类复用。比如说，AbstractPlayer 抽象类中有一个普通的方法 sleep()，表明所有运动员都需要休息，那么这个方法就可以被子类复用。\n```\npublic abstract class AbstractPlayer {\n    public void sleep() {\n        System.out.println(\"运动员也要休息而不是挑战极限\");\n    }\n}\n```\n虽然 AbstractPlayer 类可以不是抽象类——把 abstract 修饰符去掉也能满足这种场景。但 AbstractPlayer 类可能还会有一个或者多个抽象方法。\nBasketballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。\n```\npublic class BasketballPlayer extends AbstractPlayer {\n}\n```\nBasketballPlayer 对象可以直接调用 sleep() 方法：\n```\nBasketballPlayer basketballPlayer = new BasketballPlayer();\nbasketballPlayer.sleep();\n```\nFootballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。\n```\npublic class FootballPlayer extends AbstractPlayer {\n}\n```\nFootballPlayer 对象也可以直接调用 sleep() 方法：\n```\nFootballPlayer footballPlayer = new FootballPlayer();\nfootballPlayer.sleep();\n```\n（2）我们需要在抽象类中定义好 API，然后在子类中扩展实现。比如说，AbstractPlayer  抽象类中有一个抽象方法 play()，定义所有运动员都可以从事某项运动，但需要对应子类去扩展实现。\n```\npublic abstract class AbstractPlayer {\n    abstract void play();\n}\n```\nBasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。\n```\npublic class BasketballPlayer extends AbstractPlayer {\n    @Override\n    void play() {\n        System.out.println(\"我是张伯伦，我篮球场上得过 100 分，\");\n    }\n}```\n\nFootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。\n```\npublic class FootballPlayer extends AbstractPlayer {\n    @Override\n    void play() {\n        System.out.println(\"我是C罗，我能接住任意高度的头球\");\n    }\n}\n```\n（3）如果父类与子类之间的关系符合 is-a 的层次关系，就可以使用抽象类，比如说篮球运动员是运动员，足球运动员是运动员。\n## 03、具体示例\n为了进一步展示抽象类的特性，我们再来看一个具体的示例。假设现在有一个文件，里面的内容非常简单——“Hello World”，现在需要有一个读取器将内容读取出来，最好能按照大写的方式，或者小写的方式。\n这时候，最好定义一个抽象类，比如说 BaseFileReader：\n```\npublic abstract class BaseFileReader {\n    protected Path filePath;\n\n    protected BaseFileReader(Path filePath) {\n        this.filePath = filePath;\n    }\n\n    public List<String> readFile() throws IOException {\n        return Files.lines(filePath)\n                .map(this::mapFileLine).collect(Collectors.toList());\n    }\n\n    protected abstract String mapFileLine(String line);\n}\n```\nfilePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问。\nreadFile() 方法用来读取文件，方法体里面调用了抽象方法 mapFileLine()——需要子类扩展实现大小写的方式。\n你看，BaseFileReader 设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。\n小写的方式：\n```\npublic class LowercaseFileReader extends BaseFileReader {\n    protected LowercaseFileReader(Path filePath) {\n        super(filePath);\n    }\n\n    @Override\n    protected String mapFileLine(String line) {\n        return line.toLowerCase();\n    }\n}\n```\n大写的方式：\n```\npublic class UppercaseFileReader extends BaseFileReader {\n    protected UppercaseFileReader(Path filePath) {\n        super(filePath);\n    }\n\n    @Override\n    protected String mapFileLine(String line) {\n        return line.toUpperCase();\n    }\n}\n```\n你看，从文件里面一行一行读取内容的代码被子类复用了——抽象类 BaseFileReader 类中定义的普通方法 readFile()。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。\n接下来，我们来新建一个测试类 FileReaderTest：\n```\npublic class FileReaderTest {\n    public static void main(String[] args) throws URISyntaxException, IOException {\n        URL location = FileReaderTest.class.getClassLoader().getResource(\"helloworld.txt\");\n        Path path = Paths.get(location.toURI());\n        BaseFileReader lowercaseFileReader = new LowercaseFileReader(path);\n        BaseFileReader uppercaseFileReader = new UppercaseFileReader(path);\n        System.out.println(lowercaseFileReader.readFile());\n        System.out.println(uppercaseFileReader.readFile());\n    }\n}\n```\n项目的 resource 目录下有一个文本文件，名字叫 helloworld.txt。\n![](https://www.qyihe.xyz/images/post/10.30.jpg)\n可以通过 ClassLoader.getResource() 的方式获取到该文件的 URI 路径，然后就可以使用 LowercaseFileReader 和 UppercaseFileReader 两种方式读取到文本内容了。\n输出结果如下所示：\n```\n[hello world]\n[HELLO WORLD]\n```\n# 十、Java 接口\n对于面向对象编程来说，抽象是一个极具魅力的特征。如果一个程序员的抽象思维很差，那他在编程中就会遇到很多困难，无法把业务变成具体的代码。在 Java 中，可以通过两种形式来达到抽象的目的，一种是抽象类，另外一种就是接口。\n如果你现在就想知道抽象类与接口之间的区别，我可以提前给你说一个：\n\n- 一个类只能继承一个抽象类，但却可以实现多个接口。\n\n当然了，在没有搞清楚接口到底是什么，它可以做什么之前，这个区别理解起来会有点难度。\n## 01、接口是什么\n接口是通过 interface 关键字定义的，它可以包含一些常量和方法，来看下面这个示例。\n```\npublic interface Electronic {\n    // 常量\n    String LED = \"LED\";\n\n    // 抽象方法\n    int getElectricityUse();\n\n    // 静态方法\n    static boolean isEnergyEfficient(String electtronicType) {\n        return electtronicType.equals(LED);\n    }\n\n    // 默认方法\n    default void printDescription() {\n        System.out.println(\"电子\");\n    }\n}\n```\n（1）接口中定义的变量会在编译的时候自动加上 public static final 修饰符，也就是说 LED 变量其实是一个常量。\nJava 官方文档上有这样的声明：\n```\nEvery field declaration in the body of an interface is implicitly public, static, and final.\n```\n换句话说，接口可以用来作为常量类使用，还能省略掉 public static final，看似不错的一种选择，对吧？\n不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。\n（2）没有使用 private、default 或者 static 关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 public abstract 修饰符。也就是说 getElectricityUse() 其实是一个抽象方法，没有方法体——这是定义接口的本意。\n（3）从 Java 8 开始，接口中允许有静态方法，比如说 isEnergyEfficient() 方法。\n静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口的名字来调用，比如说 Electronic.isEnergyEfficient(\"LED\")。\n接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。\n（4）接口中允许定义 default 方法也是从 Java 8 开始的，比如说 printDescription()，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现，也就是说，无法直接使用一个“;”号来结束默认方法——编译器会报错的。\n![](https://www.qyihe.xyz/images/post/10.31.jpg)\n允许在接口中定义默认方法的理由是很充分的，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 default 方法的帮助下，我们就必须挨个对实现类进行修改。\n来看一下 Electronic 接口反编译后的字节码吧，你会发现，接口中定义的所有变量或者方法，都会自动添加上 public 关键字——假如你想知道编译器在背后都默默做了哪些辅助，记住反编译字节码就对了。\n```\npublic interface Electronic\n{\n\n    public abstract int getElectricityUse();\n\n    public static boolean isEnergyEfficient(String electtronicType)\n    {\n        return electtronicType.equals(\"LED\");\n    }\n\n    public void printDescription()\n    {\n        System.out.println(\"\\u7535\\u5B50\");\n    }\n\n    public static final String LED = \"LED\";\n}\n```\n有些读者可能会问，“二哥，为什么我反编译后的字节码和你的不一样，你用了什么反编译工具？”其实没有什么秘密，微信搜「沉默王二」回复关键字「JAD」就可以免费获取了，超级好用。\n## 02、定义接口的注意事项\n由之前的例子我们就可以得出下面这些结论：\n\n- 接口中允许定义变量\n- 接口中允许定义抽象方法\n- 接口中允许定义静态方法（Java 8 之后）\n- 接口中允许定义默认方法（Java 8 之后）\n\n除此之外，我们还应该知道：\n（1）接口不允许直接实例化。\n![](https://www.qyihe.xyz/images/post/10.32.jpg)\n需要定义一个类去实现接口，然后再实例化。\n```\npublic class Computer implements Electronic {\n\n    public static void main(String[] args) {\n        new Computer();\n    }\n\n    @Override\n    public int getElectricityUse() {\n        return 0;\n    }\n}\n```\n（2）接口可以是空的，既不定义变量，也不定义方法。\n```\npublic interface Serializable {\n}\n```\nSerializable 是最典型的一个空的接口，我之前分享过一篇文章《Java Serializable：明明就一个空的接口嘛》，感兴趣的读者可以去我的个人博客看一看，你就明白了空接口的意义。\n```\nwww.itwanger.com/java/2019/1…\n```\n\n（3）不要在定义接口的时候使用 final 关键字，否则会报编译错误，因为接口就是为了让子类实现的，而 final 阻止了这种行为。\n![](https://www.qyihe.xyz/images/post/10.33.jpg)\n（4）接口的抽象方法不能是 private、protected 或者 final。\n![](https://www.qyihe.xyz/images/post/10.34.jpg)\n![](https://www.qyihe.xyz/images/post/10.35.jpg)\n![](https://www.qyihe.xyz/images/post/10.36.jpg)\n（5）接口的变量是隐式 public static final，所以其值无法改变。\n## 03、接口可以做什么\n（1）使某些实现类具有我们想要的功能，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了 Comparable 或者 Comparator 的类具有比较功能。\nCloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 Object.clone() 方法，否则会抛出 CloneNotSupportedException。\n```\npublic class CloneableTest implements Cloneable {\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    public static void main(String[] args) throws CloneNotSupportedException {\n        CloneableTest c1 = new CloneableTest();\n        CloneableTest c2 = (CloneableTest) c1.clone();\n    }\n}\n```\n运行后没有报错。现在把 implements Cloneable 去掉。\n```\npublic class CloneableTest {\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    public static void main(String[] args) throws CloneNotSupportedException {\n        CloneableTest c1 = new CloneableTest();\n        CloneableTest c2 = (CloneableTest) c1.clone();\n\n    }\n}\n```\n运行后抛出 CloneNotSupportedException：\n```\nException in thread \"main\" java.lang.CloneNotSupportedException: com.cmower.baeldung.interface1.CloneableTest\n\tat java.base/java.lang.Object.clone(Native Method)\n\tat com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:6)\n\tat com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:11)\n```\n至于 Comparable 和 Comparator 的用法，感兴趣的读者可以参照我之前写的另外一篇文章《来吧，一文彻底搞懂Java中的Comparable和Comparator》。\n```\nwww.itwanger.com/java/2020/0…\n```\n（2）Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。\n可能有些读者会问，“二哥，为什么 Java 只支持单一继承？”简单来解释一下。\n如果有两个类共同继承（extends）一个有特定方法的父类，那么该方法会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。这也正是著名的菱形问题，见下图。\n![](https://www.qyihe.xyz/images/post/10.37.jpg)\nClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重载的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。\n接口没有这方面的困扰。来定义两个接口，Fly 会飞，Run 会跑。\n```\npublic interface Fly {\n    void fly();\n}\npublic interface Run {\n    void run();\n}\n```\n然后让一个类同时实现这两个接口。\n```\npublic class Pig implements Fly,Run{\n    @Override\n    public void fly() {\n        System.out.println(\"会飞的猪\");\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"会跑的猪\");\n    }\n}\n```\n这就在某种形式上达到了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。\n（3）实现多态。\n什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。\n多态可以通过继承（extends）的关系实现，也可以通过接口的形式实现。来看这样一个例子。\nShape 是表示一个形状。\n```\npublic interface Shape {\n    String name();\n}\n```\n圆是一个形状。\n```\npublic class Circle implements Shape {\n    @Override\n    public String name() {\n        return \"圆\";\n    }\n}\n```\n正方形也是一个形状。\n```\npublic class Square implements Shape {\n    @Override\n    public String name() {\n        return \"正方形\";\n    }\n}\n```\n然后来看测试类。\n```\nList<Shape> shapes = new ArrayList<>();\nShape circleShape = new Circle();\nShape squareShape = new Square();\n\nshapes.add(circleShape);\nshapes.add(squareShape);\n\nfor (Shape shape : shapes) {\n    System.out.println(shape.name());\n}\n```\n多态的存在 3 个前提：\n1、要有继承关系，Circle 和 Square 都实现了 Shape 接口\n2、子类要重写父类的方法，Circle 和 Square 都重写了 name() 方法\n3、父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle 对象，后者指向的是 Square 对象。\n然后，我们来看一下测试结果：\n```\n圆\n正方形\n```\n也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 name() 方法的时候，它知道 Circle 对象应该调用 Circle 类的 name() 方法，Square 对象应该调用 Square 类的 name() 方法。\n## 04、接口与抽象类的区别\n好了，关于接口的一切，你应该都搞清楚了。现在回到读者春夏秋冬的那条留言，“兄弟，说说抽象类和接口之间的区别？”\n（1）语法层面上\n\n- 接口中不能有 public 和 protected 修饰的方法，抽象类中可以有。\n- 接口中的变量只能是隐式的常量，抽象类中可以有任意类型的变量。\n- 一个类只能继承一个抽象类，但却可以实现多个接口。\n\n（2）设计层面上\n抽象类是对类的一种抽象，继承抽象类的类和抽象类本身是一种 is-a 的关系。\n接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，所有的类都可以实现 Serializable 接口，从而具有序列化的功能。\n就这么多吧，能说道这份上，我相信面试官就不会为难你了。\n# 十一、Java 继承\n在 Java 中，一个类可以继承另外一个类或者实现多个接口，我想这一点，大部分的读者应该都知道了。还有一点，我不确定大家是否知道，就是一个接口也可以继承另外一个接口，就像下面这样：\n```\npublic interface OneInterface extends Cloneable {\n}\n```\n这样做有什么好处呢？我想有一部分读者应该已经猜出来了，就是实现了 OneInterface 接口的类，也可以使用 Object.clone() 方法了。\n```\npublic class TestInterface implements OneInterface {\n    public static void main(String[] args) throws CloneNotSupportedException {\n        TestInterface c1 = new TestInterface();\n        TestInterface c2 = (TestInterface) c1.clone();\n    }\n}\n```\n除此之外，我们还可以在 OneInterface 接口中定义其他一些抽象方法（比如说深拷贝），使该接口拥有 Cloneable 所不具有的功能。\n```\npublic interface OneInterface extends Cloneable {\n    void deepClone();\n}\n```\n看到了吧？这就是继承的好处：子接口拥有了父接口的方法，使得子接口具有了父接口相同的行为；同时，子接口还可以在此基础上自由发挥，添加属于自己的行为。\n以上，把“接口”换成“类”，结论同样成立。让我们来定义一个普通的父类 Wanger：\n```\npublic class Wanger {\n    int age;\n    String name;\n    void write() {\n        System.out.println(\"我写了本《基督山伯爵》\");\n    }\n}\n```\n然后，我们再来定义一个子类 Wangxiaoer，使用关键字 extends 来继承父类 Wanger：\n```\npublic class Wangxiaoer extends Wanger{\n    @Override\n    void write() {\n        System.out.println(\"我写了本《茶花女》\");\n    }\n}\n```\n我们可以将通用的方法和成员变量放在父类中，达到代码复用的目的；然后将特殊的方法和成员变量放在子类中，除此之外，子类还可以覆盖父类的方法（比如write() 方法）。这样，子类也就焕发出了新的生命力。\nJava 只支持单一继承，这一点，我在上一篇接口的文章中已经提到过了。如果一个类在定义的时候没有使用 extends 关键字，那么它隐式地继承了 java.lang.Object 类——在我看来，这恐怕就是 Java 号称万物皆对象的真正原因了。\n那究竟子类继承了父类的什么呢？\n子类可以继承父类的非 private 成员变量，为了验证这一点，我们来看下面这个示例。\n```\npublic class Wanger {\n    String defaultName;\n    private String privateName;\n    public String publicName;\n    protected String protectedName;\n}\n```\n父类 Wanger 定义了四种类型的成员变量，缺省的 defaultName、私有的 privateName、共有的 publicName、受保护的 protectedName。\n在子类 Wangxiaoer 中定义一个测试方法 testVariable()：\n![](https://www.qyihe.xyz/images/post/10.38.jpg)\n可以确认，除了私有的 privateName，其他三种类型的成员变量都可以继承到。\n同理，子类可以继承父类的非 private 方法，为了验证这一点，我们来看下面这个示例。\n```\npublic class Wanger {\n    void write() {\n    }\n\n    private void privateWrite() {\n    }\n\n    public void publicWrite() {\n    }\n\n    protected void protectedWrite() {\n    }\n}\n```\n父类 Wanger 定义了四种类型的方法，缺省的 write、私有的 privateWrite()、共有的 publicWrite()、受保护的 protectedWrite()。\n在子类 Wangxiaoer 中定义一个 main 方法，并使用 new 关键字新建一个子类对象：\n![](https://www.qyihe.xyz/images/post/10.39.jpg)\n可以确认，除了私有的 privateWrite()，其他三种类型的方法都可以继承到。\n不过，子类无法继承父类的构造方法。如果父类的构造方法是带有参数的，代码如下所示：\n```\npublic class Wanger {\n    int age;\n    String name;\n\n    public Wanger(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n}\n```\n则必须在子类的构造器中显式地通过 super 关键字进行调用，否则编译器将提示以下错误：\n![](https://www.qyihe.xyz/images/post/10.40.jpg)\n修复后的代码如下所示：\n```\npublic class Wangxiaoer extends Wanger{\n    public Wangxiaoer(int age, String name) {\n        super(age, name);\n    }\n}\n```\nis-a 是继承的一个明显特征，就是说子类的对象引用类型可以是一个父类类型。\n```\npublic class Wangxiaoer extends Wanger{\n    public static void main(String[] args) {\n        Wanger wangxiaoer = new Wangxiaoer();\n    }\n}\n```\n同理，子接口的实现类的对象引用类型也可以是一个父接口类型。\n```\npublic interface OneInterface extends Cloneable {\n}\npublic class TestInterface implements OneInterface {\n    public static void main(String[] args) {\n        Cloneable c1 = new TestInterface();\n    }\n}\n```\n尽管一个类只能继承一个类，但一个类却可以实现多个接口，这一点，我在上一篇文章也提到过了。另外，还有一点我也提到了，就是 Java 8 之后，接口中可以定义 default 方法，这很方便，但也带来了新的问题：\n\n> 如果一个类实现了多个接口，而这些接口中定义了相同签名的 default 方法，那么这个类就要重写该方法，否则编译无法通过。\n\nFlyInterface 是一个会飞的接口，里面有一个签名为 sleep() 的默认方法：\n```\npublic interface FlyInterface {\n    void fly();\n    default void sleep() {\n        System.out.println(\"睡着飞\");\n    }\n}\n```\nRunInterface 是一个会跑的接口，里面也有一个签名为 sleep() 的默认方法：\n```\npublic interface RunInterface {\n    void run();\n    default void sleep() {\n        System.out.println(\"睡着跑\");\n    }\n}\n```\nPig 类实现了 FlyInterface 和 RunInterface 两个接口，但这时候编译出错了。\n![](https://www.qyihe.xyz/images/post/10.41.jpg)\n原本，default 方法就是为实现该接口而不覆盖该方法的类提供默认实现的，现在，相同方法签名的 sleep() 方法把编译器搞懵逼了，只能重写了。\n```\npublic class Pig implements FlyInterface, RunInterface {\n\n    @Override\n    public void fly() {\n        System.out.println(\"会飞的猪\");\n    }\n\n    @Override\n    public void sleep() {\n        System.out.println(\"只能重写了\");\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"会跑的猪\");\n    }\n}\n```\n类虽然不能继承多个类，但接口却可以继承多个接口，这一点，我不知道有没有触及到一些读者的知识盲区。\n```\npublic interface WalkInterface extends FlyInterface,RunInterface{\n    void walk();\n}\n```\n# 十二、this 关键字\n在 Java 中，this 关键字指的是当前对象（它的方法正在被调用）的引用，能理解吧，各位亲？不理解的话，我们继续往下看。\n看完再不明白，你过来捶爆我，我保证不还手，只要不打脸。\n## 01、消除字段歧义\n我敢赌一毛钱，所有的读者，不管男女老少，应该都知道这种用法，毕竟写构造方法的时候经常用啊。谁要不知道，过来，我给你发一毛钱红包，只要你脸皮够厚。\n```\npublic class Writer {\n    private int age;\n    private String name;\n\n    public Writer(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n}\n```\nWriter 类有两个成员变量，分别是 age 和 name，在使用有参构造函数的时候，如果参数名和成员变量的名字相同，就需要使用 this 关键字消除歧义：this.age 是指成员变量，age 是指构造方法的参数。\n## 02、引用类的其他构造方法\n当一个类的构造方法有多个，并且它们之间有交集的话，就可以使用 this 关键字来调用不同的构造方法，从而减少代码量。\n比如说，在无参构造方法中调用有参构造方法：\n```\npublic class Writer {\n    private int age;\n    private String name;\n\n    public Writer(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    public Writer() {\n        this(18, \"沉默王二\");\n    }\n}\n```\n也可以在有参构造方法中调用无参构造方法：\n```\npublic class Writer {\n    private int age;\n    private String name;\n\n    public Writer(int age, String name) {\n        this();\n        this.age = age;\n        this.name = name;\n    }\n\n    public Writer() {\n    }\n}\n```\n需要注意的是，this() 必须是构造方法中的第一条语句，否则就会报错。\n![](https://www.qyihe.xyz/images/post/10.42.jpg)\n## 03、作为参数传递\n在下例中，有一个无参的构造方法，里面调用了 print() 方法，参数只有一个 this 关键字。\n```\npublic class ThisTest {\n    public ThisTest() {\n        print(this);\n    }\n\n    private void print(ThisTest thisTest) {\n        System.out.println(\"print \" +thisTest);\n    }\n\n    public static void main(String[] args) {\n        ThisTest test = new ThisTest();\n        System.out.println(\"main \" + test);\n    }\n}\n```\n来打印看一下结果：\n```\nprint com.cmower.baeldung.this1.ThisTest@573fd745\nmain com.cmower.baeldung.this1.ThisTest@573fd745\n```\n从结果中可以看得出来，this 就是我们在 main() 方法中使用 new 关键字创建的 ThisTest 对象。\n## 04、链式调用\n学过 JavaScript，或者 jQuery 的读者可能对链式调用比较熟悉，类似于 a.b().c().d()，仿佛能无穷无尽调用下去。\n在 Java 中，对应的专有名词叫 Builder 模式，来看一个示例。\n```\npublic class Writer {\n    private int age;\n    private String name;\n    private String bookName;\n    \n    public Writer(WriterBuilder builder) {\n        this.age = builder.age;\n        this.name = builder.name;\n        this.bookName = builder.bookName;\n    }\n\n    public static class WriterBuilder {\n        public String bookName;\n        private int age;\n        private String name;\n\n        public WriterBuilder(int age, String name) {\n            this.age = age;\n            this.name = name;\n        }\n\n        public WriterBuilder writeBook(String bookName) {\n            this.bookName = bookName;\n            return this;\n        }\n\n        public Writer build() {\n            return new Writer(this);\n        }\n    }\n}\n```\nWriter 类有三个成员变量，分别是 age、name 和 bookName，还有它们仨对应的一个构造方法，参数是一个内部静态类 WriterBuilder。\n内部类 WriterBuilder 也有三个成员变量，和 Writer 类一致，不同的是，WriterBuilder 类的构造方法里面只有 age 和 name 赋值了，另外一个成员变量 bookName 通过单独的方法 writeBook() 来赋值，注意，该方法的返回类型是 WriterBuilder，最后使用 return 返回了 this 关键字。\n最后的 build() 方法用来创建一个 Writer 对象，参数为 this 关键字，也就是当前的 WriterBuilder 对象。\n这时候，创建 Writer 对象就可以通过链式调用的方式。\n```\nWriter writer = new Writer.WriterBuilder(18,\"沉默王二\")\n                .writeBook(\"《Web全栈开发进阶之路》\")\n                .build();\n```\n## 05、在内部类中访问外部类对象\n说实话，自从 Java 8 的函数式编程出现后，就很少用到 this 在内部类中访问外部类对象了。来看一个示例：\n```\npublic class ThisInnerTest {\n    private String name;\n    \n    class InnerClass {\n        public InnerClass() {\n            ThisInnerTest thisInnerTest = ThisInnerTest.this;\n            String outerName = thisInnerTest.name;\n        }\n    }\n}\n```\n在内部类 InnerClass 的构造方法中，通过外部类.this 可以获取到外部类对象，然后就可以使用外部类的成员变量了，比如说 name。\n# 十三、super 关键字\n简而言之，super 关键字就是用来访问父类的。\n先来看父类：\n```\npublic class SuperBase {\n    String message = \"父类\";\n\n    public SuperBase(String message) {\n        this.message = message;\n    }\n\n    public SuperBase() {\n    }\n\n    public void printMessage() {\n        System.out.println(message);\n    }\n}\n```\n再来看子类：\n```\npublic class SuperSub extends SuperBase {\n    String message = \"子类\";\n\n    public SuperSub(String message) {\n        super(message);\n    }\n\n    public SuperSub() {\n        super.printMessage();\n        printMessage();\n    }\n\n    public void getParentMessage() {\n        System.out.println(super.message);\n    }\n\n    public void printMessage() {\n        System.out.println(message);\n    }\n}\n```\n（1）super 关键字可用于访问父类的构造方法\n你看，子类可以通过 super(message) 来调用父类的构造方法。现在来新建一个 SuperSub 对象，看看输出结果是什么：\n```\nSuperSub superSub = new SuperSub(\"子类的message\");\n```\nnew 关键字在调用构造方法创建子类对象的时候，会通过 super 关键字初始化父类的 message，所以此此时父类的 message 会输出“子类的message”。\n（2）super 关键字可以访问父类的变量\n上述例子中的 SuperSub 类中就有，getParentMessage() 通过 super.message 方法父类的同名成员变量 message。\n（3）当方法发生重写时，super 关键字可以访问父类的同名方法\n上述例子中的 SuperSub 类中就有，无参的构造方法 SuperSub() 中就使用 super.printMessage() 调用了父类的同名方法。\n# 十四、重写和重载\n先来看一段重写的代码吧。\n```\nclass LaoWang{\n    public void write() {\n        System.out.println(\"老王写了一本《基督山伯爵》\");\n    }\n}\npublic class XiaoWang extends LaoWang {\n    @Override\n    public void write() {\n        System.out.println(\"小王写了一本《茶花女》\");\n    }\n}\n```\n重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。就好像父类 LaoWang 有一个 write() 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 write() 方法（无参），但方法体是写一本《茶花女》。\n来写一段测试代码。\n```\npublic class OverridingTest {\n    public static void main(String[] args) {\n        LaoWang wang = new XiaoWang();\n        wang.write();\n    }\n}\n```\n大家猜结果是什么？\n```\n小王写了一本《茶花女》\n```\n在上面的代码中，们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 write() 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 write() 方法而不是父类 LaoWang  中的 write() 方法，因此输出结果为“小王写了一本《茶花女》”。\n再来看一段重载的代码吧。\n```\nclass LaoWang{\n    public void read() {\n        System.out.println(\"老王读了一本《Web全栈开发进阶之路》\");\n    }\n    \n    public void read(String bookname) {\n        System.out.println(\"老王读了一本《\" + bookname + \"》\");\n    }\n}\n```\n重载的两个方法名相同，但方法参数的个数不同，另外也不涉及到继承，两个方法在同一个类中。就好像类 LaoWang 有两个方法，名字都是 read()，但一个有参数（书名），另外一个没有（只能读写死的一本书）。\n来写一段测试代码。\n```\npublic class OverloadingTest {\n    public static void main(String[] args) {\n        LaoWang wang = new LaoWang();\n        wang.read();\n        wang.read(\"金瓶梅\");\n    }\n}\n```\n这结果就不用猜了。变量 wang 的类型为 LaoWang，wang.read() 调用的是无参的 read() 方法，因此先输出“老王读了一本《Web全栈开发进阶之路》”；wang.read(\"金瓶梅\") 调用的是有参的 read(bookname) 方法，因此后输出“老王读了一本《金瓶梅》”。在编译期间，编译器就知道这两个 read() 方法时不同的，因为它们的方法签名（=方法名称+方法参数）不同。\n简单的来总结一下：\n（1）编译器无法决定调用哪个重写的方法，因为只从变量的类型上是无法做出判断的，要在运行时才能决定；但编译器可以明确地知道该调用哪个重载的方法，因为引用类型是确定的，参数个数决定了该调用哪个方法。\n（2）多态针对的是重写，而不是重载。\n![](https://www.qyihe.xyz/images/post/10.43.jpg)\n哎，后悔啊，早年我要是能把这道面试题吃透的话，也不用被老马刁难了。吟一首诗感慨一下人生吧。\n\n>青青园中葵，朝露待日晞。\n>阳春布德泽，万物生光辉。\n>常恐秋节至，焜黄华叶衰。\n>百川东到海，何时复西归?\n>少壮不努力，老大徒伤悲\n\n另外，我想要告诉大家的是，重写（Override）和重载（Overload）是 Java 中两个非常重要的概念，新手经常会被它们俩迷惑，因为它们俩的英文名字太像了，中文翻译也只差一个字。难，太难了。\n![](https://www.qyihe.xyz/images/post/10.44.jpg)\n# 十五、static 关键字\n先来个提纲挈领（唉呀妈呀，成语区博主上线了）吧：\n\n>static 关键字可用于变量、方法、代码块和内部类，表示某个特定的成员只属于某个类本身，而不是该类的某个对象。\n\n## 01、静态变量\n静态变量也叫类变量，它属于一个类，而不是这个类的对象。\n```\npublic class Writer {\n    private String name;\n    private int age;\n    public static int countOfWriters;\n\n    public Writer(String name, int age) {\n        this.name = name;\n        this.age = age;\n        countOfWriters++;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n其中，countOfWriters 被称为静态变量，它有别于 name 和 age 这两个成员变量，因为它前面多了一个修饰符 static。\n这意味着无论这个类被初始化多少次，静态变量的值都会在所有类的对象中共享。\n```\nWriter w1 = new Writer(\"沉默王二\",18);\nWriter w2 = new Writer(\"沉默王三\",16);\n\nSystem.out.println(Writer.countOfWriters);\n```\n按照上面的逻辑，你应该能推理得出，countOfWriters 的值此时应该为 2 而不是 1。从内存的角度来看，静态变量将会存储在 Java 虚拟机中一个名叫“Metaspace”（元空间，Java 8 之后）的特定池中。\n静态变量和成员变量有着很大的不同，成员变量的值属于某个对象，不同的对象之间，值是不共享的；但静态变量不是的，它可以用来统计对象的数量，因为它是共享的。就像上面例子中的 countOfWriters，创建一个对象的时候，它的值为 1，创建两个对象的时候，它的值就为 2。\n简单小结一下：\n（1）由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问；\n![](https://www.qyihe.xyz/images/post/10.45.jpg)\n（2）不需要初始化类就可以访问静态变量。\n```\npublic class WriterDemo {\n    public static void main(String[] args) {\n        System.out.println(Writer.countOfWriters); // 输出 0\n    }\n}\n```\n## 02、静态方法\n静态方法也叫类方法，它和静态变量类似，属于一个类，而不是这个类的对象。\n```\npublic static void setCountOfWriters(int countOfWriters) {\n    Writer.countOfWriters = countOfWriters;\n}\n```\nsetCountOfWriters() 就是一个静态方法，它由 static 关键字修饰。\n如果你用过 java.lang.Math 类或者 Apache 的一些工具类（比如说 StringUtils）的话，对静态方法一定不会感动陌生。\n![](https://www.qyihe.xyz/images/post/10.46.jpg)\nMath 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。\n![](https://www.qyihe.xyz/images/post/10.47.jpg)\n简单小结一下：\n（1）Java 中的静态方法在编译时解析，因为静态方法不能被重写（方法重写发生在运行时阶段，为了多态）。\n（2）抽象方法不能是静态的。\n![](https://www.qyihe.xyz/images/post/10.48.jpg)\n（3）静态方法不能使用 this 和 super 关键字。\n（4）成员方法可以直接访问其他成员方法和成员变量。\n（5）成员方法也可以直接方法静态方法和静态变量。\n（6）静态方法可以访问所有其他静态方法和静态变量。\n（7）静态方法无法直接访问成员方法和成员变量。\n![](https://www.qyihe.xyz/images/post/10.49.jpg)\n## 03、静态代码块\n静态代码块可以用来初始化静态变量，尽管静态方法也可以在声明的时候直接初始化，但有些时候，我们需要多行代码来完成初始化。\n```\npublic class StaticBlockDemo {\n    public static List<String> writes = new ArrayList<>();\n\n    static {\n        writes.add(\"沉默王二\");\n        writes.add(\"沉默王三\");\n        writes.add(\"沉默王四\");\n\n        System.out.println(\"第一块\");\n    }\n\n    static {\n        writes.add(\"沉默王五\");\n        writes.add(\"沉默王六\");\n\n        System.out.println(\"第二块\");\n    }\n}\n```\nwrites 是一个静态的 ArrayList，所以不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初始化。\n简单小结一下：\n（1）一个类可以有多个静态代码块。\n（2）静态代码块的解析和执行顺序和它在类中的位置保持一致。为了验证这个结论，可以在 StaticBlockDemo 类中加入空的 main 方法，执行完的结果如下所示：\n```\n第一块\n第二块\n```\n## 04、静态内部类\nJava 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。\n常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我们本次文章的讨论范围，以后有机会再细说。\n```\npublic class Singleton {\n    private Singleton() {}\n\n    private static class SingletonHolder {\n        public static final Singleton instance = new Singleton();\n    }\n\n    public static Singleton getInstance() {\n        return SingletonHolder.instance;\n    }\n}\n```\n以上这段代码是不是特别熟悉，对，这就是创建单例的一种方式，第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全也能保证 Singleton 类的唯一性。不过，创建单例更优雅的一种方式是使用枚举。\n简单小结一下：\n（1）静态内部类不能访问外部类的所有成员变量。\n（2）静态内部类可以访问外部类的所有静态变量，包括私有静态变量。\n（3）外部类不能声明为 static。\n![](https://www.qyihe.xyz/images/post/10.50.jpg)\n# 十六、Java 枚举\n开门见山地说吧，enum（枚举）是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，默认继承自 java.lang.Enum。\n为了证明这一点，我们来新建一个枚举 PlayerType：\n```\npublic enum PlayerType {\n    TENNIS,\n    FOOTBALL,\n    BASKETBALL\n}\n```\n两个关键字带一个类名，还有大括号，以及三个大写的单词，但没看到继承 Enum 类啊？别着急，心急吃不了热豆腐啊。使用 JAD 查看一下反编译后的字节码，就一清二楚了。\n```\npublic final class PlayerType extends Enum\n{\n\n    public static PlayerType[] values()\n    {\n        return (PlayerType[])$VALUES.clone();\n    }\n\n    public static PlayerType valueOf(String name)\n    {\n        return (PlayerType)Enum.valueOf(com/cmower/baeldung/enum1/PlayerType, name);\n    }\n\n    private PlayerType(String s, int i)\n    {\n        super(s, i);\n    }\n\n    public static final PlayerType TENNIS;\n    public static final PlayerType FOOTBALL;\n    public static final PlayerType BASKETBALL;\n    private static final PlayerType $VALUES[];\n\n    static \n    {\n        TENNIS = new PlayerType(\"TENNIS\", 0);\n        FOOTBALL = new PlayerType(\"FOOTBALL\", 1);\n        BASKETBALL = new PlayerType(\"BASKETBALL\", 2);\n        $VALUES = (new PlayerType[] {\n            TENNIS, FOOTBALL, BASKETBALL\n        });\n    }\n}\n```\n看到没？PlayerType 类是 final 的，并且继承自 Enum 类。这些工作我们程序员没做，编译器帮我们悄悄地做了。此外，它还附带几个有用静态方法，比如说 values() 和  valueOf(String name)。\n## 01、内部枚举\n好的，小伙伴们应该已经清楚枚举长什么样子了吧？既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。\n```\npublic class Player {\n    private PlayerType type;\n    public enum PlayerType {\n        TENNIS,\n        FOOTBALL,\n        BASKETBALL\n    }\n    \n    public boolean isBasketballPlayer() {\n      return getType() == PlayerType.BASKETBALL;\n    }\n\n    public PlayerType getType() {\n        return type;\n    }\n\n    public void setType(PlayerType type) {\n        this.type = type;\n    }\n}\n```\nPlayerType 就相当于 Player 的内部类，isBasketballPlayer() 方法用来判断运动员是否是一个篮球运动员。\n由于枚举是 final 的，可以确保在 Java 虚拟机中仅有一个常量对象（可以参照反编译后的静态代码块「static 关键字带大括号的那部分代码」），所以我们可以很安全地使用“==”运算符来比较两个枚举是否相等，参照 isBasketballPlayer() 方法。\n那为什么不使用 equals() 方法判断呢？\n```\nif(player.getType().equals(Player.PlayerType.BASKETBALL)){};\nif(player.getType() == Player.PlayerType.BASKETBALL){};\n```\n“==”运算符比较的时候，如果两个对象都为 null，并不会发生 NullPointerException，而 equals() 方法则会。\n另外， “==”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而 equals() 方法则不会。\n![](https://www.qyihe.xyz/images/post/10.51.jpg)\n## 02、枚举可用于 switch 语句\n这个我在之前的一篇我去的文章中详细地说明过了，感兴趣的小伙伴可以点击链接跳转过去看一下。\n```\nswitch (playerType) {\n        case TENNIS:\n            return \"网球运动员费德勒\";\n        case FOOTBALL:\n            return \"足球运动员C罗\";\n        case BASKETBALL:\n            return \"篮球运动员詹姆斯\";\n        case UNKNOWN:\n            throw new IllegalArgumentException(\"未知\");\n        default:\n            throw new IllegalArgumentException(\n                    \"运动员类型: \" + playerType);\n\n}\n```\n## 03、枚举可以有构造方法\n如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。\n```\npublic enum PlayerType {\n    TENNIS(\"网球\"),\n    FOOTBALL(\"足球\"),\n    BASKETBALL(\"篮球\");\n\n    private String name;\n\n    PlayerType(String name) {\n        this.name = name;\n    }\n}\n```\n## 04、EnumSet\nEnumSet 是一个专门针对枚举类型的 Set 接口的实现类，它是处理枚举类型数据的一把利器，非常高效（内部实现是位向量，我也搞不懂）。\n因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法：\n![](https://www.qyihe.xyz/images/post/10.52.jpg)\n下面的示例中使用 noneOf() 创建了一个空的 PlayerType 的 EnumSet；使用 allOf() 创建了一个包含所有 PlayerType 的 EnumSet。\n```\npublic class EnumSetTest {\n    public enum PlayerType {\n        TENNIS,\n        FOOTBALL,\n        BASKETBALL\n    }\n\n    public static void main(String[] args) {\n        EnumSet<PlayerType> enumSetNone = EnumSet.noneOf(PlayerType.class);\n        System.out.println(enumSetNone);\n\n        EnumSet<PlayerType> enumSetAll = EnumSet.allOf(PlayerType.class);\n        System.out.println(enumSetAll);\n    }\n}\n```\n程序输出结果如下所示：\n```\n[]\n[TENNIS, FOOTBALL, BASKETBALL]\n```\n有了 EnumSet 后，就可以使用 Set 的一些方法了：\n![](https://www.qyihe.xyz/images/post/10.53.jpg)\n## 05、EnumMap\nEnumMap 是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。\n和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字：\n```\nEnumMap<PlayerType, String> enumMap = new EnumMap<>(PlayerType.class);\n```\n有了 EnumMap 对象后就可以使用 Map 的一些方法了：\n![](https://www.qyihe.xyz/images/post/10.54.jpg)\n和 HashMap 的使用方法大致相同，来看下面的例子：\n```\nEnumMap<PlayerType, String> enumMap = new EnumMap<>(PlayerType.class);\nenumMap.put(PlayerType.BASKETBALL,\"篮球运动员\");\nenumMap.put(PlayerType.FOOTBALL,\"足球运动员\");\nenumMap.put(PlayerType.TENNIS,\"网球运动员\");\nSystem.out.println(enumMap);\n\nSystem.out.println(enumMap.get(PlayerType.BASKETBALL));\nSystem.out.println(enumMap.containsKey(PlayerType.BASKETBALL));\nSystem.out.println(enumMap.remove(PlayerType.BASKETBALL));\n```\n程序输出结果如下所示：\n```\n{TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员}\n篮球运动员\ntrue\n篮球运动员\n```\n## 06、单例\n通常情况下，实现一个单例并非易事，不信，来看下面这段代码\n```\npublic class Singleton {  \n    private volatile static Singleton singleton; \n    private Singleton (){}  \n    public static Singleton getSingleton() {  \n    if (singleton == null) {\n        synchronized (Singleton.class) { \n        if (singleton == null) {  \n            singleton = new Singleton(); \n        }  \n        }  \n    }  \n    return singleton;  \n    }  \n}\n```\n但枚举的出现，让代码量减少到极致：\n```\npublic enum EasySingleton{\n    INSTANCE;\n}\n```\n完事了，真的超级短，有没有？枚举默认实现了 Serializable 接口，因此 Java 虚拟机可以保证该类为单例，这与传统的实现方式不大相同。传统方式中，我们必须确保单例在反序列化期间不能创建任何新实例。\n## 07、枚举可与数据库交互\n我们可以配合 Mybatis 将数据库字段转换为枚举类型。现在假设有一个数据库字段 check_type 的类型如下：\n```\n`check_type` int(1) DEFAULT NULL COMMENT '检查类型（1：未通过、2：通过）',\n```\n它对应的枚举类型为 CheckType，代码如下：\n```\npublic enum CheckType {\n\tNO_PASS(0, \"未通过\"), PASS(1, \"通过\");\n\tprivate int key;\n\n\tprivate String text;\n\n\tprivate CheckType(int key, String text) {\n\t\tthis.key = key;\n\t\tthis.text = text;\n\t}\n\n\tpublic int getKey() {\n\t\treturn key;\n\t}\n\n\tpublic String getText() {\n\t\treturn text;\n\t}\n\n\tprivate static HashMap<Integer,CheckType> map = new HashMap<Integer,CheckType>();\n\tstatic {\n\t\tfor(CheckType d : CheckType.values()){\n\t\t\tmap.put(d.key, d);\n\t\t}\n\t}\n\t\n\tpublic static CheckType parse(Integer index) {\n\t\tif(map.containsKey(index)){\n\t\t\treturn map.get(index);\n\t\t}\n\t\treturn null;\n\t}\n}\n```\n（1）CheckType 添加了构造方法，还有两个字段，key 为 int 型，text 为 String 型。\n（2）CheckType 中有一个public static CheckType parse(Integer index)方法，可将一个 Integer 通过 key 的匹配转化为枚举类型。\n那么现在，我们可以在 Mybatis 的配置文件中使用 typeHandler 将数据库字段转化为枚举类型。\n```\n<resultMap id=\"CheckLog\" type=\"com.entity.CheckLog\">\n  <id property=\"id\" column=\"id\"/>\n  <result property=\"checkType\" column=\"check_type\" typeHandler=\"com.CheckTypeHandler\"></result>\n</resultMap>\n```\n其中 checkType 字段对应的类如下：\n```\npublic class CheckLog implements Serializable {\n\n    private String id;\n    private CheckType checkType;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public CheckType getCheckType() {\n        return checkType;\n    }\n\n    public void setCheckType(CheckType checkType) {\n        this.checkType = checkType;\n    }\n}\n```\nCheckTypeHandler 转换器的类源码如下：\n```\npublic class CheckTypeHandler extends BaseTypeHandler<CheckType> {\n\n\t@Override\n\tpublic CheckType getNullableResult(ResultSet rs, String index) throws SQLException {\n\t\treturn CheckType.parse(rs.getInt(index));\n\t}\n\n\t@Override\n\tpublic CheckType getNullableResult(ResultSet rs, int index) throws SQLException {\n\t\treturn CheckType.parse(rs.getInt(index));\n\t}\n\n\t@Override\n\tpublic CheckType getNullableResult(CallableStatement cs, int index) throws SQLException {\n\t\treturn CheckType.parse(cs.getInt(index));\n\t}\n\n\t@Override\n\tpublic void setNonNullParameter(PreparedStatement ps, int index, CheckType val, JdbcType arg3) throws SQLException {\n\t\tps.setInt(index, val.getKey());\n\t}\n}\n```\nCheckTypeHandler 的核心功能就是调用 CheckType 枚举类的 parse() 方法对数据库字段进行转换。\n![](https://www.qyihe.xyz/images/post/10.55.jpg)\n恕我直言，我觉得小伙伴们肯定会用 Java 枚举了，如果还不会，就过来砍我！\n# 十七、final 关键字\n尽管继承可以让我们重用现有代码，但有时处于某些原因，我们确实需要对可扩展性进行限制，final 关键字可以帮助我们做到这一点。\n## 01、final 类\n如果一个类使用了 final 关键字修饰，那么它就无法被继承。如果小伙伴们细心观察的话，Java 就有不少 final 类，比如说最常见的 String 类。\n```\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence,\n               Constable, ConstantDesc {}\n```\n为什么 String 类要设计成 final 的呢？原因大致有以下三个：\n\n- 为了实现字符串常量池\n- 为了线程安全\n- 为了 HashCode 的不可变性\n\n更详细的原因，可以查看我之前写的一篇文章。\n任何尝试从 final 类继承的行为将会引发编译错误，为了验证这一点，我们来看下面这个例子，Writer 类是 final 的。\n```\npublic final class Writer {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n尝试去继承它，编译器会提示以下错误，Writer 类是 final 的，无法继承。\n![](https://www.qyihe.xyz/images/post/10.56.jpg)\n不过，类是 final 的，并不意味着该类的对象是不可变的。\n```\nWriter writer = new Writer();\nwriter.setName(\"沉默王二\");\nSystem.out.println(writer.getName()); // 沉默王二\n```\nWriter 的 name 字段的默认值是 null，但可以通过 settter 方法将其更改为“沉默王二”。也就是说，如果一个类只是 final 的，那么它并不是不可变的全部条件。\n如果，你想了解不可变类的全部真相，请查看我之前写的文章这次要说不明白immutable类，我就怎么地。突然发现，写系列文章真的妙啊，很多相关性的概念全部涉及到了。我真服了自己了。\n把一个类设计成 final 的，有其安全方面的考虑，但不应该故意为之，因为把一个类定义成 final 的，意味着它没办法继承，假如这个类的一些方法存在一些问题的话，我们就无法通过重写的方式去修复它。\n![](https://www.qyihe.xyz/images/post/10.57.jpg)\n## 02、final 方法\n被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它设计成 final 的。\nThread 类就是一个例子，它本身不是 final 的，这意味着我们可以扩展它，但它的 isAlive() 方法是 final 的：\n```\npublic class Thread implements Runnable {\n    public final native boolean isAlive();\n}\n```\n需要注意的是，该方法是一个本地（native）方法，用于确认线程是否处于活跃状态。而本地方法是由操作系统决定的，因此重写该方法并不容易实现。\nActor 类有一个 final 方法 show()：\n```\npublic class Actor {\n    public final void show() {\n        \n    }\n}\n```\n当我们想要重写该方法的话，就会出现编译错误：\n![](https://www.qyihe.xyz/images/post/10.58.jpg)\n如果一个类中的某些方法要被其他方法调用，则应考虑事被调用的方法称为 final 方法，否则，重写该方法会影响到调用方法的使用。\n一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？\n我能想到的一点，就是前者不能被继承，也就是说方法无法被重写；后者呢，可以被继承，然后追加一些非 final 的方法。没毛病吧？看把我聪明的。\n![](https://www.qyihe.xyz/images/post/10.59.jpg)\n## 03、final 变量\n被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。之前被一个小伙伴问过，什么是 effective final，什么是 final，这一点，我在之前的文章也有阐述过，所以这里再贴一下地址：\n```\nwww.itwanger.com/java/2020/0…\n```\n（1）final 修饰的基本数据类型\n来声明一个 final 修饰的 int 类型的变量：\n```\nfinal int age = 18;\n```\n尝试将它修改为 30，结果编译器生气了：\n![](https://www.qyihe.xyz/images/post/10.60.jpg)\n（2）final 修饰的引用类型\n现在有一个普通的类 Pig，它有一个字段 name：\n```\npublic class Pig {\n   private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n在测试类中声明一个 final 修饰的 Pig 对象：\n final Pig pig = new Pig();\n如果尝试将 pig 重新赋值的话，编译器同样会生气：\n![](https://www.qyihe.xyz/images/post/10.61.jpg)\n但我们仍然可以去修改 Pig 的字段值：\n```\nfinal Pig pig = new Pig();\npig.setName(\"特立独行\");\nSystem.out.println(pig.getName()); // 特立独行\n```\n（3）final 修饰的字段\nfinal 修饰的字段可以分为两种，一种是 static 的，另外一种是没有 static 的，就像下面这样：\n```\npublic class Pig {\n   private final int age = 1;\n   public static final double PRICE = 36.5;\n}\n```\n非 static 的 final 字段必须有一个默认值，否则编译器将会提醒没有初始化：\n![](https://www.qyihe.xyz/images/post/10.62.jpg)\nstatic 的 final 字段也叫常量，它的名字应该为大写，可以在声明的时候初始化，也可以通过 static 代码块初始化。\n\n(4) final 修饰的参数\n\nfinal 关键字还可以修饰参数，它意味着参数在方法体内不能被再修改：\n```\npublic class ArgFinalTest {\n    public void arg(final int age) {\n    }\n\n    public void arg1(final String name) {\n    }\n}\n```\n如果尝试去修改它的话，编译器会提示以下错误：\n![](https://www.qyihe.xyz/images/post/10.63.jpg)\n。。。。。。\n\n> \n>转载于[沉默王二](https://juejin.im/post/5ee414c76fb9a047dd2768ea#heading-39)\n> ","source":"_posts/10.md","raw":"---\ntitle: java入门阶级,每个 Java 初学者都应该收藏\nabbrlink: 53415\ndate: 2020-07-13 21:02:27\ncategories: 技术\ntags:\n\t- java\n\t- 基础\ndescription: Java 基础和 Java 面向对象编程\ncover: '/img/java.webp'\n---\n\n这么说吧，在我眼里，Java 就是最流行的编程语言，没有之一（PHP 往一边站）。不仅岗位多，容易找到工作，关键是薪资水平也到位，不学 Java 亏得慌，对吧？\n那可能零基础学编程的小伙伴就会头疼了，网上关于 Java 的大部分技术文章都不够幽默，不够风趣，不够系列，急需要一份能看得进去的学习手册，那我觉得我肝的这份手册正好符合要求，并且会一直持续更新下去。\n第一版的内容暂时包含两方面，Java 基础和 Java 面向对象编程。来吧，先上目录，一睹为快。\n01、Java 基本语法简介\n02、Java 基本数据类型简介\n03、Java main() 方法简介\n04、Java 的流程控制语句\n05、Java 包的简介\n06、Java 到底是值传递还是引用传递\n07、Java 的类和对象\n08、Java 构造方法\n09、Java 抽象类\n10、Java 接口\n11、Java 继承\n12、this 关键字\n13、super 关键字\n14、重写和重载\n15、static 关键字\n16、Java 枚举\n17、final 关键字\n目录欣赏完了，接下来就是拜读精华内容的时间，搬个小板凳，认认真真好好学吧，学到就是赚到！\n\n\n# 一、Java 基本语法简介\n## 01、数据类型\nJava 有 2 种数据类型，一种是基本数据类型，一种是引用类型。\n基本数据类型用于存储简单类型的数据，比如说，int、long、byte、short 用于存储整数，float、double 用于存储浮点数，char 用于存储字符，boolean 用于存储布尔值。\n不同的基本数据类型，有不同的默认值和大小，来个表格感受下。\n\n\n数据类型|默认值|大小\n-- | --|--\nboolean |false|1比特\nchar|0|2字节\nbyte|0|1字节\nshort|0|2字节\nint|0|4字节\nlong|0L|8字节\nfloat|0.0f|4字节\ndouble|0.0 |8字节\n\n引用类型用于存储对象（null 表示没有值的对象）的引用，String 是引用类型的最佳代表，比如说 String cmower = \"沉默王二\"。\n\n## 02、声明变量\n要声明一个变量，必须指定它的名字和类型，来看一个简单的示例：\n```\nint age;\nString name;\n```\ncount 和 name 在声明后会得到一个默认值，按照它们的数据类型——不能是局部变量（否则 Java 编译器会在你使用变量的时候提醒要先赋值），必须是类成员变量。\n```\npublic class SyntaxLocalVariable {\n    int age;\n    String name;\n\n    public static void main(String[] args) {\n        SyntaxLocalVariable syntax = new SyntaxLocalVariable();\n        System.out.println(syntax.age); // 输出 0\n        System.out.println(syntax.name);  // 输出 null\n    }\n}\n```\n也可以在声明一个变量后使用“=”操作符进行赋值，就像下面这样：\n```\nint age = 18;\nString name = \"沉默王二\";\n```\n我们定义了 2 个变量，int 类型的 age 和 String 类型的 name，age 赋值 18，name 赋值为“沉默王二”。\n每行代码后面都跟了一个“;”，表示当前语句结束了。\n在 Java 中，变量最好遵守命名约定，这样能提高代码的可阅读性。\n\n- 以字母、下划线（_）或者美元符号（$）开头\n- 不能使用 Java 的保留字，比如说 int 不能作为变量名\n\n## 03、数组\n数组在 Java 中占据着重要的位置，它是很多集合类的底层实现。数组属于引用类型，它用来存储一系列指定类型的数据。\n声明数组的一般语法如下所示：\n```\ntype[] identiier = new type[length];\n```\ntype 可以是任意的基本数据类型或者引用类型。来看下面这个例子：\n```\npublic class ArraysDemo {\n    public static void main(String[] args) {\n        int [] nums = new int[10];\n        nums[0] = 18;\n        nums[1] = 19;\n        System.out.println(nums[0]);\n    }\n}\n```\n数组的索引从 0 开始，第一个元素的索引为 0，第二个元素的索引为 1。为什么要这样设计？感兴趣的话，你可以去探究一下。\n通过变量名[索引]的方式可以访问数组指定索引处的元素，赋值或者取值是一样的。\n\n## 04、关键字\n关键字属于保留字，在 Java 中具有特殊的含义，比如说 public、final、static、new 等等，它们不能用来作为变量名。为了便于你作为参照，我列举了 48 个常用的关键字，你可以瞅一瞅。\n\n1： abstract： abstract 关键字用于声明抽象类——可以有抽象和非抽象方法。\n\n2： boolean： boolean 关键字用于将变量声明为布尔值类型，它只有 true 和 false 两个值。\n\n3： break： break 关键字用于中断循环或 switch 语句。\n\n4： byte： byte 关键字用于声明一个可以容纳 8 个比特的变量。\n\n5： case： case 关键字用于在 switch 语句中标记条件的值。\n\n6： catch： catch 关键字用于捕获 try 语句中的异常。\n\n7： char： char 关键字用于声明一个可以容纳无符号 16 位比特的 Unicode 字符的变量。\n\n8： class： class 关键字用于声明一个类。\n\n9： continue： continue 关键字用于继续下一个循环。它可以在指定条件下跳过其余代码。\n\n10：default： default 关键字用于指定 switch 语句中除去 case 条件之外的默认代码块。\n\n11：do： do 关键字通常和 while 关键字配合使用，do 后紧跟循环体。\n\n12：double： double 关键字用于声明一个可以容纳 64 位浮点数的变量。\n\n13：else： else 关键字用于指示 if 语句中的备用分支。\n\n14：enum： enum（枚举）关键字用于定义一组固定的常量。\n\n15：extends： extends 关键字用于指示一个类是从另一个类或接口继承的。\n\n16：final： final 关键字用于指示该变量是不可更改的。\n\n17：finally： finally 关键字和 try-catch 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。\n\n18：float： float 关键字用于声明一个可以容纳 32 位浮点数的变量。\n\n19：for： for 关键字用于启动一个 for 循环，如果循环次数是固定的，建议使用 for 循环。\n\n20：if： if 关键字用于指定条件，如果条件为真，则执行对应代码。\n\n21：implements： implements 关键字用于实现接口。\n\n22：import： import 关键字用于导入对应的类或者接口。\n\n23：instanceof： instanceof 关键字用于判断对象是否属于某个类型（class）。\n\n24：int： int 关键字用于声明一个可以容纳 32 位带符号的整数变量。\n\n25：interface： interface 关键字用于声明接口——只能具有抽象方法。\n\n26：long： long 关键字用于声明一个可以容纳 64 位整数的变量。\n\n27：native： native 关键字用于指定一个方法是通过调用本机接口（非 Java）实现的。\n\n28：new： new 关键字用于创建一个新的对象。\n\n29：null： 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null。\n\n30：package： package 关键字用于声明类所在的包。\n\n31：private： private 关键字是一个访问修饰符，表示方法或变量只对当前类可见。\n\n32：protected： protected 关键字也是一个访问修饰符，表示方法或变量对同一包内的类和所有子类可见。\n\n33：public： public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。\n\n34：return： return 关键字用于在代码执行完成后返回（一个值）。\n\n35：short： short 关键字用于声明一个可以容纳 16 位整数的变量。\n\n36：static： static 关键字表示该变量或方法是静态变量或静态方法。\n\n37：strictfp：  strictfp 关键字并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。\n\n38：super： super 关键字可用于调用父类的方法或者变量。\n\n39：switch： switch 关键字通常用于三个（以上）的条件判断。\n\n40：synchronized： synchronized 关键字用于指定多线程代码中的同步方法、变量或者代码块。\n\n41：this： this 关键字可用于在方法或构造函数中引用当前对象。\n\n42：throw： throw 关键字主动抛出异常。\n\n43：throws： throws 关键字用于声明异常。\n\n44：transient： transient 关键字在序列化的使用用到，它修饰的字段不会被序列化。\n\n45：try： try 关键字用于包裹要捕获异常的代码块。\n\n46：void： void 关键字用于指定方法没有返回值。\n\n47：volatile： volatile 关键字保证了不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n\n48：while： 如果循环次数不固定，建议使用 while 循环。\n![](https://www.qyihe.xyz/images/post/10.1.jpg)\n## 05、操作符\n除去“=”赋值操作符，Java 中还有很多其他作用的操作符，我们来大致看一下。\n### ①、算术运算符\n\n-  +（加号）\n-  –（减号）\n-  *（乘号）\n-  /（除号）\n-  ％（取余）\n\n来看一个例子：\n```\npublic class ArithmeticOperator {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 5;\n        \n        System.out.println(a + b);//15  \n        System.out.println(a - b);//5  \n        System.out.println(a * b);//50  \n        System.out.println(a / b);//2  \n        System.out.println(a % b);//0  \n    }\n}\n```\n“+”号比较特殊，还可以用于字符串拼接，来看一个例子：\n```\nString result = \"沉默王二\" + \"一枚有趣的程序员\";\n```\n### ②、逻辑运算符\n逻辑运算符通常用于布尔表达式，常见的有：\n\n- &&（AND）多个条件中只要有一个为 false 结果就为 false\n- ||（OR）多个条件只要有一个为 true 结果就为 true\n- !（NOT）条件如果为 true，加上“!”就为 false，否则，反之。\n\n来看一个例子：\n```\npublic class LogicalOperator {\n    public static void main(String[] args) {\n        int a=10;\n        int b=5;\n        int c=20;\n        System.out.println(a<b&&a<c);//false\n        System.out.println(a>b||a<c);//true\n        System.out.println(!(a<b)); // true\n    }\n}\n```\n### ③、比较运算符\n\n-  < (小于)\n-  <= (小于或者等于)\n-  >(大于)\n-  >= (大于或者等于)\n-  == (相等)\n-  != (不等)\n\n## 06、程序结构\nJava 中最小的程序单元叫做类，一个类可以有一个或者多个字段（也叫作成员变量），还可以有一个或者多个方法，甚至还可以有一些内部类。\n如果一个类想要执行，就必须有一个 main 方法——程序运行的入口，就好像人的嘴一样，嗯，可以这么牵强的理解一下。\n```\npublic class StructureProgram {\n    public static void main(String[] args) {\n        System.out.println(\"没有成员变量，只有一个 main 方法\");\n    }\n}\n```\n- 类名叫做 StructureProgram，在它里面，只有一个 main 方法。\n- {} 之间的代码称之为代码块。\n- 以上源代码将会保存在一个后缀名为 java 的文件中。\n\n## 07、编译然后执行代码\n通常，一些教程在介绍这块内容的时候，建议你通过命令行中先执行 javac 命令将源代码编译成字节码文件，然后再执行 java 命令指定代码。\n但我不希望这个糟糕的局面再继续下去了——新手安装配置 JDK 真的蛮需要勇气和耐心的，稍有不慎，没入门就先放弃了。况且，在命令行中编译源代码会遇到很多莫名其妙的错误，这对新手是极其致命的——如果你再遇到这种老式的教程，可以吐口水了。\n好的方法，就是去下载 IntelliJ IDEA，简称 IDEA，它被业界公认为最好的 Java 集成开发工具，尤其在智能代码助手、代码自动提示、代码重构、代码版本管理(Git、SVN、Maven)、单元测试、代码分析等方面有着亮眼的发挥。IDEA 产于捷克（位于东欧），开发人员以严谨著称。IDEA 分为社区版和付费版两个版本，新手直接下载社区版就足够用了。\n安装成功后，可以开始敲代码了，然后直接右键运行（连保存都省了），结果会在 Run 面板中显示，如下图所示。\n![](https://www.qyihe.xyz/images/post/10.2.jpg)\n想查看反编译后的字节码的话，可以在 src 的同级目录 target/classes 的包路径下找到一个 StructureProgram.class 的文件（如果找不到的话，在目录上右键选择「Reload from Disk」）。\n可以双击打开它。\n```\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\npackage com.cmower.baeldung.basic;\n\npublic class StructureProgram {\n    public StructureProgram() {\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"没有成员变量，只有一个 main 方法\");\n    }\n}\n```\nIDEA 默认会用 Fernflower 将 class 字节码反编译为我们可以看得懂的 Java 代码。实际上，class 字节码（请安装 show bytecode 插件）长下面这个样子：\n```\n// class version 57.65535 (-65479)\n// access flags 0x21\npublic class com/cmower/baeldung/basic/StructureProgram {\n\n  // compiled from: StructureProgram.java\n\n  // access flags 0x1\n  public <init>()V\n   L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.<init> ()V\n    RETURN\n   L1\n    LOCALVARIABLE this Lcom/cmower/baeldung/basic/StructureProgram; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n  // access flags 0x9\n  public static main([Ljava/lang/String;)V\n   L0\n    LINENUMBER 5 L0\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"\\u6ca1\\u6709\\u6210\\u5458\\u53d8\\u91cf\\uff0c\\u53ea\\u6709\\u4e00\\u4e2a main \\u65b9\\u6cd5\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n   L1\n    LINENUMBER 6 L1\n    RETURN\n   L2\n    LOCALVARIABLE args [Ljava/lang/String; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n```\n新手看起来还是有些懵逼的，建议过过眼瘾就行了。\n![](https://www.qyihe.xyz/images/post/10.3.jpg)\n# 二、Java 基本数据类型简介\n## 01、布尔\n布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：\n```\nboolean flag = true;\n```\n## 02、byte\nbyte 的取值范围在 -128 和 127 之间，包含 127。最小值为 -128，最大值为 127，默认值为 0。\n在网络传输的过程中，为了节省空间，常用字节来作为数据的传输方式。代码示例：\n```\nbyte a = 10;\nbyte b = -10;\n```\n## 03、short\nshort 的取值范围在 -32,768 和 32,767 之间，包含 32,767。最小值为 -32,768，最大值为 32,767，默认值为 0。代码示例：\n```\nshort s = 10000;\nshort r = -5000;\n```\n## 04、int\nint 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间，默认值为 0。如果没有特殊需求，整形数据就用 int。代码示例：\n```\nint a = 100000;\nint b = -200000;\n```\n## 05、long\nlong 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间，默认值为 0。如果 int 存储不下，就用 long，整形数据就用 int。代码示例：\n```\nlong a = 100000L; \nlong b = -200000L;\n```\n为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。\n## 06、float\nfloat 是单精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围是无限的，默认值为 0.0f。float 不适合用于精确的数值，比如说货币。代码示例：\n```\nfloat f1 = 234.5f;\n```\n为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。\n## 07、double\ndouble 是双精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围也是无限的，默认值为 0.0。double 同样不适合用于精确的数值，比如说货币。代码示例：\n```\ndouble d1 = 12.3\n```\n那精确的数值用什么表示呢？最好使用 BigDecimal，它可以表示一个任意大小且精度完全准确的浮点数。针对货币类型的数值，也可以先乘以 100 转成整形进行处理。\nTips：单精度是这样的格式，1 位符号，8 位指数，23 位小数，有效位数为 7 位。\n![](https://www.qyihe.xyz/images/post/10.4.jpg)\n双精度是这样的格式，1 位符号，11 位指数，52 为小数，有效位数为 16 位。\n![](https://www.qyihe.xyz/images/post/10.5.jpg)\n取值范围取决于指数位，计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。\n\n>一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。\n\n## 08、char\nchar 可以表示一个 16 位的 Unicode 字符，其值范围在 '\\u0000'（0）和 '\\uffff'（65,535）（包含）之间。代码示例：\n```\nchar letterA = 'A'; // 用英文的单引号包裹住。\n```\n# 三、Java main() 方法简介\n每个程序都需要一个入口，对于 Java 程序来说，入口就是 main 方法。\n```\npublic static void main(String[] args) {\n\n}\n```\n- public、static、void 这 3 个关键字在前面的内容已·经介绍过了，如果觉得回去找比较麻烦的话，这里再贴一下：\n\n- public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。\n\n- static 关键字表示该变量或方法是静态变量或静态方法，可以直接通过类访问，不需要实例化对象来访问。\n\n- void 关键字用于指定方法没有返回值。\n\n另外，main 关键字为方法的名字，Java 虚拟机在执行程序时会寻找这个标识符；args 为 main() 方法的参数名，它的类型为一个 String 数组，也就是说，在使用 java 命令执行程序的时候，可以给 main() 方法传递字符串数组作为参数。\n```\njava HelloWorld 沉默王二 沉默王三\n```\njavac 命令用来编译程序，java 命令用来执行程序，HelloWorld 为这段程序的类名，沉默王二和沉默王三为字符串数组，中间通过空格隔开，然后就可以在 main() 方法中通过 args[0] 和 args[1] 获取传递的参数值了。\n```\npublic class HelloWorld {\n    public static void main(String[] args) {\n        if (\"沉默王二\".equals(args[0])) {\n            \n        }\n        \n        if (\"沉默王三\".equals(args[1])) {\n            \n        }\n    }\n}\n```\nmain() 方法的写法并不是唯一的，还有其他几种变体，尽管它们可能并不常见，可以简单来了解一下。\n\n第二种，把方括号 [] 往 args 靠近而不是 String 靠近：\n```\npublic static void main(String []args) { \n\n}\n```\n第三种，把方括号 [] 放在 args 的右侧：\n```\npublic static void main(String args[]) {\n\n}\n```\n第四种，还可以把数组形式换成可变参数的形式：\n```\npublic static void main(String...args) { \n\n}\n```\n第五种，在 main() 方法上添加另外一个修饰符 strictfp，用于强调在处理浮点数时的兼容性：\n```\npublic strictfp static void main(String[] args) { \n\n}\n```\n也可以在 main() 方法上添加 final 关键字或者 synchronized 关键字。\n\n第六种，还可以为 args 参数添加 final 关键字：\n```\npublic static void main(final String[] args) { \n\n}\n```\n第七种，最复杂的一种，所有可以添加的关键字统统添加上：\n```\nfinal static synchronized strictfp void main(final String[] args) { \n\n}\n```\n当然了，并不需要为了装逼特意把 main() 方法写成上面提到的这些形式，使用 IDE 提供的默认形式就可以了。\n# 四、Java 的流程控制语句\n- 在 Java 中，有三种类型的流程控制语句：\n\n- 条件分支，用于在两个或者多个条件之间做出选择，常见的有 if/else/else if、三元运算符和 switch 语句。\n\n- 循环或者遍历，常见的有 for、while 和 do-while。\n\n- break 和 continue，用于跳出循环或者跳过进入下一轮循环。\n\n## if 语句\nif 语句的格式如下：\n```\nif(布尔表达式){  \n// 如果条件为 true，则执行这块代码\n} \n```\n画个流程图表示一下：\n![](https://www.qyihe.xyz/images/post/10.6.jpg)\n来写个示例：\n```\npublic class IfExample {\n    public static void main(String[] args) {\n        int age = 20;\n        if (age < 30) {\n            System.out.println(\"青春年华\");\n        }\n    }\n}\n```\n输出：\n```\n青春年华\n```\n## if-else 语句\nif-else 语句的格式如下:\n```\nif(布尔表达式){  \n// 条件为 true 时执行的代码块\n}else{  \n// 条件为 false  时执行的代码块\n}  \n```\n画个流程图表示一下：\n![](https://www.qyihe.xyz/images/post/10.7.jpg)\n来写个示例：\n```\npublic class IfElseExample {\n    public static void main(String[] args) {\n        int age = 31;\n        if (age < 30) {\n            System.out.println(\"青春年华\");\n        } else {\n            System.out.println(\"而立之年\");\n        }\n    }\n}\n```\n输出：\n```\n而立之年\n```\n除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：\n```\npublic class LeapYear {\n    public static void main(String[] args) {\n        int year = 2020;\n        if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n            System.out.println(\"闰年\");\n        } else {\n            System.out.println(\"普通年份\");\n        }\n    }\n}\n```\n输出：\n```\n闰年\n```\n如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。\n```\npublic class IfElseTernaryExample {\n    public static void main(String[] args) {\n        int num = 13;\n        String result = (num % 2 == 0) ? \"偶数\" : \"奇数\";\n        System.out.println(result);\n    }\n}\n```\n输出：\n```\n奇数\n```\n## if-else-if 语句\nif-else-if 语句的格式如下：\n```\nif(条件1){  \n// 条件1 为 true 时执行的代码\n}else if(条件2){  \n// 条件2 为 true 时执行的代码\n}  \nelse if(条件3){  \n// 条件3 为 true 时执行的代码\n}  \n...  \nelse{  \n// 以上条件均为 false 时执行的代码\n} \n```\n画个流程图表示一下：\n![](https://www.qyihe.xyz/images/post/10.8.jpg)\n来写个示例：\n```\npublic class IfElseIfExample {\n    public static void main(String[] args) {\n        int age = 31;\n        if (age < 30) {\n            System.out.println(\"青春年华\");\n        } else if (age >= 30 && age < 40 ) {\n            System.out.println(\"而立之年\");\n        } else if (age >= 40 && age < 50 ) {\n            System.out.println(\"不惑之年\");\n        } else {\n            System.out.println(\"知天命\");\n        }\n    }\n}\n```\n输出：\n```\n而立之年\n```\n## if 嵌套语句\nif 嵌套语句的格式如下：\n```\nif(外侧条件){    \n     // 外侧条件为 true 时执行的代码 \n          if(内侧条件){  \n             // 内侧条件为 true 时执行的代码\n    }    \n}  \n```\n画个流程图表示一下：\n![](https://www.qyihe.xyz/images/post/10.9.jpg)\n来写个示例：\n```\npublic class NestedIfExample {\n    public static void main(String[] args) {\n        int age = 20;\n        boolean isGirl = true;\n        if (age >= 20) {\n            if (isGirl) {\n                System.out.println(\"女生法定结婚年龄\");\n            }\n        }\n    }\n}\n```\n输出：\n```\n女生法定结婚年龄\n```\n## switch 语句的格式：\n```\nswitch(变量) {    \ncase 可选值1:    \n // 可选值1匹配后执行的代码;    \n break;  // 该关键字是可选项\ncase 可选值2:    \n // 可选值2匹配后执行的代码;    \n break;  // 该关键字是可选项\n......    \n    \ndefault: // 该关键字是可选项     \n // 所有可选值都不匹配后执行的代码 \n}    \n```\n\n- 变量可以有 1 个或者 N 个值。\n\n- 值类型必须和变量类型是一致的，并且值是确定的。\n\n- 值必须是唯一的，不能重复，否则编译会出错。\n\n- break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。\n\n- default 关键字也是可选的。\n![](https://www.qyihe.xyz/images/post/10.10.jpg)\n画个流程图：\n\n来个示例：\n```\npublic class Switch1 {\n    public static void main(String[] args) {\n        int age = 20;\n        switch (age) {\n            case 20 :\n                System.out.println(\"上学\");\n                break;\n            case 24 :\n                System.out.println(\"苏州工作\");\n                break;\n            case 30 :\n                System.out.println(\"洛阳工作\");\n                break;\n            default:\n                System.out.println(\"未知\");\n                break; // 可省略\n        }\n    }\n}\n```\n输出：\n```\n上学\n```\n当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：\n```\npublic class Switch2 {\n    public static void main(String[] args) {\n        String name = \"沉默王二\";\n        switch (name) {\n            case \"詹姆斯\":\n                System.out.println(\"篮球运动员\");\n                break;\n            case \"穆里尼奥\":\n                System.out.println(\"足球教练\");\n                break;\n            case \"沉默王二\":\n            case \"沉默王三\":\n                System.out.println(\"乒乓球爱好者\");\n                break;\n            default:\n                throw new IllegalArgumentException(\n                        \"名字没有匹配项\");\n\n        }\n    }\n}\n```\n输出：\n```\n乒乓球爱好者\n```\n枚举作为 switch 语句的变量也很常见，来看例子：\n```\npublic class SwitchEnumDemo {\n    public enum PlayerTypes {\n        TENNIS,\n        FOOTBALL,\n        BASKETBALL,\n        UNKNOWN\n    }\n\n    public static void main(String[] args) {\n        System.out.println(createPlayer(PlayerTypes.BASKETBALL));\n    }\n\n    private static String createPlayer(PlayerTypes playerType) {\n        switch (playerType) {\n            case TENNIS:\n                return \"网球运动员费德勒\";\n            case FOOTBALL:\n                return \"足球运动员C罗\";\n            case BASKETBALL:\n                return \"篮球运动员詹姆斯\";\n            case UNKNOWN:\n                throw new IllegalArgumentException(\"未知\");\n            default:\n                throw new IllegalArgumentException(\n                        \"运动员类型: \" + playerType);\n\n        }\n    }\n}\n```\n输出：\n```\n篮球运动员詹姆斯\n```\n## 循环语句比较\n\n\n\n比较方式|for   |while  |do-while\n-----   | ---- | ----  | ----\n简介 |for 循环的次数是固定的 |while 循环的次数是不固定的，并且需要条件为 true |do-while 循环的次数也不固定，但会至少执行一次循环，无聊条件是否为 true\n何时使用 |循环次数固定的 |循环次数是不固定的 |循环次数不固定，并且循环体至少要执行一次\n语法 |for(init:condition;++/--) {// 要执行的代码} |while(condition){// 要执行的代码} |do{//要执行的代码}while(condition);\n\n## 普通的 for 循环\n普通的 for 循环可以分为 4 个部分：\n（1）初始变量：循环开始执行时的初始条件。\n（2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。\n（3）循环体：循环每次要执行的代码块，直到条件变为 false。\n（4）自增/自减：初识变量变化的方式。\n来看一下普通 for 循环的格式：\n```\nfor(初识变量;条件;自增/自减){  \n// 循环体\n}  \n```\n画个流程图：\n![](https://www.qyihe.xyz/images/post/10.11.jpg)\n来个示例：\n```\npublic class ForExample {\n    public static void main(String[] args) {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"沉默王二好帅啊\");\n        }\n    }\n}\n```\n输出：\n```\n沉默王二好帅啊\n沉默王二好帅啊\n沉默王二好帅啊\n沉默王二好帅啊\n沉默王二好帅啊\n```\n循环语句还可以嵌套呢，这样就可以打印出更好玩的呢。\n```\npublic class PyramidForExample {\n    public static void main(String[] args) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0;j<= i;j++) {\n                System.out.print(\"❤\");\n            }\n            System.out.println();\n        }\n    }\n}\n```\n打印出什么玩意呢？\n```\n❤\n❤❤\n❤❤❤\n❤❤❤❤\n❤❤❤❤❤\n```\n## for-each\nfor-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：\n```\nfor(元素类型 元素 : 数组或集合){  \n// 要执行的代码\n}  \n```\n来看一下示例：\n```\npublic class ForEachExample {\n    public static void main(String[] args) {\n        String[] strs = {\"沉默王二\", \"一枚有趣的程序员\"};\n\n        for (String str : strs) {\n            System.out.println(str);\n        }\n    }\n}\n```\n输出：\n```\n沉默王二\n一枚有趣的程序员\n```\n## 无限 for 循环\n想不想体验一下无限 for 循环的威力，也就是死循环？\n```\npublic class InfinitiveForExample {\n    public static void main(String[] args) {\n        for(;;){\n            System.out.println(\"停不下来。。。。\");\n        }\n    }\n}\n```\n输出：\n```\n停不下来。。。。\n停不下来。。。。\n停不下来。。。。\n停不下来。。。。\n```\n一旦运行起来，就停不下来了，除非强制停止。\n## while 循环\n```\nwhile(条件){  \n//循环体  \n}  \n```\n画个流程图：\n![](https://www.qyihe.xyz/images/post/10.12.jpg)\n来个示例：\n```\npublic class WhileExample {\n    public static void main(String[] args) {\n        int i = 0;\n        while (true) {\n            System.out.println(\"沉默王二\");\n            i++;\n            if (i == 5) {\n                break;\n            }\n        }\n    }\n}\n```\n猜猜会输出几次？\n```\n沉默王二\n沉默王二\n沉默王二\n沉默王二\n沉默王二\n```\n## do-while 循环\n```\ndo{  \n// 循环体\n}while(提交); \n```\n画个流程图：\n![](https://www.qyihe.xyz/images/post/10.13.jpg)\n来个示例：\n```\npublic class DoWhileExample {\n    public static void main(String[] args) {\n        int i = 0;\n        do {\n            System.out.println(\"沉默王二\");\n            i++;\n            if (i == 5) {\n                break;\n            }\n        } while (true);\n    }\n}\n```\n程序输出结果如下所示：\n```\n沉默王二\n沉默王二\n沉默王二\n沉默王二\n沉默王二\n```\n## break\nbreak 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。\n可以将 break 关键字用于所有类型循环语句中，比如说 for 循环，while 循环，以及 do-while 循环。\n来画个流程图感受一下：\n![](https://www.qyihe.xyz/images/post/10.14.jpg)\n用在 for 循环中的示例：\n```\nfor (int i = 1; i <= 10; i++) {\n    if (i == 5) {\n        break;\n    }\n    System.out.println(i);\n}\n```\n用在嵌套 for 循环中的示例：\n```\nfor (int i = 1; i <= 3; i++) {\n    for (int j = 1; j <= 3; j++) {\n        if (i == 2 && j == 2) {\n            break;\n        }\n        System.out.println(i + \" \" + j);\n    }\n}\n```\n用在 while 循环中的示例：\n```\nint i = 1;\nwhile (i <= 10) {\n    if (i == 5) {\n        i++;\n        break;\n    }\n    System.out.println(i);\n    i++;\n}\n```\n用在 do-while 循环中的示例：\n```\nint j = 1;\ndo {\n    if (j == 5) { \n        j++;\n        break;\n    }\n    System.out.println(j);\n    j++;\n} while (j <= 10);\n```\n## continue\n当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。\n来个示例：\n```\npublic class ContinueDemo {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 10; i++) {\n            if (i == 5) {\n                // 使用 continue 关键字\n                continue;// 5 将会被跳过\n            }\n            System.out.println(i);\n        }\n    }\n}\n```\n输出：\n```\n1\n2\n3\n4\n6\n7\n8\n9\n10\n```\n5 真的被跳过了。\n再来个循环嵌套的例子。\n```\npublic class ContinueInnerDemo {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 3; i++) {\n            for (int j = 1; j <= 3; j++) {\n                if (i == 2 && j == 2) {\n                    //  当i=2，j=2时跳过\n                    continue;\n                }\n                System.out.println(i + \" \" + j);\n            }\n        }\n    }\n}\n```\n打印出什么玩意呢？\n```\n1 1\n1 2\n1 3\n2 1\n2 3\n3 1\n3 2\n3 3\n```\n“2 2” 没有输出，被跳过了。\n再来看一下 while 循环时 continue 的使用示例：\n```\npublic class ContinueWhileDemo {\n    public static void main(String[] args) {\n        int i = 1;\n        while (i <= 10) {\n            if (i == 5) {\n                i++;\n                continue;\n            }\n            System.out.println(i);\n            i++;\n        }\n    }\n}\n```\n输出：\n```\n1\n2\n3\n4\n6\n7\n8\n9\n10\n```\n注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。\n最后，再来看一下 do-while 循环时 continue 的使用示例：\n```\npublic class ContinueDoWhileDemo {\n    public static void main(String[] args) {\n        int i=1;\n        do{\n            if(i==5){\n                i++;\n                continue;\n            }\n            System.out.println(i);\n            i++;\n        }while(i<=10);\n    }\n}\n```\n输出：\n```\n1\n2\n3\n4\n6\n7\n8\n9\n10\n```\n注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。\n# 五、Java 包的简介\n在 Java 中，我们使用 package（包）对相关的类、接口和子包进行分组。这样做的好处有：\n\n- 使相关类型更容易查找\n- 避免命名冲突，比如说 com.itwanger.Hello 和 com.itwangsan.Hello 不同\n- 通过包和访问权限控制符来限定类的可见性\n\n## 01、创建一个包\n```\npackage com.itwanger;\n```\n可以使用 package 关键字来定义一个包名，需要注意的是，这行代码必须处于一个类中的第一行。强烈建议在包中声明类，不要缺省，否则就失去了包结构的带来的好处。\n包的命名应该遵守以下规则：\n\n- 应该全部是小写字母\n- 可以包含多个单词，单词之间使用“.”连接，比如说 java.lang\n- 名称由公司名或者组织名确定，采用倒序的方式，比如说，我个人博客的域名是 www.itwanger.com，所以我创建的包名是就是 com.itwanger.xxxx。\n\n每个包或者子包都在磁盘上有自己的目录结构，如果 Java 文件时在 com.itwanger.xxxx 包下，那么该文件所在的目录结构就应该是 com->itwanger->xxxx。\n## 02、使用包\n让我们在名为 test 的子包里新建一个 Cmower 类：\n```\npackage com.itwanger.test;\n\npublic class Cmower {\n    private String name;\n    private int age;\n}\n```\n如果需要在另外一个包中使用 Cmower 类，就需要通过 import 关键字将其引入。有两种方式可供选择，第一种，使用 * 导入包下所有的类：\n```\nimport com.itwanger.test.*;\n```\n第二种，使用类名导入该类：\n```\nimport com.itwanger.test.Cmower;\n```\nJava 和第三方类库提供了很多包可供使用，可以通过上述的方式导入类库使用。\n```\npackage com.itwanger.test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CmowerTest {\n    public static void main(String[] args) {\n        List<Cmower> list = new ArrayList<>();\n        list.add(new Cmower());\n    }\n}\n```\n## 03、全名\n有时，我们可能会使用来自不同包下的两个具有相同名称的类。例如，我们可能同时使用 java.sql.Date 和 java.util.Date。当我们遇到命名冲突时，我们需要对至少一个类使用全名（包名+类名）。\n\n```List<com.itwanger.test.Cmower> list1 = new ArrayList<>();\nlist.add(new com.itwanger.test.Cmower());\n```\n# 六、Java 到底是值传递还是引用传递\n将参数传递给方法有两种常见的方式，一种是“值传递”，一种是“引用传递”。C 语言本身只支持值传递，它的衍生品 C++ 既支持值传递，也支持引用传递，而 Java 只支持值传递。\n## 01、值传递 VS 引用传递\n首先，我们必须要搞清楚，到底什么是值传递，什么是引用传递，否则，讨论 Java 到底是值传递还是引用传递就显得毫无意义。\n当一个参数按照值的方式在两个方法之间传递时，调用者和被调用者其实是用的两个不同的变量——被调用者中的变量（原始值）是调用者中变量的一份拷贝，对它们当中的任何一个变量修改都不会影响到另外一个变量。\n而当一个参数按照引用传递的方式在两个方法之间传递时，调用者和被调用者其实用的是同一个变量，当该变量被修改时，双方都是可见的。\nJava 程序员之所以容易搞混值传递和引用传递，主要是因为 Java 有两种数据类型，一种是基本类型，比如说 int，另外一种是引用类型，比如说 String。\n基本类型的变量存储的都是实际的值，而引用类型的变量存储的是对象的引用——指向了对象在内存中的地址。值和引用存储在 stack（栈）中，而对象存储在 heap（堆）中。\n![](https://www.qyihe.xyz/images/post/10.15.jpg)\n之所以有这个区别，是因为：\n\n- 栈的优势是，存取速度比堆要快，仅次于直接位于 CPU 中的寄存器。但缺点是，栈中的数据大小与生存周期必须是确定的。\n- 堆的优势是可以动态地分配内存大小，生存周期也不必事先告诉编译器，Java 的垃圾回收器会自动收走那些不再使用的数据。但由于要在运行时动态分配内存，存取速度较慢。\n\n## 02、基本类型的参数传递\n众所周知，Java 有 8 种基本数据类型，分别是 int、long、byte、short、float、double 、char 和 boolean。它们的值直接存储在栈中，每当作为参数传递时，都会将原始值（实参）复制一份新的出来，给形参用。形参将会在被调用方法结束时从栈中清除。\n来看下面这段代码：\n```\npublic class PrimitiveTypeDemo {\n    public static void main(String[] args) {\n        int age = 18;\n        modify(age);\n        System.out.println(age);\n    }\n\n    private static void modify(int age1) {\n        age1 = 30;\n    }\n}\n```\n（1）main 方法中的 age 是基本类型，所以它的值 18 直接存储在栈中。\n（2）调用 modify() 方法的时候，将为实参 age 创建一个副本（形参 age1），它的值也为 18，不过是在栈中的其他位置。\n（3）对形参 age 的任何修改都只会影响它自身而不会影响实参。\n![](https://www.qyihe.xyz/images/post/10.16.jpg)\n## 03、引用类型的参数传递\n来看一段创建引用类型变量的代码：\n```\nWriter writer = new Writer(18, \"沉默王二\");\n```\nwriter 是对象吗？还是对象的引用？为了搞清楚这个问题，我们可以把上面的代码拆分为两行代码：\n```\nWriter writer;\nwriter = new Writer(18, \"沉默王二\");\n```\n假如 writer 是对象的话，就不需要通过 new 关键字创建对象了，对吧？那也就是说，writer 并不是对象，在“=”操作符执行之前，它仅仅是一个变量。那谁是对象呢？new Writer(18, \"沉默王二\")，它是对象，存储于堆中；然后，“=”操作符将对象的引用赋值给了 writer 变量，于是 writer 此时应该叫对象引用，它存储在栈中，保存了对象在堆中的地址。\n每当引用类型作为参数传递时，都会创建一个对象引用（实参）的副本（形参），该形参保存的地址和实参一样。\n来看下面这段代码：\n```\npublic class ReferenceTypeDemo {\n    public static void main(String[] args) {\n        Writer a = new Writer(18);\n        Writer b = new Writer(18);\n        modify(a, b);\n\n        System.out.println(a.getAge());\n        System.out.println(b.getAge());\n    }\n\n    private static void modify(Writer a1, Writer b1) {\n        a1.setAge(30);\n\n        b1 = new Writer(18);\n        b1.setAge(30);\n    }\n}\n```\n（1）在调用 modify() 方法之前，实参 a 和 b 指向的对象是不一样的，尽管 age 都为 18。\n![](https://www.qyihe.xyz/images/post/10.17.jpg)\n（2）在调用 modify() 方法时，实参 a 和 b 都在栈中创建了一个新的副本，分别是 a1 和 b1，但指向的对象是一致的（a 和 a1 指向对象 a，b 和 b1 指向对象 b）。\n![](https://www.qyihe.xyz/images/post/10.18.jpg)\n（3）在 modify() 方法中，修改了形参 a1 的 age 为 30，意味着对象 a 的 age 从 18 变成了 30，而实参 a 指向的也是对象 a，所以 a 的 age 也变成了 30；形参 b1 指向了一个新的对象，随后 b1 的 age 被修改为 30。\n![](https://www.qyihe.xyz/images/post/10.19.jpg)\n修改 a1 的 age，意味着同时修改了 a 的 age，因为它们指向的对象是一个；修改 b1 的 age，对 b 却没有影响，因为它们指向的对象是两个。\n程序输出的结果如下所示：\n```\n30\n18\n```\n果然和我们的分析是吻合的。\n# 七、Java 的类和对象\n类和对象是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。对象可以是现实中看得见的任何物体（一只特立独行的猪），也可以是想象中的任何虚拟物体（能七十二变的孙悟空），Java 通过类（class）来定义这些物体，有什么状态（通过字段，或者叫成员变量定义，比如说猪的颜色是纯色还是花色），有什么行为（通过方法定义，比如说猪会吃，会睡觉）。\n来，让我来定义一个简单的类给你看看。\n```\npublic class Pig {\n    private String color;\n\n    public void eat() {\n        System.out.println(\"吃\");\n    }\n}\n```\n默认情况下，每个 Java 类都会有一个空的构造方法，尽管它在源代码中是缺省的，但却可以通过反编译字节码看到它。\n```\npublic class Pig {\n    private String color;\n\n    public Pig() {\n    }\n\n    public void eat() {\n        System.out.println(\"吃\");\n    }\n}\n```\n没错，就是多出来的那个 public Pig() {}，参数是空的，方法体是空的。我们可以通过 new 关键字利用这个构造方法来创建一个对象，代码如下所示：\n ```\n Pig pig = new Pig();\n ```\n当然了，我们也可以主动添加带参的构造方法。\n```\npublic class Pig {\n    private String color;\n\n    public Pig(String color) {\n        this.color = color;\n    }\n\n    public void eat() {\n        System.out.println(\"吃\");\n    }\n}\n```\n这时候，再查看反编译后的字节码时，你会发现缺省的无参构造方法消失了——和源代码一模一样。\n```\npublic class Pig {\n    private String color;\n\n    public Pig(String color) {\n        this.color = color;\n    }\n\n    public void eat() {\n        System.out.println(\"吃\");\n    }\n}\n```\n这意味着无法通过 new Pig() 来创建对象了——编译器会提醒你追加参数。\n![](https://www.qyihe.xyz/images/post/10.20.jpg)\n比如说你将代码修改为 new Pig(\"纯白色\")，或者添加无参的构造方法。\n```\npublic class Pig {\n    private String color;\n\n    public Pig(String color) {\n        this.color = color;\n    }\n\n    public Pig() {\n    }\n\n    public void eat() {\n        System.out.println(\"吃\");\n    }\n}\n```\n使用无参构造方法创建的对象状态默认值为 null（color 字符串为引用类型），如果是基本类型的话，默认值为对应基本类型的默认值，比如说 int 为 0，更详细的见下图。\n![](https://www.qyihe.xyz/images/post/10.21.jpg)\n（图片中有一处错误，boolean 的默认值为 false）\n接下来，我们来创建多个 Pig 对象，它的颜色各不相同。\n```\npublic class PigTest {\n    public static void main(String[] args) {\n        Pig pigNoColor = new Pig();\n        Pig pigWhite = new Pig(\"纯白色\");\n        Pig pigBlack = new Pig(\"纯黑色\");\n    }\n}\n```\n你看，我们创建了 3 个不同花色的 Pig 对象，全部来自于一个类，由此可见类的重要性，只需要定义一次，就可以多次使用。\n那假如我想改变对象的状态呢？该怎么办？目前毫无办法，因为没有任何可以更改状态的方法，直接修改 color 是行不通的，因为它的访问权限修饰符是 private 的。\n最好的办法就是为 Pig 类追加 getter/setter 方法，就像下面这样：\n```\npublic String getColor() {\n    return color;\n}\n\npublic void setColor(String color) {\n    this.color = color;\n}\n```\n通过 setColor() 方法来修改，通过 getColor() 方法获取状态，它们的权限修饰符是 public 的。\n```\nPig pigNoColor = new Pig();\npigNoColor.setColor(\"花色\");\nSystem.out.println(pigNoColor.getColor()); // 花色\n```\n为什么要这样设计呢？可以直接将 color 字段的访问权限修饰符换成是 public 的啊，不就和 getter/setter 一样的效果了吗？\n因为有些情况，某些字段是不允许被随意修改的，它只有在对象创建的时候初始化一次，比如说猪的年龄，它只能每年长一岁（举个例子），没有月光宝盒让它变回去。\n```\nprivate int age;\n\npublic int getAge() {\n    return age;\n}\n\npublic void increaseAge() {\n    this.age++;\n}\n```\n你看，age 就没有 setter 方法，只有一个每年可以调用一次的 increaseAge() 方法和 getter 方法。如果把 age 的访问权限修饰符更改为 public，age 就完全失去控制了，可以随意将其重置为 0 或者负数。\n访问权限修饰符对于 Java 来说，非常重要，目前共有四种：public、private、protected 和 default（缺省）。\n一个类只能使用 public 或者 default 修饰，public 修饰的类你之前已经见到过了，现在我来定义一个缺省权限修饰符的类给你欣赏一下。\n```\nclass Dog {\n}\n```\n哈哈，其实也没啥可以欣赏的。缺省意味着这个类可以被同一个包下的其他类进行访问；而 public 意味着这个类可以被所有包下的类进行访问。\n假如硬要通过 private 和 protected 来修饰类的话，编译器会生气的，它不同意。\n![](https://www.qyihe.xyz/images/post/10.22.jpg)\nprivate 可以用来修饰类的构造方法、字段和方法，只能被当前类进行访问。protected 也可以用来修饰类的构造方法、字段和方法，但它的权限范围更宽一些，可以被同一个包中的类进行访问，或者当前类的子类。\n可以通过下面这张图来对比一下四个权限修饰符之间的差别：\n![](https://www.qyihe.xyz/images/post/10.23.jpg)\n\n- 同一个类中，不管是哪种权限修饰符，都可以访问；\n- 同一个包下，private 修饰的无法访问；\n- 子类可以访问 public 和 protected 修饰的；\n- public 修饰符面向世界，哈哈，可以被所有的地方访问到。\n![](https://www.qyihe.xyz/images/post/10.24.jpg)\n# 八、Java 构造方法\n假设现在有一个 Writer 类，它有两个字段，姓名和年纪：\n```\npublic class Writer {\n    private String name;\n    private int age;\n\n    @Override\n    public String toString() {\n        return \"Writer{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n```\n重写了 toString() 方法，用于打印 Writer 类的详情。由于没有构造方法，意味着当我们创建 Writer 对象时，它的字段值并没有初始化：\n```\nWriter writer = new Writer();\nSystem.out.println(writer.toString());\n```\n输出结果如下所示：\n```\nWriter{name='null', age=0}\n```\nname 是字符串类型，所以默认值为 null，age 为 int 类型，所以默认值为 0。\n让我们为 Writer 类主动加一个无参的构造方法：\n```\npublic Writer() {\n    this.name = \"\";\n    this.age = 0;\n}\n```\n构造方法也是一个方法，只不过它没有返回值，默认返回创建对象的类型。需要注意的是，当前构造方法没有参数，它被称为无参构造方法。如果我们没有主动创建无参构造方法的话，编译器会隐式地自动添加一个无参的构造方法。这就是为什么，一开始虽然没有构造方法，却可以使用 new Writer() 创建对象的原因，只不过，所有的字段都被初始化成了默认值。\n接下来，让我们添加一个有参的构造方法：\n```\npublic Writer(String name, int age) {\n    this.name = name;\n    this.age = age;\n}\n```\n现在，我们创建 Writer 对象的时候就可以通过对字段值初始化值了。\n```\nWriter writer1 = new Writer(\"沉默王二\",18);\nSystem.out.println(writer1.toString());\n```\n来看一下打印结果：\n```\nWriter{name='沉默王二', age=18}\n```\n可以根据字段的数量添加不同参数数量的构造方法，比如说，我们可以单独为 name 字段添加一个构造方法：\n```\npublic Writer(String name) {\n    this.name = name;\n}\n```\n为了能够兼顾 age 字段，我们可以通过 this 关键字调用其他的构造方法：\n```\npublic Writer(String name) {\n    this(name,18);\n}\n```\n把作者的年龄都默认初始化为 18。如果需要使用父类的构造方法，还可以使用 super 关键字，手册后面有详细的介绍。\n# 九、Java 抽象类\n当我们要完成的任务是确定的，但具体的方式需要随后开个会投票的话，Java 的抽象类就派上用场了。这句话怎么理解呢？搬个小板凳坐好，听我来给你讲讲。\n![](https://www.qyihe.xyz/images/post/10.25.jpg)\n## 01、抽象类的 5 个关键点\n（1）定义抽象类的时候需要用到关键字 abstract，放在 class 关键字前。\n```\npublic abstract class AbstractPlayer {\n}\n```\n关于抽象类的命名，阿里出品的 Java 开发手册上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，记住了哦。\n（2）抽象类不能被实例化，但可以有子类。\n尝试通过 new 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。\n![](https://www.qyihe.xyz/images/post/10.26.jpg)\n通过 extends 关键字可以继承抽象类，继承后，BasketballPlayer 类就是 AbstractPlayer 的子类。\n```\npublic class BasketballPlayer extends AbstractPlayer {\n}\n```\n（3）如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。\n当在一个普通类（没有使用 abstract 关键字修饰）中定义了抽象方法，编译器就会有两处错误提示。\n第一处在类级别上，提醒你“这个类必须通过 abstract 关键字定义”，or 的那个信息没必要，见下图。\n![](https://www.qyihe.xyz/images/post/10.27.jpg)\n第二处在方法级别上，提醒你“抽象方法所在的类不是抽象的”，见下图。\n![](https://www.qyihe.xyz/images/post/10.28.jpg)\n（4）抽象类可以同时声明抽象方法和具体方法，也可以什么方法都没有，但没必要。就像下面这样：\n```\npublic abstract class AbstractPlayer {\n    abstract void play();\n    \n    public void sleep() {\n        System.out.println(\"运动员也要休息而不是挑战极限\");\n    }\n}\n```\n（5）抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类中定义了 play() 方法，子类中就必须实现。\n```\npublic class BasketballPlayer extends AbstractPlayer {\n    @Override\n    void play() {\n        System.out.println(\"我是张伯伦，篮球场上得过 100 分\");\n    }\n}\n```\n如果没有实现的话，编译器会提醒你“子类必须实现抽象方法”，见下图。\n![](https://www.qyihe.xyz/images/post/10.29.jpg)\n## 02、什么时候用抽象类\n与抽象类息息相关的还有一个概念，就是接口，我们留到下一篇文章中详细说，因为要说的知识点还是蛮多的。你现在只需要有这样一个概念就好，接口是对行为的抽象，抽象类是对整个类（包含成员变量和行为）进行抽象。\n（是不是有点明白又有点不明白，别着急，翘首以盼地等下一篇文章出炉吧）\n除了接口之外，还有一个概念就是具体的类，就是不通过 abstract 修饰的普通类，见下面这段代码中的定义。\n```\npublic class BasketballPlayer {\n   public void play() {\n        System.out.println(\"我是詹姆斯，现役第一人\");\n    }\n}\n```\n有接口，有具体类，那什么时候该使用抽象类呢？\n（1）我们希望一些通用的功能被多个子类复用。比如说，AbstractPlayer 抽象类中有一个普通的方法 sleep()，表明所有运动员都需要休息，那么这个方法就可以被子类复用。\n```\npublic abstract class AbstractPlayer {\n    public void sleep() {\n        System.out.println(\"运动员也要休息而不是挑战极限\");\n    }\n}\n```\n虽然 AbstractPlayer 类可以不是抽象类——把 abstract 修饰符去掉也能满足这种场景。但 AbstractPlayer 类可能还会有一个或者多个抽象方法。\nBasketballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。\n```\npublic class BasketballPlayer extends AbstractPlayer {\n}\n```\nBasketballPlayer 对象可以直接调用 sleep() 方法：\n```\nBasketballPlayer basketballPlayer = new BasketballPlayer();\nbasketballPlayer.sleep();\n```\nFootballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。\n```\npublic class FootballPlayer extends AbstractPlayer {\n}\n```\nFootballPlayer 对象也可以直接调用 sleep() 方法：\n```\nFootballPlayer footballPlayer = new FootballPlayer();\nfootballPlayer.sleep();\n```\n（2）我们需要在抽象类中定义好 API，然后在子类中扩展实现。比如说，AbstractPlayer  抽象类中有一个抽象方法 play()，定义所有运动员都可以从事某项运动，但需要对应子类去扩展实现。\n```\npublic abstract class AbstractPlayer {\n    abstract void play();\n}\n```\nBasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。\n```\npublic class BasketballPlayer extends AbstractPlayer {\n    @Override\n    void play() {\n        System.out.println(\"我是张伯伦，我篮球场上得过 100 分，\");\n    }\n}```\n\nFootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。\n```\npublic class FootballPlayer extends AbstractPlayer {\n    @Override\n    void play() {\n        System.out.println(\"我是C罗，我能接住任意高度的头球\");\n    }\n}\n```\n（3）如果父类与子类之间的关系符合 is-a 的层次关系，就可以使用抽象类，比如说篮球运动员是运动员，足球运动员是运动员。\n## 03、具体示例\n为了进一步展示抽象类的特性，我们再来看一个具体的示例。假设现在有一个文件，里面的内容非常简单——“Hello World”，现在需要有一个读取器将内容读取出来，最好能按照大写的方式，或者小写的方式。\n这时候，最好定义一个抽象类，比如说 BaseFileReader：\n```\npublic abstract class BaseFileReader {\n    protected Path filePath;\n\n    protected BaseFileReader(Path filePath) {\n        this.filePath = filePath;\n    }\n\n    public List<String> readFile() throws IOException {\n        return Files.lines(filePath)\n                .map(this::mapFileLine).collect(Collectors.toList());\n    }\n\n    protected abstract String mapFileLine(String line);\n}\n```\nfilePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问。\nreadFile() 方法用来读取文件，方法体里面调用了抽象方法 mapFileLine()——需要子类扩展实现大小写的方式。\n你看，BaseFileReader 设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。\n小写的方式：\n```\npublic class LowercaseFileReader extends BaseFileReader {\n    protected LowercaseFileReader(Path filePath) {\n        super(filePath);\n    }\n\n    @Override\n    protected String mapFileLine(String line) {\n        return line.toLowerCase();\n    }\n}\n```\n大写的方式：\n```\npublic class UppercaseFileReader extends BaseFileReader {\n    protected UppercaseFileReader(Path filePath) {\n        super(filePath);\n    }\n\n    @Override\n    protected String mapFileLine(String line) {\n        return line.toUpperCase();\n    }\n}\n```\n你看，从文件里面一行一行读取内容的代码被子类复用了——抽象类 BaseFileReader 类中定义的普通方法 readFile()。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。\n接下来，我们来新建一个测试类 FileReaderTest：\n```\npublic class FileReaderTest {\n    public static void main(String[] args) throws URISyntaxException, IOException {\n        URL location = FileReaderTest.class.getClassLoader().getResource(\"helloworld.txt\");\n        Path path = Paths.get(location.toURI());\n        BaseFileReader lowercaseFileReader = new LowercaseFileReader(path);\n        BaseFileReader uppercaseFileReader = new UppercaseFileReader(path);\n        System.out.println(lowercaseFileReader.readFile());\n        System.out.println(uppercaseFileReader.readFile());\n    }\n}\n```\n项目的 resource 目录下有一个文本文件，名字叫 helloworld.txt。\n![](https://www.qyihe.xyz/images/post/10.30.jpg)\n可以通过 ClassLoader.getResource() 的方式获取到该文件的 URI 路径，然后就可以使用 LowercaseFileReader 和 UppercaseFileReader 两种方式读取到文本内容了。\n输出结果如下所示：\n```\n[hello world]\n[HELLO WORLD]\n```\n# 十、Java 接口\n对于面向对象编程来说，抽象是一个极具魅力的特征。如果一个程序员的抽象思维很差，那他在编程中就会遇到很多困难，无法把业务变成具体的代码。在 Java 中，可以通过两种形式来达到抽象的目的，一种是抽象类，另外一种就是接口。\n如果你现在就想知道抽象类与接口之间的区别，我可以提前给你说一个：\n\n- 一个类只能继承一个抽象类，但却可以实现多个接口。\n\n当然了，在没有搞清楚接口到底是什么，它可以做什么之前，这个区别理解起来会有点难度。\n## 01、接口是什么\n接口是通过 interface 关键字定义的，它可以包含一些常量和方法，来看下面这个示例。\n```\npublic interface Electronic {\n    // 常量\n    String LED = \"LED\";\n\n    // 抽象方法\n    int getElectricityUse();\n\n    // 静态方法\n    static boolean isEnergyEfficient(String electtronicType) {\n        return electtronicType.equals(LED);\n    }\n\n    // 默认方法\n    default void printDescription() {\n        System.out.println(\"电子\");\n    }\n}\n```\n（1）接口中定义的变量会在编译的时候自动加上 public static final 修饰符，也就是说 LED 变量其实是一个常量。\nJava 官方文档上有这样的声明：\n```\nEvery field declaration in the body of an interface is implicitly public, static, and final.\n```\n换句话说，接口可以用来作为常量类使用，还能省略掉 public static final，看似不错的一种选择，对吧？\n不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。\n（2）没有使用 private、default 或者 static 关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 public abstract 修饰符。也就是说 getElectricityUse() 其实是一个抽象方法，没有方法体——这是定义接口的本意。\n（3）从 Java 8 开始，接口中允许有静态方法，比如说 isEnergyEfficient() 方法。\n静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口的名字来调用，比如说 Electronic.isEnergyEfficient(\"LED\")。\n接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。\n（4）接口中允许定义 default 方法也是从 Java 8 开始的，比如说 printDescription()，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现，也就是说，无法直接使用一个“;”号来结束默认方法——编译器会报错的。\n![](https://www.qyihe.xyz/images/post/10.31.jpg)\n允许在接口中定义默认方法的理由是很充分的，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 default 方法的帮助下，我们就必须挨个对实现类进行修改。\n来看一下 Electronic 接口反编译后的字节码吧，你会发现，接口中定义的所有变量或者方法，都会自动添加上 public 关键字——假如你想知道编译器在背后都默默做了哪些辅助，记住反编译字节码就对了。\n```\npublic interface Electronic\n{\n\n    public abstract int getElectricityUse();\n\n    public static boolean isEnergyEfficient(String electtronicType)\n    {\n        return electtronicType.equals(\"LED\");\n    }\n\n    public void printDescription()\n    {\n        System.out.println(\"\\u7535\\u5B50\");\n    }\n\n    public static final String LED = \"LED\";\n}\n```\n有些读者可能会问，“二哥，为什么我反编译后的字节码和你的不一样，你用了什么反编译工具？”其实没有什么秘密，微信搜「沉默王二」回复关键字「JAD」就可以免费获取了，超级好用。\n## 02、定义接口的注意事项\n由之前的例子我们就可以得出下面这些结论：\n\n- 接口中允许定义变量\n- 接口中允许定义抽象方法\n- 接口中允许定义静态方法（Java 8 之后）\n- 接口中允许定义默认方法（Java 8 之后）\n\n除此之外，我们还应该知道：\n（1）接口不允许直接实例化。\n![](https://www.qyihe.xyz/images/post/10.32.jpg)\n需要定义一个类去实现接口，然后再实例化。\n```\npublic class Computer implements Electronic {\n\n    public static void main(String[] args) {\n        new Computer();\n    }\n\n    @Override\n    public int getElectricityUse() {\n        return 0;\n    }\n}\n```\n（2）接口可以是空的，既不定义变量，也不定义方法。\n```\npublic interface Serializable {\n}\n```\nSerializable 是最典型的一个空的接口，我之前分享过一篇文章《Java Serializable：明明就一个空的接口嘛》，感兴趣的读者可以去我的个人博客看一看，你就明白了空接口的意义。\n```\nwww.itwanger.com/java/2019/1…\n```\n\n（3）不要在定义接口的时候使用 final 关键字，否则会报编译错误，因为接口就是为了让子类实现的，而 final 阻止了这种行为。\n![](https://www.qyihe.xyz/images/post/10.33.jpg)\n（4）接口的抽象方法不能是 private、protected 或者 final。\n![](https://www.qyihe.xyz/images/post/10.34.jpg)\n![](https://www.qyihe.xyz/images/post/10.35.jpg)\n![](https://www.qyihe.xyz/images/post/10.36.jpg)\n（5）接口的变量是隐式 public static final，所以其值无法改变。\n## 03、接口可以做什么\n（1）使某些实现类具有我们想要的功能，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了 Comparable 或者 Comparator 的类具有比较功能。\nCloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 Object.clone() 方法，否则会抛出 CloneNotSupportedException。\n```\npublic class CloneableTest implements Cloneable {\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    public static void main(String[] args) throws CloneNotSupportedException {\n        CloneableTest c1 = new CloneableTest();\n        CloneableTest c2 = (CloneableTest) c1.clone();\n    }\n}\n```\n运行后没有报错。现在把 implements Cloneable 去掉。\n```\npublic class CloneableTest {\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    public static void main(String[] args) throws CloneNotSupportedException {\n        CloneableTest c1 = new CloneableTest();\n        CloneableTest c2 = (CloneableTest) c1.clone();\n\n    }\n}\n```\n运行后抛出 CloneNotSupportedException：\n```\nException in thread \"main\" java.lang.CloneNotSupportedException: com.cmower.baeldung.interface1.CloneableTest\n\tat java.base/java.lang.Object.clone(Native Method)\n\tat com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:6)\n\tat com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:11)\n```\n至于 Comparable 和 Comparator 的用法，感兴趣的读者可以参照我之前写的另外一篇文章《来吧，一文彻底搞懂Java中的Comparable和Comparator》。\n```\nwww.itwanger.com/java/2020/0…\n```\n（2）Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。\n可能有些读者会问，“二哥，为什么 Java 只支持单一继承？”简单来解释一下。\n如果有两个类共同继承（extends）一个有特定方法的父类，那么该方法会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。这也正是著名的菱形问题，见下图。\n![](https://www.qyihe.xyz/images/post/10.37.jpg)\nClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重载的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。\n接口没有这方面的困扰。来定义两个接口，Fly 会飞，Run 会跑。\n```\npublic interface Fly {\n    void fly();\n}\npublic interface Run {\n    void run();\n}\n```\n然后让一个类同时实现这两个接口。\n```\npublic class Pig implements Fly,Run{\n    @Override\n    public void fly() {\n        System.out.println(\"会飞的猪\");\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"会跑的猪\");\n    }\n}\n```\n这就在某种形式上达到了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。\n（3）实现多态。\n什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。\n多态可以通过继承（extends）的关系实现，也可以通过接口的形式实现。来看这样一个例子。\nShape 是表示一个形状。\n```\npublic interface Shape {\n    String name();\n}\n```\n圆是一个形状。\n```\npublic class Circle implements Shape {\n    @Override\n    public String name() {\n        return \"圆\";\n    }\n}\n```\n正方形也是一个形状。\n```\npublic class Square implements Shape {\n    @Override\n    public String name() {\n        return \"正方形\";\n    }\n}\n```\n然后来看测试类。\n```\nList<Shape> shapes = new ArrayList<>();\nShape circleShape = new Circle();\nShape squareShape = new Square();\n\nshapes.add(circleShape);\nshapes.add(squareShape);\n\nfor (Shape shape : shapes) {\n    System.out.println(shape.name());\n}\n```\n多态的存在 3 个前提：\n1、要有继承关系，Circle 和 Square 都实现了 Shape 接口\n2、子类要重写父类的方法，Circle 和 Square 都重写了 name() 方法\n3、父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle 对象，后者指向的是 Square 对象。\n然后，我们来看一下测试结果：\n```\n圆\n正方形\n```\n也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 name() 方法的时候，它知道 Circle 对象应该调用 Circle 类的 name() 方法，Square 对象应该调用 Square 类的 name() 方法。\n## 04、接口与抽象类的区别\n好了，关于接口的一切，你应该都搞清楚了。现在回到读者春夏秋冬的那条留言，“兄弟，说说抽象类和接口之间的区别？”\n（1）语法层面上\n\n- 接口中不能有 public 和 protected 修饰的方法，抽象类中可以有。\n- 接口中的变量只能是隐式的常量，抽象类中可以有任意类型的变量。\n- 一个类只能继承一个抽象类，但却可以实现多个接口。\n\n（2）设计层面上\n抽象类是对类的一种抽象，继承抽象类的类和抽象类本身是一种 is-a 的关系。\n接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，所有的类都可以实现 Serializable 接口，从而具有序列化的功能。\n就这么多吧，能说道这份上，我相信面试官就不会为难你了。\n# 十一、Java 继承\n在 Java 中，一个类可以继承另外一个类或者实现多个接口，我想这一点，大部分的读者应该都知道了。还有一点，我不确定大家是否知道，就是一个接口也可以继承另外一个接口，就像下面这样：\n```\npublic interface OneInterface extends Cloneable {\n}\n```\n这样做有什么好处呢？我想有一部分读者应该已经猜出来了，就是实现了 OneInterface 接口的类，也可以使用 Object.clone() 方法了。\n```\npublic class TestInterface implements OneInterface {\n    public static void main(String[] args) throws CloneNotSupportedException {\n        TestInterface c1 = new TestInterface();\n        TestInterface c2 = (TestInterface) c1.clone();\n    }\n}\n```\n除此之外，我们还可以在 OneInterface 接口中定义其他一些抽象方法（比如说深拷贝），使该接口拥有 Cloneable 所不具有的功能。\n```\npublic interface OneInterface extends Cloneable {\n    void deepClone();\n}\n```\n看到了吧？这就是继承的好处：子接口拥有了父接口的方法，使得子接口具有了父接口相同的行为；同时，子接口还可以在此基础上自由发挥，添加属于自己的行为。\n以上，把“接口”换成“类”，结论同样成立。让我们来定义一个普通的父类 Wanger：\n```\npublic class Wanger {\n    int age;\n    String name;\n    void write() {\n        System.out.println(\"我写了本《基督山伯爵》\");\n    }\n}\n```\n然后，我们再来定义一个子类 Wangxiaoer，使用关键字 extends 来继承父类 Wanger：\n```\npublic class Wangxiaoer extends Wanger{\n    @Override\n    void write() {\n        System.out.println(\"我写了本《茶花女》\");\n    }\n}\n```\n我们可以将通用的方法和成员变量放在父类中，达到代码复用的目的；然后将特殊的方法和成员变量放在子类中，除此之外，子类还可以覆盖父类的方法（比如write() 方法）。这样，子类也就焕发出了新的生命力。\nJava 只支持单一继承，这一点，我在上一篇接口的文章中已经提到过了。如果一个类在定义的时候没有使用 extends 关键字，那么它隐式地继承了 java.lang.Object 类——在我看来，这恐怕就是 Java 号称万物皆对象的真正原因了。\n那究竟子类继承了父类的什么呢？\n子类可以继承父类的非 private 成员变量，为了验证这一点，我们来看下面这个示例。\n```\npublic class Wanger {\n    String defaultName;\n    private String privateName;\n    public String publicName;\n    protected String protectedName;\n}\n```\n父类 Wanger 定义了四种类型的成员变量，缺省的 defaultName、私有的 privateName、共有的 publicName、受保护的 protectedName。\n在子类 Wangxiaoer 中定义一个测试方法 testVariable()：\n![](https://www.qyihe.xyz/images/post/10.38.jpg)\n可以确认，除了私有的 privateName，其他三种类型的成员变量都可以继承到。\n同理，子类可以继承父类的非 private 方法，为了验证这一点，我们来看下面这个示例。\n```\npublic class Wanger {\n    void write() {\n    }\n\n    private void privateWrite() {\n    }\n\n    public void publicWrite() {\n    }\n\n    protected void protectedWrite() {\n    }\n}\n```\n父类 Wanger 定义了四种类型的方法，缺省的 write、私有的 privateWrite()、共有的 publicWrite()、受保护的 protectedWrite()。\n在子类 Wangxiaoer 中定义一个 main 方法，并使用 new 关键字新建一个子类对象：\n![](https://www.qyihe.xyz/images/post/10.39.jpg)\n可以确认，除了私有的 privateWrite()，其他三种类型的方法都可以继承到。\n不过，子类无法继承父类的构造方法。如果父类的构造方法是带有参数的，代码如下所示：\n```\npublic class Wanger {\n    int age;\n    String name;\n\n    public Wanger(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n}\n```\n则必须在子类的构造器中显式地通过 super 关键字进行调用，否则编译器将提示以下错误：\n![](https://www.qyihe.xyz/images/post/10.40.jpg)\n修复后的代码如下所示：\n```\npublic class Wangxiaoer extends Wanger{\n    public Wangxiaoer(int age, String name) {\n        super(age, name);\n    }\n}\n```\nis-a 是继承的一个明显特征，就是说子类的对象引用类型可以是一个父类类型。\n```\npublic class Wangxiaoer extends Wanger{\n    public static void main(String[] args) {\n        Wanger wangxiaoer = new Wangxiaoer();\n    }\n}\n```\n同理，子接口的实现类的对象引用类型也可以是一个父接口类型。\n```\npublic interface OneInterface extends Cloneable {\n}\npublic class TestInterface implements OneInterface {\n    public static void main(String[] args) {\n        Cloneable c1 = new TestInterface();\n    }\n}\n```\n尽管一个类只能继承一个类，但一个类却可以实现多个接口，这一点，我在上一篇文章也提到过了。另外，还有一点我也提到了，就是 Java 8 之后，接口中可以定义 default 方法，这很方便，但也带来了新的问题：\n\n> 如果一个类实现了多个接口，而这些接口中定义了相同签名的 default 方法，那么这个类就要重写该方法，否则编译无法通过。\n\nFlyInterface 是一个会飞的接口，里面有一个签名为 sleep() 的默认方法：\n```\npublic interface FlyInterface {\n    void fly();\n    default void sleep() {\n        System.out.println(\"睡着飞\");\n    }\n}\n```\nRunInterface 是一个会跑的接口，里面也有一个签名为 sleep() 的默认方法：\n```\npublic interface RunInterface {\n    void run();\n    default void sleep() {\n        System.out.println(\"睡着跑\");\n    }\n}\n```\nPig 类实现了 FlyInterface 和 RunInterface 两个接口，但这时候编译出错了。\n![](https://www.qyihe.xyz/images/post/10.41.jpg)\n原本，default 方法就是为实现该接口而不覆盖该方法的类提供默认实现的，现在，相同方法签名的 sleep() 方法把编译器搞懵逼了，只能重写了。\n```\npublic class Pig implements FlyInterface, RunInterface {\n\n    @Override\n    public void fly() {\n        System.out.println(\"会飞的猪\");\n    }\n\n    @Override\n    public void sleep() {\n        System.out.println(\"只能重写了\");\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"会跑的猪\");\n    }\n}\n```\n类虽然不能继承多个类，但接口却可以继承多个接口，这一点，我不知道有没有触及到一些读者的知识盲区。\n```\npublic interface WalkInterface extends FlyInterface,RunInterface{\n    void walk();\n}\n```\n# 十二、this 关键字\n在 Java 中，this 关键字指的是当前对象（它的方法正在被调用）的引用，能理解吧，各位亲？不理解的话，我们继续往下看。\n看完再不明白，你过来捶爆我，我保证不还手，只要不打脸。\n## 01、消除字段歧义\n我敢赌一毛钱，所有的读者，不管男女老少，应该都知道这种用法，毕竟写构造方法的时候经常用啊。谁要不知道，过来，我给你发一毛钱红包，只要你脸皮够厚。\n```\npublic class Writer {\n    private int age;\n    private String name;\n\n    public Writer(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n}\n```\nWriter 类有两个成员变量，分别是 age 和 name，在使用有参构造函数的时候，如果参数名和成员变量的名字相同，就需要使用 this 关键字消除歧义：this.age 是指成员变量，age 是指构造方法的参数。\n## 02、引用类的其他构造方法\n当一个类的构造方法有多个，并且它们之间有交集的话，就可以使用 this 关键字来调用不同的构造方法，从而减少代码量。\n比如说，在无参构造方法中调用有参构造方法：\n```\npublic class Writer {\n    private int age;\n    private String name;\n\n    public Writer(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    public Writer() {\n        this(18, \"沉默王二\");\n    }\n}\n```\n也可以在有参构造方法中调用无参构造方法：\n```\npublic class Writer {\n    private int age;\n    private String name;\n\n    public Writer(int age, String name) {\n        this();\n        this.age = age;\n        this.name = name;\n    }\n\n    public Writer() {\n    }\n}\n```\n需要注意的是，this() 必须是构造方法中的第一条语句，否则就会报错。\n![](https://www.qyihe.xyz/images/post/10.42.jpg)\n## 03、作为参数传递\n在下例中，有一个无参的构造方法，里面调用了 print() 方法，参数只有一个 this 关键字。\n```\npublic class ThisTest {\n    public ThisTest() {\n        print(this);\n    }\n\n    private void print(ThisTest thisTest) {\n        System.out.println(\"print \" +thisTest);\n    }\n\n    public static void main(String[] args) {\n        ThisTest test = new ThisTest();\n        System.out.println(\"main \" + test);\n    }\n}\n```\n来打印看一下结果：\n```\nprint com.cmower.baeldung.this1.ThisTest@573fd745\nmain com.cmower.baeldung.this1.ThisTest@573fd745\n```\n从结果中可以看得出来，this 就是我们在 main() 方法中使用 new 关键字创建的 ThisTest 对象。\n## 04、链式调用\n学过 JavaScript，或者 jQuery 的读者可能对链式调用比较熟悉，类似于 a.b().c().d()，仿佛能无穷无尽调用下去。\n在 Java 中，对应的专有名词叫 Builder 模式，来看一个示例。\n```\npublic class Writer {\n    private int age;\n    private String name;\n    private String bookName;\n    \n    public Writer(WriterBuilder builder) {\n        this.age = builder.age;\n        this.name = builder.name;\n        this.bookName = builder.bookName;\n    }\n\n    public static class WriterBuilder {\n        public String bookName;\n        private int age;\n        private String name;\n\n        public WriterBuilder(int age, String name) {\n            this.age = age;\n            this.name = name;\n        }\n\n        public WriterBuilder writeBook(String bookName) {\n            this.bookName = bookName;\n            return this;\n        }\n\n        public Writer build() {\n            return new Writer(this);\n        }\n    }\n}\n```\nWriter 类有三个成员变量，分别是 age、name 和 bookName，还有它们仨对应的一个构造方法，参数是一个内部静态类 WriterBuilder。\n内部类 WriterBuilder 也有三个成员变量，和 Writer 类一致，不同的是，WriterBuilder 类的构造方法里面只有 age 和 name 赋值了，另外一个成员变量 bookName 通过单独的方法 writeBook() 来赋值，注意，该方法的返回类型是 WriterBuilder，最后使用 return 返回了 this 关键字。\n最后的 build() 方法用来创建一个 Writer 对象，参数为 this 关键字，也就是当前的 WriterBuilder 对象。\n这时候，创建 Writer 对象就可以通过链式调用的方式。\n```\nWriter writer = new Writer.WriterBuilder(18,\"沉默王二\")\n                .writeBook(\"《Web全栈开发进阶之路》\")\n                .build();\n```\n## 05、在内部类中访问外部类对象\n说实话，自从 Java 8 的函数式编程出现后，就很少用到 this 在内部类中访问外部类对象了。来看一个示例：\n```\npublic class ThisInnerTest {\n    private String name;\n    \n    class InnerClass {\n        public InnerClass() {\n            ThisInnerTest thisInnerTest = ThisInnerTest.this;\n            String outerName = thisInnerTest.name;\n        }\n    }\n}\n```\n在内部类 InnerClass 的构造方法中，通过外部类.this 可以获取到外部类对象，然后就可以使用外部类的成员变量了，比如说 name。\n# 十三、super 关键字\n简而言之，super 关键字就是用来访问父类的。\n先来看父类：\n```\npublic class SuperBase {\n    String message = \"父类\";\n\n    public SuperBase(String message) {\n        this.message = message;\n    }\n\n    public SuperBase() {\n    }\n\n    public void printMessage() {\n        System.out.println(message);\n    }\n}\n```\n再来看子类：\n```\npublic class SuperSub extends SuperBase {\n    String message = \"子类\";\n\n    public SuperSub(String message) {\n        super(message);\n    }\n\n    public SuperSub() {\n        super.printMessage();\n        printMessage();\n    }\n\n    public void getParentMessage() {\n        System.out.println(super.message);\n    }\n\n    public void printMessage() {\n        System.out.println(message);\n    }\n}\n```\n（1）super 关键字可用于访问父类的构造方法\n你看，子类可以通过 super(message) 来调用父类的构造方法。现在来新建一个 SuperSub 对象，看看输出结果是什么：\n```\nSuperSub superSub = new SuperSub(\"子类的message\");\n```\nnew 关键字在调用构造方法创建子类对象的时候，会通过 super 关键字初始化父类的 message，所以此此时父类的 message 会输出“子类的message”。\n（2）super 关键字可以访问父类的变量\n上述例子中的 SuperSub 类中就有，getParentMessage() 通过 super.message 方法父类的同名成员变量 message。\n（3）当方法发生重写时，super 关键字可以访问父类的同名方法\n上述例子中的 SuperSub 类中就有，无参的构造方法 SuperSub() 中就使用 super.printMessage() 调用了父类的同名方法。\n# 十四、重写和重载\n先来看一段重写的代码吧。\n```\nclass LaoWang{\n    public void write() {\n        System.out.println(\"老王写了一本《基督山伯爵》\");\n    }\n}\npublic class XiaoWang extends LaoWang {\n    @Override\n    public void write() {\n        System.out.println(\"小王写了一本《茶花女》\");\n    }\n}\n```\n重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。就好像父类 LaoWang 有一个 write() 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 write() 方法（无参），但方法体是写一本《茶花女》。\n来写一段测试代码。\n```\npublic class OverridingTest {\n    public static void main(String[] args) {\n        LaoWang wang = new XiaoWang();\n        wang.write();\n    }\n}\n```\n大家猜结果是什么？\n```\n小王写了一本《茶花女》\n```\n在上面的代码中，们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 write() 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 write() 方法而不是父类 LaoWang  中的 write() 方法，因此输出结果为“小王写了一本《茶花女》”。\n再来看一段重载的代码吧。\n```\nclass LaoWang{\n    public void read() {\n        System.out.println(\"老王读了一本《Web全栈开发进阶之路》\");\n    }\n    \n    public void read(String bookname) {\n        System.out.println(\"老王读了一本《\" + bookname + \"》\");\n    }\n}\n```\n重载的两个方法名相同，但方法参数的个数不同，另外也不涉及到继承，两个方法在同一个类中。就好像类 LaoWang 有两个方法，名字都是 read()，但一个有参数（书名），另外一个没有（只能读写死的一本书）。\n来写一段测试代码。\n```\npublic class OverloadingTest {\n    public static void main(String[] args) {\n        LaoWang wang = new LaoWang();\n        wang.read();\n        wang.read(\"金瓶梅\");\n    }\n}\n```\n这结果就不用猜了。变量 wang 的类型为 LaoWang，wang.read() 调用的是无参的 read() 方法，因此先输出“老王读了一本《Web全栈开发进阶之路》”；wang.read(\"金瓶梅\") 调用的是有参的 read(bookname) 方法，因此后输出“老王读了一本《金瓶梅》”。在编译期间，编译器就知道这两个 read() 方法时不同的，因为它们的方法签名（=方法名称+方法参数）不同。\n简单的来总结一下：\n（1）编译器无法决定调用哪个重写的方法，因为只从变量的类型上是无法做出判断的，要在运行时才能决定；但编译器可以明确地知道该调用哪个重载的方法，因为引用类型是确定的，参数个数决定了该调用哪个方法。\n（2）多态针对的是重写，而不是重载。\n![](https://www.qyihe.xyz/images/post/10.43.jpg)\n哎，后悔啊，早年我要是能把这道面试题吃透的话，也不用被老马刁难了。吟一首诗感慨一下人生吧。\n\n>青青园中葵，朝露待日晞。\n>阳春布德泽，万物生光辉。\n>常恐秋节至，焜黄华叶衰。\n>百川东到海，何时复西归?\n>少壮不努力，老大徒伤悲\n\n另外，我想要告诉大家的是，重写（Override）和重载（Overload）是 Java 中两个非常重要的概念，新手经常会被它们俩迷惑，因为它们俩的英文名字太像了，中文翻译也只差一个字。难，太难了。\n![](https://www.qyihe.xyz/images/post/10.44.jpg)\n# 十五、static 关键字\n先来个提纲挈领（唉呀妈呀，成语区博主上线了）吧：\n\n>static 关键字可用于变量、方法、代码块和内部类，表示某个特定的成员只属于某个类本身，而不是该类的某个对象。\n\n## 01、静态变量\n静态变量也叫类变量，它属于一个类，而不是这个类的对象。\n```\npublic class Writer {\n    private String name;\n    private int age;\n    public static int countOfWriters;\n\n    public Writer(String name, int age) {\n        this.name = name;\n        this.age = age;\n        countOfWriters++;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n其中，countOfWriters 被称为静态变量，它有别于 name 和 age 这两个成员变量，因为它前面多了一个修饰符 static。\n这意味着无论这个类被初始化多少次，静态变量的值都会在所有类的对象中共享。\n```\nWriter w1 = new Writer(\"沉默王二\",18);\nWriter w2 = new Writer(\"沉默王三\",16);\n\nSystem.out.println(Writer.countOfWriters);\n```\n按照上面的逻辑，你应该能推理得出，countOfWriters 的值此时应该为 2 而不是 1。从内存的角度来看，静态变量将会存储在 Java 虚拟机中一个名叫“Metaspace”（元空间，Java 8 之后）的特定池中。\n静态变量和成员变量有着很大的不同，成员变量的值属于某个对象，不同的对象之间，值是不共享的；但静态变量不是的，它可以用来统计对象的数量，因为它是共享的。就像上面例子中的 countOfWriters，创建一个对象的时候，它的值为 1，创建两个对象的时候，它的值就为 2。\n简单小结一下：\n（1）由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问；\n![](https://www.qyihe.xyz/images/post/10.45.jpg)\n（2）不需要初始化类就可以访问静态变量。\n```\npublic class WriterDemo {\n    public static void main(String[] args) {\n        System.out.println(Writer.countOfWriters); // 输出 0\n    }\n}\n```\n## 02、静态方法\n静态方法也叫类方法，它和静态变量类似，属于一个类，而不是这个类的对象。\n```\npublic static void setCountOfWriters(int countOfWriters) {\n    Writer.countOfWriters = countOfWriters;\n}\n```\nsetCountOfWriters() 就是一个静态方法，它由 static 关键字修饰。\n如果你用过 java.lang.Math 类或者 Apache 的一些工具类（比如说 StringUtils）的话，对静态方法一定不会感动陌生。\n![](https://www.qyihe.xyz/images/post/10.46.jpg)\nMath 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。\n![](https://www.qyihe.xyz/images/post/10.47.jpg)\n简单小结一下：\n（1）Java 中的静态方法在编译时解析，因为静态方法不能被重写（方法重写发生在运行时阶段，为了多态）。\n（2）抽象方法不能是静态的。\n![](https://www.qyihe.xyz/images/post/10.48.jpg)\n（3）静态方法不能使用 this 和 super 关键字。\n（4）成员方法可以直接访问其他成员方法和成员变量。\n（5）成员方法也可以直接方法静态方法和静态变量。\n（6）静态方法可以访问所有其他静态方法和静态变量。\n（7）静态方法无法直接访问成员方法和成员变量。\n![](https://www.qyihe.xyz/images/post/10.49.jpg)\n## 03、静态代码块\n静态代码块可以用来初始化静态变量，尽管静态方法也可以在声明的时候直接初始化，但有些时候，我们需要多行代码来完成初始化。\n```\npublic class StaticBlockDemo {\n    public static List<String> writes = new ArrayList<>();\n\n    static {\n        writes.add(\"沉默王二\");\n        writes.add(\"沉默王三\");\n        writes.add(\"沉默王四\");\n\n        System.out.println(\"第一块\");\n    }\n\n    static {\n        writes.add(\"沉默王五\");\n        writes.add(\"沉默王六\");\n\n        System.out.println(\"第二块\");\n    }\n}\n```\nwrites 是一个静态的 ArrayList，所以不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初始化。\n简单小结一下：\n（1）一个类可以有多个静态代码块。\n（2）静态代码块的解析和执行顺序和它在类中的位置保持一致。为了验证这个结论，可以在 StaticBlockDemo 类中加入空的 main 方法，执行完的结果如下所示：\n```\n第一块\n第二块\n```\n## 04、静态内部类\nJava 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。\n常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我们本次文章的讨论范围，以后有机会再细说。\n```\npublic class Singleton {\n    private Singleton() {}\n\n    private static class SingletonHolder {\n        public static final Singleton instance = new Singleton();\n    }\n\n    public static Singleton getInstance() {\n        return SingletonHolder.instance;\n    }\n}\n```\n以上这段代码是不是特别熟悉，对，这就是创建单例的一种方式，第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全也能保证 Singleton 类的唯一性。不过，创建单例更优雅的一种方式是使用枚举。\n简单小结一下：\n（1）静态内部类不能访问外部类的所有成员变量。\n（2）静态内部类可以访问外部类的所有静态变量，包括私有静态变量。\n（3）外部类不能声明为 static。\n![](https://www.qyihe.xyz/images/post/10.50.jpg)\n# 十六、Java 枚举\n开门见山地说吧，enum（枚举）是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，默认继承自 java.lang.Enum。\n为了证明这一点，我们来新建一个枚举 PlayerType：\n```\npublic enum PlayerType {\n    TENNIS,\n    FOOTBALL,\n    BASKETBALL\n}\n```\n两个关键字带一个类名，还有大括号，以及三个大写的单词，但没看到继承 Enum 类啊？别着急，心急吃不了热豆腐啊。使用 JAD 查看一下反编译后的字节码，就一清二楚了。\n```\npublic final class PlayerType extends Enum\n{\n\n    public static PlayerType[] values()\n    {\n        return (PlayerType[])$VALUES.clone();\n    }\n\n    public static PlayerType valueOf(String name)\n    {\n        return (PlayerType)Enum.valueOf(com/cmower/baeldung/enum1/PlayerType, name);\n    }\n\n    private PlayerType(String s, int i)\n    {\n        super(s, i);\n    }\n\n    public static final PlayerType TENNIS;\n    public static final PlayerType FOOTBALL;\n    public static final PlayerType BASKETBALL;\n    private static final PlayerType $VALUES[];\n\n    static \n    {\n        TENNIS = new PlayerType(\"TENNIS\", 0);\n        FOOTBALL = new PlayerType(\"FOOTBALL\", 1);\n        BASKETBALL = new PlayerType(\"BASKETBALL\", 2);\n        $VALUES = (new PlayerType[] {\n            TENNIS, FOOTBALL, BASKETBALL\n        });\n    }\n}\n```\n看到没？PlayerType 类是 final 的，并且继承自 Enum 类。这些工作我们程序员没做，编译器帮我们悄悄地做了。此外，它还附带几个有用静态方法，比如说 values() 和  valueOf(String name)。\n## 01、内部枚举\n好的，小伙伴们应该已经清楚枚举长什么样子了吧？既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。\n```\npublic class Player {\n    private PlayerType type;\n    public enum PlayerType {\n        TENNIS,\n        FOOTBALL,\n        BASKETBALL\n    }\n    \n    public boolean isBasketballPlayer() {\n      return getType() == PlayerType.BASKETBALL;\n    }\n\n    public PlayerType getType() {\n        return type;\n    }\n\n    public void setType(PlayerType type) {\n        this.type = type;\n    }\n}\n```\nPlayerType 就相当于 Player 的内部类，isBasketballPlayer() 方法用来判断运动员是否是一个篮球运动员。\n由于枚举是 final 的，可以确保在 Java 虚拟机中仅有一个常量对象（可以参照反编译后的静态代码块「static 关键字带大括号的那部分代码」），所以我们可以很安全地使用“==”运算符来比较两个枚举是否相等，参照 isBasketballPlayer() 方法。\n那为什么不使用 equals() 方法判断呢？\n```\nif(player.getType().equals(Player.PlayerType.BASKETBALL)){};\nif(player.getType() == Player.PlayerType.BASKETBALL){};\n```\n“==”运算符比较的时候，如果两个对象都为 null，并不会发生 NullPointerException，而 equals() 方法则会。\n另外， “==”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而 equals() 方法则不会。\n![](https://www.qyihe.xyz/images/post/10.51.jpg)\n## 02、枚举可用于 switch 语句\n这个我在之前的一篇我去的文章中详细地说明过了，感兴趣的小伙伴可以点击链接跳转过去看一下。\n```\nswitch (playerType) {\n        case TENNIS:\n            return \"网球运动员费德勒\";\n        case FOOTBALL:\n            return \"足球运动员C罗\";\n        case BASKETBALL:\n            return \"篮球运动员詹姆斯\";\n        case UNKNOWN:\n            throw new IllegalArgumentException(\"未知\");\n        default:\n            throw new IllegalArgumentException(\n                    \"运动员类型: \" + playerType);\n\n}\n```\n## 03、枚举可以有构造方法\n如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。\n```\npublic enum PlayerType {\n    TENNIS(\"网球\"),\n    FOOTBALL(\"足球\"),\n    BASKETBALL(\"篮球\");\n\n    private String name;\n\n    PlayerType(String name) {\n        this.name = name;\n    }\n}\n```\n## 04、EnumSet\nEnumSet 是一个专门针对枚举类型的 Set 接口的实现类，它是处理枚举类型数据的一把利器，非常高效（内部实现是位向量，我也搞不懂）。\n因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法：\n![](https://www.qyihe.xyz/images/post/10.52.jpg)\n下面的示例中使用 noneOf() 创建了一个空的 PlayerType 的 EnumSet；使用 allOf() 创建了一个包含所有 PlayerType 的 EnumSet。\n```\npublic class EnumSetTest {\n    public enum PlayerType {\n        TENNIS,\n        FOOTBALL,\n        BASKETBALL\n    }\n\n    public static void main(String[] args) {\n        EnumSet<PlayerType> enumSetNone = EnumSet.noneOf(PlayerType.class);\n        System.out.println(enumSetNone);\n\n        EnumSet<PlayerType> enumSetAll = EnumSet.allOf(PlayerType.class);\n        System.out.println(enumSetAll);\n    }\n}\n```\n程序输出结果如下所示：\n```\n[]\n[TENNIS, FOOTBALL, BASKETBALL]\n```\n有了 EnumSet 后，就可以使用 Set 的一些方法了：\n![](https://www.qyihe.xyz/images/post/10.53.jpg)\n## 05、EnumMap\nEnumMap 是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。\n和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字：\n```\nEnumMap<PlayerType, String> enumMap = new EnumMap<>(PlayerType.class);\n```\n有了 EnumMap 对象后就可以使用 Map 的一些方法了：\n![](https://www.qyihe.xyz/images/post/10.54.jpg)\n和 HashMap 的使用方法大致相同，来看下面的例子：\n```\nEnumMap<PlayerType, String> enumMap = new EnumMap<>(PlayerType.class);\nenumMap.put(PlayerType.BASKETBALL,\"篮球运动员\");\nenumMap.put(PlayerType.FOOTBALL,\"足球运动员\");\nenumMap.put(PlayerType.TENNIS,\"网球运动员\");\nSystem.out.println(enumMap);\n\nSystem.out.println(enumMap.get(PlayerType.BASKETBALL));\nSystem.out.println(enumMap.containsKey(PlayerType.BASKETBALL));\nSystem.out.println(enumMap.remove(PlayerType.BASKETBALL));\n```\n程序输出结果如下所示：\n```\n{TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员}\n篮球运动员\ntrue\n篮球运动员\n```\n## 06、单例\n通常情况下，实现一个单例并非易事，不信，来看下面这段代码\n```\npublic class Singleton {  \n    private volatile static Singleton singleton; \n    private Singleton (){}  \n    public static Singleton getSingleton() {  \n    if (singleton == null) {\n        synchronized (Singleton.class) { \n        if (singleton == null) {  \n            singleton = new Singleton(); \n        }  \n        }  \n    }  \n    return singleton;  \n    }  \n}\n```\n但枚举的出现，让代码量减少到极致：\n```\npublic enum EasySingleton{\n    INSTANCE;\n}\n```\n完事了，真的超级短，有没有？枚举默认实现了 Serializable 接口，因此 Java 虚拟机可以保证该类为单例，这与传统的实现方式不大相同。传统方式中，我们必须确保单例在反序列化期间不能创建任何新实例。\n## 07、枚举可与数据库交互\n我们可以配合 Mybatis 将数据库字段转换为枚举类型。现在假设有一个数据库字段 check_type 的类型如下：\n```\n`check_type` int(1) DEFAULT NULL COMMENT '检查类型（1：未通过、2：通过）',\n```\n它对应的枚举类型为 CheckType，代码如下：\n```\npublic enum CheckType {\n\tNO_PASS(0, \"未通过\"), PASS(1, \"通过\");\n\tprivate int key;\n\n\tprivate String text;\n\n\tprivate CheckType(int key, String text) {\n\t\tthis.key = key;\n\t\tthis.text = text;\n\t}\n\n\tpublic int getKey() {\n\t\treturn key;\n\t}\n\n\tpublic String getText() {\n\t\treturn text;\n\t}\n\n\tprivate static HashMap<Integer,CheckType> map = new HashMap<Integer,CheckType>();\n\tstatic {\n\t\tfor(CheckType d : CheckType.values()){\n\t\t\tmap.put(d.key, d);\n\t\t}\n\t}\n\t\n\tpublic static CheckType parse(Integer index) {\n\t\tif(map.containsKey(index)){\n\t\t\treturn map.get(index);\n\t\t}\n\t\treturn null;\n\t}\n}\n```\n（1）CheckType 添加了构造方法，还有两个字段，key 为 int 型，text 为 String 型。\n（2）CheckType 中有一个public static CheckType parse(Integer index)方法，可将一个 Integer 通过 key 的匹配转化为枚举类型。\n那么现在，我们可以在 Mybatis 的配置文件中使用 typeHandler 将数据库字段转化为枚举类型。\n```\n<resultMap id=\"CheckLog\" type=\"com.entity.CheckLog\">\n  <id property=\"id\" column=\"id\"/>\n  <result property=\"checkType\" column=\"check_type\" typeHandler=\"com.CheckTypeHandler\"></result>\n</resultMap>\n```\n其中 checkType 字段对应的类如下：\n```\npublic class CheckLog implements Serializable {\n\n    private String id;\n    private CheckType checkType;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public CheckType getCheckType() {\n        return checkType;\n    }\n\n    public void setCheckType(CheckType checkType) {\n        this.checkType = checkType;\n    }\n}\n```\nCheckTypeHandler 转换器的类源码如下：\n```\npublic class CheckTypeHandler extends BaseTypeHandler<CheckType> {\n\n\t@Override\n\tpublic CheckType getNullableResult(ResultSet rs, String index) throws SQLException {\n\t\treturn CheckType.parse(rs.getInt(index));\n\t}\n\n\t@Override\n\tpublic CheckType getNullableResult(ResultSet rs, int index) throws SQLException {\n\t\treturn CheckType.parse(rs.getInt(index));\n\t}\n\n\t@Override\n\tpublic CheckType getNullableResult(CallableStatement cs, int index) throws SQLException {\n\t\treturn CheckType.parse(cs.getInt(index));\n\t}\n\n\t@Override\n\tpublic void setNonNullParameter(PreparedStatement ps, int index, CheckType val, JdbcType arg3) throws SQLException {\n\t\tps.setInt(index, val.getKey());\n\t}\n}\n```\nCheckTypeHandler 的核心功能就是调用 CheckType 枚举类的 parse() 方法对数据库字段进行转换。\n![](https://www.qyihe.xyz/images/post/10.55.jpg)\n恕我直言，我觉得小伙伴们肯定会用 Java 枚举了，如果还不会，就过来砍我！\n# 十七、final 关键字\n尽管继承可以让我们重用现有代码，但有时处于某些原因，我们确实需要对可扩展性进行限制，final 关键字可以帮助我们做到这一点。\n## 01、final 类\n如果一个类使用了 final 关键字修饰，那么它就无法被继承。如果小伙伴们细心观察的话，Java 就有不少 final 类，比如说最常见的 String 类。\n```\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence,\n               Constable, ConstantDesc {}\n```\n为什么 String 类要设计成 final 的呢？原因大致有以下三个：\n\n- 为了实现字符串常量池\n- 为了线程安全\n- 为了 HashCode 的不可变性\n\n更详细的原因，可以查看我之前写的一篇文章。\n任何尝试从 final 类继承的行为将会引发编译错误，为了验证这一点，我们来看下面这个例子，Writer 类是 final 的。\n```\npublic final class Writer {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n尝试去继承它，编译器会提示以下错误，Writer 类是 final 的，无法继承。\n![](https://www.qyihe.xyz/images/post/10.56.jpg)\n不过，类是 final 的，并不意味着该类的对象是不可变的。\n```\nWriter writer = new Writer();\nwriter.setName(\"沉默王二\");\nSystem.out.println(writer.getName()); // 沉默王二\n```\nWriter 的 name 字段的默认值是 null，但可以通过 settter 方法将其更改为“沉默王二”。也就是说，如果一个类只是 final 的，那么它并不是不可变的全部条件。\n如果，你想了解不可变类的全部真相，请查看我之前写的文章这次要说不明白immutable类，我就怎么地。突然发现，写系列文章真的妙啊，很多相关性的概念全部涉及到了。我真服了自己了。\n把一个类设计成 final 的，有其安全方面的考虑，但不应该故意为之，因为把一个类定义成 final 的，意味着它没办法继承，假如这个类的一些方法存在一些问题的话，我们就无法通过重写的方式去修复它。\n![](https://www.qyihe.xyz/images/post/10.57.jpg)\n## 02、final 方法\n被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它设计成 final 的。\nThread 类就是一个例子，它本身不是 final 的，这意味着我们可以扩展它，但它的 isAlive() 方法是 final 的：\n```\npublic class Thread implements Runnable {\n    public final native boolean isAlive();\n}\n```\n需要注意的是，该方法是一个本地（native）方法，用于确认线程是否处于活跃状态。而本地方法是由操作系统决定的，因此重写该方法并不容易实现。\nActor 类有一个 final 方法 show()：\n```\npublic class Actor {\n    public final void show() {\n        \n    }\n}\n```\n当我们想要重写该方法的话，就会出现编译错误：\n![](https://www.qyihe.xyz/images/post/10.58.jpg)\n如果一个类中的某些方法要被其他方法调用，则应考虑事被调用的方法称为 final 方法，否则，重写该方法会影响到调用方法的使用。\n一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？\n我能想到的一点，就是前者不能被继承，也就是说方法无法被重写；后者呢，可以被继承，然后追加一些非 final 的方法。没毛病吧？看把我聪明的。\n![](https://www.qyihe.xyz/images/post/10.59.jpg)\n## 03、final 变量\n被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。之前被一个小伙伴问过，什么是 effective final，什么是 final，这一点，我在之前的文章也有阐述过，所以这里再贴一下地址：\n```\nwww.itwanger.com/java/2020/0…\n```\n（1）final 修饰的基本数据类型\n来声明一个 final 修饰的 int 类型的变量：\n```\nfinal int age = 18;\n```\n尝试将它修改为 30，结果编译器生气了：\n![](https://www.qyihe.xyz/images/post/10.60.jpg)\n（2）final 修饰的引用类型\n现在有一个普通的类 Pig，它有一个字段 name：\n```\npublic class Pig {\n   private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n在测试类中声明一个 final 修饰的 Pig 对象：\n final Pig pig = new Pig();\n如果尝试将 pig 重新赋值的话，编译器同样会生气：\n![](https://www.qyihe.xyz/images/post/10.61.jpg)\n但我们仍然可以去修改 Pig 的字段值：\n```\nfinal Pig pig = new Pig();\npig.setName(\"特立独行\");\nSystem.out.println(pig.getName()); // 特立独行\n```\n（3）final 修饰的字段\nfinal 修饰的字段可以分为两种，一种是 static 的，另外一种是没有 static 的，就像下面这样：\n```\npublic class Pig {\n   private final int age = 1;\n   public static final double PRICE = 36.5;\n}\n```\n非 static 的 final 字段必须有一个默认值，否则编译器将会提醒没有初始化：\n![](https://www.qyihe.xyz/images/post/10.62.jpg)\nstatic 的 final 字段也叫常量，它的名字应该为大写，可以在声明的时候初始化，也可以通过 static 代码块初始化。\n\n(4) final 修饰的参数\n\nfinal 关键字还可以修饰参数，它意味着参数在方法体内不能被再修改：\n```\npublic class ArgFinalTest {\n    public void arg(final int age) {\n    }\n\n    public void arg1(final String name) {\n    }\n}\n```\n如果尝试去修改它的话，编译器会提示以下错误：\n![](https://www.qyihe.xyz/images/post/10.63.jpg)\n。。。。。。\n\n> \n>转载于[沉默王二](https://juejin.im/post/5ee414c76fb9a047dd2768ea#heading-39)\n> ","slug":"10","published":1,"updated":"2021-08-01T07:42:17.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cky03p49s001d0cumdx5u14dx","content":"<p>这么说吧，在我眼里，Java 就是最流行的编程语言，没有之一（PHP 往一边站）。不仅岗位多，容易找到工作，关键是薪资水平也到位，不学 Java 亏得慌，对吧？<br>那可能零基础学编程的小伙伴就会头疼了，网上关于 Java 的大部分技术文章都不够幽默，不够风趣，不够系列，急需要一份能看得进去的学习手册，那我觉得我肝的这份手册正好符合要求，并且会一直持续更新下去。<br>第一版的内容暂时包含两方面，Java 基础和 Java 面向对象编程。来吧，先上目录，一睹为快。<br>01、Java 基本语法简介<br>02、Java 基本数据类型简介<br>03、Java main() 方法简介<br>04、Java 的流程控制语句<br>05、Java 包的简介<br>06、Java 到底是值传递还是引用传递<br>07、Java 的类和对象<br>08、Java 构造方法<br>09、Java 抽象类<br>10、Java 接口<br>11、Java 继承<br>12、this 关键字<br>13、super 关键字<br>14、重写和重载<br>15、static 关键字<br>16、Java 枚举<br>17、final 关键字<br>目录欣赏完了，接下来就是拜读精华内容的时间，搬个小板凳，认认真真好好学吧，学到就是赚到！</p>\n<h1 id=\"一、Java-基本语法简介\"><a href=\"#一、Java-基本语法简介\" class=\"headerlink\" title=\"一、Java 基本语法简介\"></a>一、Java 基本语法简介</h1><h2 id=\"01、数据类型\"><a href=\"#01、数据类型\" class=\"headerlink\" title=\"01、数据类型\"></a>01、数据类型</h2><p>Java 有 2 种数据类型，一种是基本数据类型，一种是引用类型。<br>基本数据类型用于存储简单类型的数据，比如说，int、long、byte、short 用于存储整数，float、double 用于存储浮点数，char 用于存储字符，boolean 用于存储布尔值。<br>不同的基本数据类型，有不同的默认值和大小，来个表格感受下。</p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>默认值</th>\n<th>大小</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean</td>\n<td>false</td>\n<td>1比特</td>\n</tr>\n<tr>\n<td>char</td>\n<td>0</td>\n<td>2字节</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>0</td>\n<td>1字节</td>\n</tr>\n<tr>\n<td>short</td>\n<td>0</td>\n<td>2字节</td>\n</tr>\n<tr>\n<td>int</td>\n<td>0</td>\n<td>4字节</td>\n</tr>\n<tr>\n<td>long</td>\n<td>0L</td>\n<td>8字节</td>\n</tr>\n<tr>\n<td>float</td>\n<td>0.0f</td>\n<td>4字节</td>\n</tr>\n<tr>\n<td>double</td>\n<td>0.0</td>\n<td>8字节</td>\n</tr>\n</tbody></table>\n<p>引用类型用于存储对象（null 表示没有值的对象）的引用，String 是引用类型的最佳代表，比如说 String cmower = “沉默王二”。</p>\n<h2 id=\"02、声明变量\"><a href=\"#02、声明变量\" class=\"headerlink\" title=\"02、声明变量\"></a>02、声明变量</h2><p>要声明一个变量，必须指定它的名字和类型，来看一个简单的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age;</span><br><span class=\"line\">String name;</span><br></pre></td></tr></table></figure>\n<p>count 和 name 在声明后会得到一个默认值，按照它们的数据类型——不能是局部变量（否则 Java 编译器会在你使用变量的时候提醒要先赋值），必须是类成员变量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SyntaxLocalVariable &#123;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SyntaxLocalVariable syntax = new SyntaxLocalVariable();</span><br><span class=\"line\">        System.out.println(syntax.age); // 输出 0</span><br><span class=\"line\">        System.out.println(syntax.name);  // 输出 null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以在声明一个变量后使用“=”操作符进行赋值，就像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age = 18;</span><br><span class=\"line\">String name = &quot;沉默王二&quot;;</span><br></pre></td></tr></table></figure>\n<p>我们定义了 2 个变量，int 类型的 age 和 String 类型的 name，age 赋值 18，name 赋值为“沉默王二”。<br>每行代码后面都跟了一个“;”，表示当前语句结束了。<br>在 Java 中，变量最好遵守命名约定，这样能提高代码的可阅读性。</p>\n<ul>\n<li>以字母、下划线（_）或者美元符号（$）开头</li>\n<li>不能使用 Java 的保留字，比如说 int 不能作为变量名</li>\n</ul>\n<h2 id=\"03、数组\"><a href=\"#03、数组\" class=\"headerlink\" title=\"03、数组\"></a>03、数组</h2><p>数组在 Java 中占据着重要的位置，它是很多集合类的底层实现。数组属于引用类型，它用来存储一系列指定类型的数据。<br>声明数组的一般语法如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type[] identiier = new type[length];</span><br></pre></td></tr></table></figure>\n<p>type 可以是任意的基本数据类型或者引用类型。来看下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ArraysDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int [] nums = new int[10];</span><br><span class=\"line\">        nums[0] = 18;</span><br><span class=\"line\">        nums[1] = 19;</span><br><span class=\"line\">        System.out.println(nums[0]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数组的索引从 0 开始，第一个元素的索引为 0，第二个元素的索引为 1。为什么要这样设计？感兴趣的话，你可以去探究一下。<br>通过变量名[索引]的方式可以访问数组指定索引处的元素，赋值或者取值是一样的。</p>\n<h2 id=\"04、关键字\"><a href=\"#04、关键字\" class=\"headerlink\" title=\"04、关键字\"></a>04、关键字</h2><p>关键字属于保留字，在 Java 中具有特殊的含义，比如说 public、final、static、new 等等，它们不能用来作为变量名。为了便于你作为参照，我列举了 48 个常用的关键字，你可以瞅一瞅。</p>\n<p>1： abstract： abstract 关键字用于声明抽象类——可以有抽象和非抽象方法。</p>\n<p>2： boolean： boolean 关键字用于将变量声明为布尔值类型，它只有 true 和 false 两个值。</p>\n<p>3： break： break 关键字用于中断循环或 switch 语句。</p>\n<p>4： byte： byte 关键字用于声明一个可以容纳 8 个比特的变量。</p>\n<p>5： case： case 关键字用于在 switch 语句中标记条件的值。</p>\n<p>6： catch： catch 关键字用于捕获 try 语句中的异常。</p>\n<p>7： char： char 关键字用于声明一个可以容纳无符号 16 位比特的 Unicode 字符的变量。</p>\n<p>8： class： class 关键字用于声明一个类。</p>\n<p>9： continue： continue 关键字用于继续下一个循环。它可以在指定条件下跳过其余代码。</p>\n<p>10：default： default 关键字用于指定 switch 语句中除去 case 条件之外的默认代码块。</p>\n<p>11：do： do 关键字通常和 while 关键字配合使用，do 后紧跟循环体。</p>\n<p>12：double： double 关键字用于声明一个可以容纳 64 位浮点数的变量。</p>\n<p>13：else： else 关键字用于指示 if 语句中的备用分支。</p>\n<p>14：enum： enum（枚举）关键字用于定义一组固定的常量。</p>\n<p>15：extends： extends 关键字用于指示一个类是从另一个类或接口继承的。</p>\n<p>16：final： final 关键字用于指示该变量是不可更改的。</p>\n<p>17：finally： finally 关键字和 try-catch 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</p>\n<p>18：float： float 关键字用于声明一个可以容纳 32 位浮点数的变量。</p>\n<p>19：for： for 关键字用于启动一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</p>\n<p>20：if： if 关键字用于指定条件，如果条件为真，则执行对应代码。</p>\n<p>21：implements： implements 关键字用于实现接口。</p>\n<p>22：import： import 关键字用于导入对应的类或者接口。</p>\n<p>23：instanceof： instanceof 关键字用于判断对象是否属于某个类型（class）。</p>\n<p>24：int： int 关键字用于声明一个可以容纳 32 位带符号的整数变量。</p>\n<p>25：interface： interface 关键字用于声明接口——只能具有抽象方法。</p>\n<p>26：long： long 关键字用于声明一个可以容纳 64 位整数的变量。</p>\n<p>27：native： native 关键字用于指定一个方法是通过调用本机接口（非 Java）实现的。</p>\n<p>28：new： new 关键字用于创建一个新的对象。</p>\n<p>29：null： 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null。</p>\n<p>30：package： package 关键字用于声明类所在的包。</p>\n<p>31：private： private 关键字是一个访问修饰符，表示方法或变量只对当前类可见。</p>\n<p>32：protected： protected 关键字也是一个访问修饰符，表示方法或变量对同一包内的类和所有子类可见。</p>\n<p>33：public： public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。</p>\n<p>34：return： return 关键字用于在代码执行完成后返回（一个值）。</p>\n<p>35：short： short 关键字用于声明一个可以容纳 16 位整数的变量。</p>\n<p>36：static： static 关键字表示该变量或方法是静态变量或静态方法。</p>\n<p>37：strictfp：  strictfp 关键字并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。</p>\n<p>38：super： super 关键字可用于调用父类的方法或者变量。</p>\n<p>39：switch： switch 关键字通常用于三个（以上）的条件判断。</p>\n<p>40：synchronized： synchronized 关键字用于指定多线程代码中的同步方法、变量或者代码块。</p>\n<p>41：this： this 关键字可用于在方法或构造函数中引用当前对象。</p>\n<p>42：throw： throw 关键字主动抛出异常。</p>\n<p>43：throws： throws 关键字用于声明异常。</p>\n<p>44：transient： transient 关键字在序列化的使用用到，它修饰的字段不会被序列化。</p>\n<p>45：try： try 关键字用于包裹要捕获异常的代码块。</p>\n<p>46：void： void 关键字用于指定方法没有返回值。</p>\n<p>47：volatile： volatile 关键字保证了不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>\n<p>48：while： 如果循环次数不固定，建议使用 while 循环。<br><img src=\"https://www.qyihe.xyz/images/post/10.1.jpg\"></p>\n<h2 id=\"05、操作符\"><a href=\"#05、操作符\" class=\"headerlink\" title=\"05、操作符\"></a>05、操作符</h2><p>除去“=”赋值操作符，Java 中还有很多其他作用的操作符，我们来大致看一下。</p>\n<h3 id=\"①、算术运算符\"><a href=\"#①、算术运算符\" class=\"headerlink\" title=\"①、算术运算符\"></a>①、算术运算符</h3><ul>\n<li> +（加号）</li>\n<li> –（减号）</li>\n<li> *（乘号）</li>\n<li> /（除号）</li>\n<li> ％（取余）</li>\n</ul>\n<p>来看一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ArithmeticOperator &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a = 10;</span><br><span class=\"line\">        int b = 5;</span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(a + b);//15  </span><br><span class=\"line\">        System.out.println(a - b);//5  </span><br><span class=\"line\">        System.out.println(a * b);//50  </span><br><span class=\"line\">        System.out.println(a / b);//2  </span><br><span class=\"line\">        System.out.println(a % b);//0  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>“+”号比较特殊，还可以用于字符串拼接，来看一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String result = &quot;沉默王二&quot; + &quot;一枚有趣的程序员&quot;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"②、逻辑运算符\"><a href=\"#②、逻辑运算符\" class=\"headerlink\" title=\"②、逻辑运算符\"></a>②、逻辑运算符</h3><p>逻辑运算符通常用于布尔表达式，常见的有：</p>\n<ul>\n<li>&amp;&amp;（AND）多个条件中只要有一个为 false 结果就为 false</li>\n<li>||（OR）多个条件只要有一个为 true 结果就为 true</li>\n<li>!（NOT）条件如果为 true，加上“!”就为 false，否则，反之。</li>\n</ul>\n<p>来看一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LogicalOperator &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a=10;</span><br><span class=\"line\">        int b=5;</span><br><span class=\"line\">        int c=20;</span><br><span class=\"line\">        System.out.println(a&lt;b&amp;&amp;a&lt;c);//false</span><br><span class=\"line\">        System.out.println(a&gt;b||a&lt;c);//true</span><br><span class=\"line\">        System.out.println(!(a&lt;b)); // true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"③、比较运算符\"><a href=\"#③、比较运算符\" class=\"headerlink\" title=\"③、比较运算符\"></a>③、比较运算符</h3><ul>\n<li> &lt; (小于)</li>\n<li> &lt;= (小于或者等于)</li>\n<li><blockquote>\n<p>(大于)</p>\n</blockquote>\n</li>\n<li> &gt;= (大于或者等于)</li>\n<li> == (相等)</li>\n<li> != (不等)</li>\n</ul>\n<h2 id=\"06、程序结构\"><a href=\"#06、程序结构\" class=\"headerlink\" title=\"06、程序结构\"></a>06、程序结构</h2><p>Java 中最小的程序单元叫做类，一个类可以有一个或者多个字段（也叫作成员变量），还可以有一个或者多个方法，甚至还可以有一些内部类。<br>如果一个类想要执行，就必须有一个 main 方法——程序运行的入口，就好像人的嘴一样，嗯，可以这么牵强的理解一下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StructureProgram &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(&quot;没有成员变量，只有一个 main 方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类名叫做 StructureProgram，在它里面，只有一个 main 方法。</li>\n<li>{} 之间的代码称之为代码块。</li>\n<li>以上源代码将会保存在一个后缀名为 java 的文件中。</li>\n</ul>\n<h2 id=\"07、编译然后执行代码\"><a href=\"#07、编译然后执行代码\" class=\"headerlink\" title=\"07、编译然后执行代码\"></a>07、编译然后执行代码</h2><p>通常，一些教程在介绍这块内容的时候，建议你通过命令行中先执行 javac 命令将源代码编译成字节码文件，然后再执行 java 命令指定代码。<br>但我不希望这个糟糕的局面再继续下去了——新手安装配置 JDK 真的蛮需要勇气和耐心的，稍有不慎，没入门就先放弃了。况且，在命令行中编译源代码会遇到很多莫名其妙的错误，这对新手是极其致命的——如果你再遇到这种老式的教程，可以吐口水了。<br>好的方法，就是去下载 IntelliJ IDEA，简称 IDEA，它被业界公认为最好的 Java 集成开发工具，尤其在智能代码助手、代码自动提示、代码重构、代码版本管理(Git、SVN、Maven)、单元测试、代码分析等方面有着亮眼的发挥。IDEA 产于捷克（位于东欧），开发人员以严谨著称。IDEA 分为社区版和付费版两个版本，新手直接下载社区版就足够用了。<br>安装成功后，可以开始敲代码了，然后直接右键运行（连保存都省了），结果会在 Run 面板中显示，如下图所示。<br><img src=\"https://www.qyihe.xyz/images/post/10.2.jpg\"><br>想查看反编译后的字节码的话，可以在 src 的同级目录 target/classes 的包路径下找到一个 StructureProgram.class 的文件（如果找不到的话，在目录上右键选择「Reload from Disk」）。<br>可以双击打开它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class=\"line\">// (powered by Fernflower decompiler)</span><br><span class=\"line\">//</span><br><span class=\"line\"></span><br><span class=\"line\">package com.cmower.baeldung.basic;</span><br><span class=\"line\"></span><br><span class=\"line\">public class StructureProgram &#123;</span><br><span class=\"line\">    public StructureProgram() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(&quot;没有成员变量，只有一个 main 方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>IDEA 默认会用 Fernflower 将 class 字节码反编译为我们可以看得懂的 Java 代码。实际上，class 字节码（请安装 show bytecode 插件）长下面这个样子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// class version 57.65535 (-65479)</span><br><span class=\"line\">// access flags 0x21</span><br><span class=\"line\">public class com/cmower/baeldung/basic/StructureProgram &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // compiled from: StructureProgram.java</span><br><span class=\"line\"></span><br><span class=\"line\">  // access flags 0x1</span><br><span class=\"line\">  public &lt;init&gt;()V</span><br><span class=\"line\">   L0</span><br><span class=\"line\">    LINENUMBER 3 L0</span><br><span class=\"line\">    ALOAD 0</span><br><span class=\"line\">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class=\"line\">    RETURN</span><br><span class=\"line\">   L1</span><br><span class=\"line\">    LOCALVARIABLE this Lcom/cmower/baeldung/basic/StructureProgram; L0 L1 0</span><br><span class=\"line\">    MAXSTACK = 1</span><br><span class=\"line\">    MAXLOCALS = 1</span><br><span class=\"line\"></span><br><span class=\"line\">  // access flags 0x9</span><br><span class=\"line\">  public static main([Ljava/lang/String;)V</span><br><span class=\"line\">   L0</span><br><span class=\"line\">    LINENUMBER 5 L0</span><br><span class=\"line\">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class=\"line\">    LDC &quot;\\u6ca1\\u6709\\u6210\\u5458\\u53d8\\u91cf\\uff0c\\u53ea\\u6709\\u4e00\\u4e2a main \\u65b9\\u6cd5&quot;</span><br><span class=\"line\">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class=\"line\">   L1</span><br><span class=\"line\">    LINENUMBER 6 L1</span><br><span class=\"line\">    RETURN</span><br><span class=\"line\">   L2</span><br><span class=\"line\">    LOCALVARIABLE args [Ljava/lang/String; L0 L2 0</span><br><span class=\"line\">    MAXSTACK = 2</span><br><span class=\"line\">    MAXLOCALS = 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新手看起来还是有些懵逼的，建议过过眼瘾就行了。<br><img src=\"https://www.qyihe.xyz/images/post/10.3.jpg\"></p>\n<h1 id=\"二、Java-基本数据类型简介\"><a href=\"#二、Java-基本数据类型简介\" class=\"headerlink\" title=\"二、Java 基本数据类型简介\"></a>二、Java 基本数据类型简介</h1><h2 id=\"01、布尔\"><a href=\"#01、布尔\" class=\"headerlink\" title=\"01、布尔\"></a>01、布尔</h2><p>布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean flag = true;</span><br></pre></td></tr></table></figure>\n<h2 id=\"02、byte\"><a href=\"#02、byte\" class=\"headerlink\" title=\"02、byte\"></a>02、byte</h2><p>byte 的取值范围在 -128 和 127 之间，包含 127。最小值为 -128，最大值为 127，默认值为 0。<br>在网络传输的过程中，为了节省空间，常用字节来作为数据的传输方式。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte a = 10;</span><br><span class=\"line\">byte b = -10;</span><br></pre></td></tr></table></figure>\n<h2 id=\"03、short\"><a href=\"#03、short\" class=\"headerlink\" title=\"03、short\"></a>03、short</h2><p>short 的取值范围在 -32,768 和 32,767 之间，包含 32,767。最小值为 -32,768，最大值为 32,767，默认值为 0。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">short s = 10000;</span><br><span class=\"line\">short r = -5000;</span><br></pre></td></tr></table></figure>\n<h2 id=\"04、int\"><a href=\"#04、int\" class=\"headerlink\" title=\"04、int\"></a>04、int</h2><p>int 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间，默认值为 0。如果没有特殊需求，整形数据就用 int。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 100000;</span><br><span class=\"line\">int b = -200000;</span><br></pre></td></tr></table></figure>\n<h2 id=\"05、long\"><a href=\"#05、long\" class=\"headerlink\" title=\"05、long\"></a>05、long</h2><p>long 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间，默认值为 0。如果 int 存储不下，就用 long，整形数据就用 int。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long a = 100000L; </span><br><span class=\"line\">long b = -200000L;</span><br></pre></td></tr></table></figure>\n<p>为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。</p>\n<h2 id=\"06、float\"><a href=\"#06、float\" class=\"headerlink\" title=\"06、float\"></a>06、float</h2><p>float 是单精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围是无限的，默认值为 0.0f。float 不适合用于精确的数值，比如说货币。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float f1 = 234.5f;</span><br></pre></td></tr></table></figure>\n<p>为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。</p>\n<h2 id=\"07、double\"><a href=\"#07、double\" class=\"headerlink\" title=\"07、double\"></a>07、double</h2><p>double 是双精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围也是无限的，默认值为 0.0。double 同样不适合用于精确的数值，比如说货币。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double d1 = 12.3</span><br></pre></td></tr></table></figure>\n<p>那精确的数值用什么表示呢？最好使用 BigDecimal，它可以表示一个任意大小且精度完全准确的浮点数。针对货币类型的数值，也可以先乘以 100 转成整形进行处理。<br>Tips：单精度是这样的格式，1 位符号，8 位指数，23 位小数，有效位数为 7 位。<br><img src=\"https://www.qyihe.xyz/images/post/10.4.jpg\"><br>双精度是这样的格式，1 位符号，11 位指数，52 为小数，有效位数为 16 位。<br><img src=\"https://www.qyihe.xyz/images/post/10.5.jpg\"><br>取值范围取决于指数位，计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。</p>\n<blockquote>\n<p>一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。</p>\n</blockquote>\n<h2 id=\"08、char\"><a href=\"#08、char\" class=\"headerlink\" title=\"08、char\"></a>08、char</h2><p>char 可以表示一个 16 位的 Unicode 字符，其值范围在 ‘\\u0000’（0）和 ‘\\uffff’（65,535）（包含）之间。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char letterA = &#x27;A&#x27;; // 用英文的单引号包裹住。</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、Java-main-方法简介\"><a href=\"#三、Java-main-方法简介\" class=\"headerlink\" title=\"三、Java main() 方法简介\"></a>三、Java main() 方法简介</h1><p>每个程序都需要一个入口，对于 Java 程序来说，入口就是 main 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>public、static、void 这 3 个关键字在前面的内容已·经介绍过了，如果觉得回去找比较麻烦的话，这里再贴一下：</p>\n</li>\n<li><p>public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。</p>\n</li>\n<li><p>static 关键字表示该变量或方法是静态变量或静态方法，可以直接通过类访问，不需要实例化对象来访问。</p>\n</li>\n<li><p>void 关键字用于指定方法没有返回值。</p>\n</li>\n</ul>\n<p>另外，main 关键字为方法的名字，Java 虚拟机在执行程序时会寻找这个标识符；args 为 main() 方法的参数名，它的类型为一个 String 数组，也就是说，在使用 java 命令执行程序的时候，可以给 main() 方法传递字符串数组作为参数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java HelloWorld 沉默王二 沉默王三</span><br></pre></td></tr></table></figure>\n<p>javac 命令用来编译程序，java 命令用来执行程序，HelloWorld 为这段程序的类名，沉默王二和沉默王三为字符串数组，中间通过空格隔开，然后就可以在 main() 方法中通过 args[0] 和 args[1] 获取传递的参数值了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HelloWorld &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        if (&quot;沉默王二&quot;.equals(args[0])) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (&quot;沉默王三&quot;.equals(args[1])) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>main() 方法的写法并不是唯一的，还有其他几种变体，尽管它们可能并不常见，可以简单来了解一下。</p>\n<p>第二种，把方括号 [] 往 args 靠近而不是 String 靠近：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String []args) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三种，把方括号 [] 放在 args 的右侧：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String args[]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第四种，还可以把数组形式换成可变参数的形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String...args) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第五种，在 main() 方法上添加另外一个修饰符 strictfp，用于强调在处理浮点数时的兼容性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public strictfp static void main(String[] args) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以在 main() 方法上添加 final 关键字或者 synchronized 关键字。</p>\n<p>第六种，还可以为 args 参数添加 final 关键字：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(final String[] args) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第七种，最复杂的一种，所有可以添加的关键字统统添加上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final static synchronized strictfp void main(final String[] args) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然了，并不需要为了装逼特意把 main() 方法写成上面提到的这些形式，使用 IDE 提供的默认形式就可以了。</p>\n<h1 id=\"四、Java-的流程控制语句\"><a href=\"#四、Java-的流程控制语句\" class=\"headerlink\" title=\"四、Java 的流程控制语句\"></a>四、Java 的流程控制语句</h1><ul>\n<li><p>在 Java 中，有三种类型的流程控制语句：</p>\n</li>\n<li><p>条件分支，用于在两个或者多个条件之间做出选择，常见的有 if/else/else if、三元运算符和 switch 语句。</p>\n</li>\n<li><p>循环或者遍历，常见的有 for、while 和 do-while。</p>\n</li>\n<li><p>break 和 continue，用于跳出循环或者跳过进入下一轮循环。</p>\n</li>\n</ul>\n<h2 id=\"if-语句\"><a href=\"#if-语句\" class=\"headerlink\" title=\"if 语句\"></a>if 语句</h2><p>if 语句的格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(布尔表达式)&#123;  </span><br><span class=\"line\">// 如果条件为 true，则执行这块代码</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>画个流程图表示一下：<br><img src=\"https://www.qyihe.xyz/images/post/10.6.jpg\"><br>来写个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class IfExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age = 20;</span><br><span class=\"line\">        if (age &lt; 30) &#123;</span><br><span class=\"line\">            System.out.println(&quot;青春年华&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">青春年华</span><br></pre></td></tr></table></figure>\n<h2 id=\"if-else-语句\"><a href=\"#if-else-语句\" class=\"headerlink\" title=\"if-else 语句\"></a>if-else 语句</h2><p>if-else 语句的格式如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(布尔表达式)&#123;  </span><br><span class=\"line\">// 条件为 true 时执行的代码块</span><br><span class=\"line\">&#125;else&#123;  </span><br><span class=\"line\">// 条件为 false  时执行的代码块</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>画个流程图表示一下：<br><img src=\"https://www.qyihe.xyz/images/post/10.7.jpg\"><br>来写个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class IfElseExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age = 31;</span><br><span class=\"line\">        if (age &lt; 30) &#123;</span><br><span class=\"line\">            System.out.println(&quot;青春年华&quot;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            System.out.println(&quot;而立之年&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">而立之年</span><br></pre></td></tr></table></figure>\n<p>除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LeapYear &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int year = 2020;</span><br><span class=\"line\">        if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &#123;</span><br><span class=\"line\">            System.out.println(&quot;闰年&quot;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            System.out.println(&quot;普通年份&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">闰年</span><br></pre></td></tr></table></figure>\n<p>如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class IfElseTernaryExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int num = 13;</span><br><span class=\"line\">        String result = (num % 2 == 0) ? &quot;偶数&quot; : &quot;奇数&quot;;</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">奇数</span><br></pre></td></tr></table></figure>\n<h2 id=\"if-else-if-语句\"><a href=\"#if-else-if-语句\" class=\"headerlink\" title=\"if-else-if 语句\"></a>if-else-if 语句</h2><p>if-else-if 语句的格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(条件1)&#123;  </span><br><span class=\"line\">// 条件1 为 true 时执行的代码</span><br><span class=\"line\">&#125;else if(条件2)&#123;  </span><br><span class=\"line\">// 条件2 为 true 时执行的代码</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">else if(条件3)&#123;  </span><br><span class=\"line\">// 条件3 为 true 时执行的代码</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">...  </span><br><span class=\"line\">else&#123;  </span><br><span class=\"line\">// 以上条件均为 false 时执行的代码</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>画个流程图表示一下：<br><img src=\"https://www.qyihe.xyz/images/post/10.8.jpg\"><br>来写个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class IfElseIfExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age = 31;</span><br><span class=\"line\">        if (age &lt; 30) &#123;</span><br><span class=\"line\">            System.out.println(&quot;青春年华&quot;);</span><br><span class=\"line\">        &#125; else if (age &gt;= 30 &amp;&amp; age &lt; 40 ) &#123;</span><br><span class=\"line\">            System.out.println(&quot;而立之年&quot;);</span><br><span class=\"line\">        &#125; else if (age &gt;= 40 &amp;&amp; age &lt; 50 ) &#123;</span><br><span class=\"line\">            System.out.println(&quot;不惑之年&quot;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            System.out.println(&quot;知天命&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">而立之年</span><br></pre></td></tr></table></figure>\n<h2 id=\"if-嵌套语句\"><a href=\"#if-嵌套语句\" class=\"headerlink\" title=\"if 嵌套语句\"></a>if 嵌套语句</h2><p>if 嵌套语句的格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(外侧条件)&#123;    </span><br><span class=\"line\">     // 外侧条件为 true 时执行的代码 </span><br><span class=\"line\">          if(内侧条件)&#123;  </span><br><span class=\"line\">             // 内侧条件为 true 时执行的代码</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>画个流程图表示一下：<br><img src=\"https://www.qyihe.xyz/images/post/10.9.jpg\"><br>来写个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class NestedIfExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age = 20;</span><br><span class=\"line\">        boolean isGirl = true;</span><br><span class=\"line\">        if (age &gt;= 20) &#123;</span><br><span class=\"line\">            if (isGirl) &#123;</span><br><span class=\"line\">                System.out.println(&quot;女生法定结婚年龄&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">女生法定结婚年龄</span><br></pre></td></tr></table></figure>\n<h2 id=\"switch-语句的格式：\"><a href=\"#switch-语句的格式：\" class=\"headerlink\" title=\"switch 语句的格式：\"></a>switch 语句的格式：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(变量) &#123;    </span><br><span class=\"line\">case 可选值1:    </span><br><span class=\"line\"> // 可选值1匹配后执行的代码;    </span><br><span class=\"line\"> break;  // 该关键字是可选项</span><br><span class=\"line\">case 可选值2:    </span><br><span class=\"line\"> // 可选值2匹配后执行的代码;    </span><br><span class=\"line\"> break;  // 该关键字是可选项</span><br><span class=\"line\">......    </span><br><span class=\"line\">    </span><br><span class=\"line\">default: // 该关键字是可选项     </span><br><span class=\"line\"> // 所有可选值都不匹配后执行的代码 </span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>变量可以有 1 个或者 N 个值。</p>\n</li>\n<li><p>值类型必须和变量类型是一致的，并且值是确定的。</p>\n</li>\n<li><p>值必须是唯一的，不能重复，否则编译会出错。</p>\n</li>\n<li><p>break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。</p>\n</li>\n<li><p>default 关键字也是可选的。<br><img src=\"https://www.qyihe.xyz/images/post/10.10.jpg\"><br>画个流程图：</p>\n</li>\n</ul>\n<p>来个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Switch1 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age = 20;</span><br><span class=\"line\">        switch (age) &#123;</span><br><span class=\"line\">            case 20 :</span><br><span class=\"line\">                System.out.println(&quot;上学&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case 24 :</span><br><span class=\"line\">                System.out.println(&quot;苏州工作&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case 30 :</span><br><span class=\"line\">                System.out.println(&quot;洛阳工作&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                System.out.println(&quot;未知&quot;);</span><br><span class=\"line\">                break; // 可省略</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上学</span><br></pre></td></tr></table></figure>\n<p>当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Switch2 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String name = &quot;沉默王二&quot;;</span><br><span class=\"line\">        switch (name) &#123;</span><br><span class=\"line\">            case &quot;詹姆斯&quot;:</span><br><span class=\"line\">                System.out.println(&quot;篮球运动员&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;穆里尼奥&quot;:</span><br><span class=\"line\">                System.out.println(&quot;足球教练&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;沉默王二&quot;:</span><br><span class=\"line\">            case &quot;沉默王三&quot;:</span><br><span class=\"line\">                System.out.println(&quot;乒乓球爱好者&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                throw new IllegalArgumentException(</span><br><span class=\"line\">                        &quot;名字没有匹配项&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">乒乓球爱好者</span><br></pre></td></tr></table></figure>\n<p>枚举作为 switch 语句的变量也很常见，来看例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SwitchEnumDemo &#123;</span><br><span class=\"line\">    public enum PlayerTypes &#123;</span><br><span class=\"line\">        TENNIS,</span><br><span class=\"line\">        FOOTBALL,</span><br><span class=\"line\">        BASKETBALL,</span><br><span class=\"line\">        UNKNOWN</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(createPlayer(PlayerTypes.BASKETBALL));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static String createPlayer(PlayerTypes playerType) &#123;</span><br><span class=\"line\">        switch (playerType) &#123;</span><br><span class=\"line\">            case TENNIS:</span><br><span class=\"line\">                return &quot;网球运动员费德勒&quot;;</span><br><span class=\"line\">            case FOOTBALL:</span><br><span class=\"line\">                return &quot;足球运动员C罗&quot;;</span><br><span class=\"line\">            case BASKETBALL:</span><br><span class=\"line\">                return &quot;篮球运动员詹姆斯&quot;;</span><br><span class=\"line\">            case UNKNOWN:</span><br><span class=\"line\">                throw new IllegalArgumentException(&quot;未知&quot;);</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                throw new IllegalArgumentException(</span><br><span class=\"line\">                        &quot;运动员类型: &quot; + playerType);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">篮球运动员詹姆斯</span><br></pre></td></tr></table></figure>\n<h2 id=\"循环语句比较\"><a href=\"#循环语句比较\" class=\"headerlink\" title=\"循环语句比较\"></a>循环语句比较</h2><table>\n<thead>\n<tr>\n<th>比较方式</th>\n<th>for</th>\n<th>while</th>\n<th>do-while</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>简介</td>\n<td>for 循环的次数是固定的</td>\n<td>while 循环的次数是不固定的，并且需要条件为 true</td>\n<td>do-while 循环的次数也不固定，但会至少执行一次循环，无聊条件是否为 true</td>\n</tr>\n<tr>\n<td>何时使用</td>\n<td>循环次数固定的</td>\n<td>循环次数是不固定的</td>\n<td>循环次数不固定，并且循环体至少要执行一次</td>\n</tr>\n<tr>\n<td>语法</td>\n<td>for(init:condition;++/–) {// 要执行的代码}</td>\n<td>while(condition){// 要执行的代码}</td>\n<td>do{//要执行的代码}while(condition);</td>\n</tr>\n</tbody></table>\n<h2 id=\"普通的-for-循环\"><a href=\"#普通的-for-循环\" class=\"headerlink\" title=\"普通的 for 循环\"></a>普通的 for 循环</h2><p>普通的 for 循环可以分为 4 个部分：<br>（1）初始变量：循环开始执行时的初始条件。<br>（2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。<br>（3）循环体：循环每次要执行的代码块，直到条件变为 false。<br>（4）自增/自减：初识变量变化的方式。<br>来看一下普通 for 循环的格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(初识变量;条件;自增/自减)&#123;  </span><br><span class=\"line\">// 循环体</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>画个流程图：<br><img src=\"https://www.qyihe.xyz/images/post/10.11.jpg\"><br>来个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ForExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">            System.out.println(&quot;沉默王二好帅啊&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">沉默王二好帅啊</span><br><span class=\"line\">沉默王二好帅啊</span><br><span class=\"line\">沉默王二好帅啊</span><br><span class=\"line\">沉默王二好帅啊</span><br><span class=\"line\">沉默王二好帅啊</span><br></pre></td></tr></table></figure>\n<p>循环语句还可以嵌套呢，这样就可以打印出更好玩的呢。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PyramidForExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">            for (int j = 0;j&lt;= i;j++) &#123;</span><br><span class=\"line\">                System.out.print(&quot;❤&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印出什么玩意呢？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">❤</span><br><span class=\"line\">❤❤</span><br><span class=\"line\">❤❤❤</span><br><span class=\"line\">❤❤❤❤</span><br><span class=\"line\">❤❤❤❤❤</span><br></pre></td></tr></table></figure>\n<h2 id=\"for-each\"><a href=\"#for-each\" class=\"headerlink\" title=\"for-each\"></a>for-each</h2><p>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(元素类型 元素 : 数组或集合)&#123;  </span><br><span class=\"line\">// 要执行的代码</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>来看一下示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ForEachExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String[] strs = &#123;&quot;沉默王二&quot;, &quot;一枚有趣的程序员&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (String str : strs) &#123;</span><br><span class=\"line\">            System.out.println(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">沉默王二</span><br><span class=\"line\">一枚有趣的程序员</span><br></pre></td></tr></table></figure>\n<h2 id=\"无限-for-循环\"><a href=\"#无限-for-循环\" class=\"headerlink\" title=\"无限 for 循环\"></a>无限 for 循环</h2><p>想不想体验一下无限 for 循环的威力，也就是死循环？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class InfinitiveForExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for(;;)&#123;</span><br><span class=\"line\">            System.out.println(&quot;停不下来。。。。&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">停不下来。。。。</span><br><span class=\"line\">停不下来。。。。</span><br><span class=\"line\">停不下来。。。。</span><br><span class=\"line\">停不下来。。。。</span><br></pre></td></tr></table></figure>\n<p>一旦运行起来，就停不下来了，除非强制停止。</p>\n<h2 id=\"while-循环\"><a href=\"#while-循环\" class=\"headerlink\" title=\"while 循环\"></a>while 循环</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(条件)&#123;  </span><br><span class=\"line\">//循环体  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>画个流程图：<br><img src=\"https://www.qyihe.xyz/images/post/10.12.jpg\"><br>来个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WhileExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int i = 0;</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            System.out.println(&quot;沉默王二&quot;);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            if (i == 5) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>猜猜会输出几次？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br></pre></td></tr></table></figure>\n<h2 id=\"do-while-循环\"><a href=\"#do-while-循环\" class=\"headerlink\" title=\"do-while 循环\"></a>do-while 循环</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do&#123;  </span><br><span class=\"line\">// 循环体</span><br><span class=\"line\">&#125;while(提交); </span><br></pre></td></tr></table></figure>\n<p>画个流程图：<br><img src=\"https://www.qyihe.xyz/images/post/10.13.jpg\"><br>来个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DoWhileExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int i = 0;</span><br><span class=\"line\">        do &#123;</span><br><span class=\"line\">            System.out.println(&quot;沉默王二&quot;);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            if (i == 5) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; while (true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序输出结果如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br></pre></td></tr></table></figure>\n<h2 id=\"break\"><a href=\"#break\" class=\"headerlink\" title=\"break\"></a>break</h2><p>break 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。<br>可以将 break 关键字用于所有类型循环语句中，比如说 for 循环，while 循环，以及 do-while 循环。<br>来画个流程图感受一下：<br><img src=\"https://www.qyihe.xyz/images/post/10.14.jpg\"><br>用在 for 循环中的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class=\"line\">    if (i == 5) &#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用在嵌套 for 循环中的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class=\"line\">    for (int j = 1; j &lt;= 3; j++) &#123;</span><br><span class=\"line\">        if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(i + &quot; &quot; + j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用在 while 循环中的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 1;</span><br><span class=\"line\">while (i &lt;= 10) &#123;</span><br><span class=\"line\">    if (i == 5) &#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(i);</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用在 do-while 循环中的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int j = 1;</span><br><span class=\"line\">do &#123;</span><br><span class=\"line\">    if (j == 5) &#123; </span><br><span class=\"line\">        j++;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(j);</span><br><span class=\"line\">    j++;</span><br><span class=\"line\">&#125; while (j &lt;= 10);</span><br></pre></td></tr></table></figure>\n<h2 id=\"continue\"><a href=\"#continue\" class=\"headerlink\" title=\"continue\"></a>continue</h2><p>当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。<br>来个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ContinueDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class=\"line\">            if (i == 5) &#123;</span><br><span class=\"line\">                // 使用 continue 关键字</span><br><span class=\"line\">                continue;// 5 将会被跳过</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>5 真的被跳过了。<br>再来个循环嵌套的例子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ContinueInnerDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class=\"line\">            for (int j = 1; j &lt;= 3; j++) &#123;</span><br><span class=\"line\">                if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class=\"line\">                    //  当i=2，j=2时跳过</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(i + &quot; &quot; + j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印出什么玩意呢？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 1</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 3</span><br><span class=\"line\">2 1</span><br><span class=\"line\">2 3</span><br><span class=\"line\">3 1</span><br><span class=\"line\">3 2</span><br><span class=\"line\">3 3</span><br></pre></td></tr></table></figure>\n<p>“2 2” 没有输出，被跳过了。<br>再来看一下 while 循环时 continue 的使用示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ContinueWhileDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int i = 1;</span><br><span class=\"line\">        while (i &lt;= 10) &#123;</span><br><span class=\"line\">            if (i == 5) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。<br>最后，再来看一下 do-while 循环时 continue 的使用示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ContinueDoWhileDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int i=1;</span><br><span class=\"line\">        do&#123;</span><br><span class=\"line\">            if(i==5)&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;while(i&lt;=10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p>\n<h1 id=\"五、Java-包的简介\"><a href=\"#五、Java-包的简介\" class=\"headerlink\" title=\"五、Java 包的简介\"></a>五、Java 包的简介</h1><p>在 Java 中，我们使用 package（包）对相关的类、接口和子包进行分组。这样做的好处有：</p>\n<ul>\n<li>使相关类型更容易查找</li>\n<li>避免命名冲突，比如说 com.itwanger.Hello 和 com.itwangsan.Hello 不同</li>\n<li>通过包和访问权限控制符来限定类的可见性</li>\n</ul>\n<h2 id=\"01、创建一个包\"><a href=\"#01、创建一个包\" class=\"headerlink\" title=\"01、创建一个包\"></a>01、创建一个包</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.itwanger;</span><br></pre></td></tr></table></figure>\n<p>可以使用 package 关键字来定义一个包名，需要注意的是，这行代码必须处于一个类中的第一行。强烈建议在包中声明类，不要缺省，否则就失去了包结构的带来的好处。<br>包的命名应该遵守以下规则：</p>\n<ul>\n<li>应该全部是小写字母</li>\n<li>可以包含多个单词，单词之间使用“.”连接，比如说 java.lang</li>\n<li>名称由公司名或者组织名确定，采用倒序的方式，比如说，我个人博客的域名是 <a href=\"http://www.itwanger.com,所以我创建的包名是就是/\">www.itwanger.com，所以我创建的包名是就是</a> com.itwanger.xxxx。</li>\n</ul>\n<p>每个包或者子包都在磁盘上有自己的目录结构，如果 Java 文件时在 com.itwanger.xxxx 包下，那么该文件所在的目录结构就应该是 com-&gt;itwanger-&gt;xxxx。</p>\n<h2 id=\"02、使用包\"><a href=\"#02、使用包\" class=\"headerlink\" title=\"02、使用包\"></a>02、使用包</h2><p>让我们在名为 test 的子包里新建一个 Cmower 类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.itwanger.test;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Cmower &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果需要在另外一个包中使用 Cmower 类，就需要通过 import 关键字将其引入。有两种方式可供选择，第一种，使用 * 导入包下所有的类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.itwanger.test.*;</span><br></pre></td></tr></table></figure>\n<p>第二种，使用类名导入该类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.itwanger.test.Cmower;</span><br></pre></td></tr></table></figure>\n<p>Java 和第三方类库提供了很多包可供使用，可以通过上述的方式导入类库使用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.itwanger.test;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class CmowerTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List&lt;Cmower&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(new Cmower());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"03、全名\"><a href=\"#03、全名\" class=\"headerlink\" title=\"03、全名\"></a>03、全名</h2><p>有时，我们可能会使用来自不同包下的两个具有相同名称的类。例如，我们可能同时使用 java.sql.Date 和 java.util.Date。当我们遇到命名冲突时，我们需要对至少一个类使用全名（包名+类名）。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>list1 </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.add(new com.itwanger.test.Cmower());</span><br></pre></td></tr></table></figure>\n<h1 id=\"六、Java-到底是值传递还是引用传递\"><a href=\"#六、Java-到底是值传递还是引用传递\" class=\"headerlink\" title=\"六、Java 到底是值传递还是引用传递\"></a>六、Java 到底是值传递还是引用传递</h1><p>将参数传递给方法有两种常见的方式，一种是“值传递”，一种是“引用传递”。C 语言本身只支持值传递，它的衍生品 C++ 既支持值传递，也支持引用传递，而 Java 只支持值传递。</p>\n<h2 id=\"01、值传递-VS-引用传递\"><a href=\"#01、值传递-VS-引用传递\" class=\"headerlink\" title=\"01、值传递 VS 引用传递\"></a>01、值传递 VS 引用传递</h2><p>首先，我们必须要搞清楚，到底什么是值传递，什么是引用传递，否则，讨论 Java 到底是值传递还是引用传递就显得毫无意义。<br>当一个参数按照值的方式在两个方法之间传递时，调用者和被调用者其实是用的两个不同的变量——被调用者中的变量（原始值）是调用者中变量的一份拷贝，对它们当中的任何一个变量修改都不会影响到另外一个变量。<br>而当一个参数按照引用传递的方式在两个方法之间传递时，调用者和被调用者其实用的是同一个变量，当该变量被修改时，双方都是可见的。<br>Java 程序员之所以容易搞混值传递和引用传递，主要是因为 Java 有两种数据类型，一种是基本类型，比如说 int，另外一种是引用类型，比如说 String。<br>基本类型的变量存储的都是实际的值，而引用类型的变量存储的是对象的引用——指向了对象在内存中的地址。值和引用存储在 stack（栈）中，而对象存储在 heap（堆）中。<br><img src=\"https://www.qyihe.xyz/images/post/10.15.jpg\"><br>之所以有这个区别，是因为：</p>\n<ul>\n<li>栈的优势是，存取速度比堆要快，仅次于直接位于 CPU 中的寄存器。但缺点是，栈中的数据大小与生存周期必须是确定的。</li>\n<li>堆的优势是可以动态地分配内存大小，生存周期也不必事先告诉编译器，Java 的垃圾回收器会自动收走那些不再使用的数据。但由于要在运行时动态分配内存，存取速度较慢。</li>\n</ul>\n<h2 id=\"02、基本类型的参数传递\"><a href=\"#02、基本类型的参数传递\" class=\"headerlink\" title=\"02、基本类型的参数传递\"></a>02、基本类型的参数传递</h2><p>众所周知，Java 有 8 种基本数据类型，分别是 int、long、byte、short、float、double 、char 和 boolean。它们的值直接存储在栈中，每当作为参数传递时，都会将原始值（实参）复制一份新的出来，给形参用。形参将会在被调用方法结束时从栈中清除。<br>来看下面这段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PrimitiveTypeDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age = 18;</span><br><span class=\"line\">        modify(age);</span><br><span class=\"line\">        System.out.println(age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void modify(int age1) &#123;</span><br><span class=\"line\">        age1 = 30;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（1）main 方法中的 age 是基本类型，所以它的值 18 直接存储在栈中。<br>（2）调用 modify() 方法的时候，将为实参 age 创建一个副本（形参 age1），它的值也为 18，不过是在栈中的其他位置。<br>（3）对形参 age 的任何修改都只会影响它自身而不会影响实参。<br><img src=\"https://www.qyihe.xyz/images/post/10.16.jpg\"></p>\n<h2 id=\"03、引用类型的参数传递\"><a href=\"#03、引用类型的参数传递\" class=\"headerlink\" title=\"03、引用类型的参数传递\"></a>03、引用类型的参数传递</h2><p>来看一段创建引用类型变量的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer writer = new Writer(18, &quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>\n<p>writer 是对象吗？还是对象的引用？为了搞清楚这个问题，我们可以把上面的代码拆分为两行代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer writer;</span><br><span class=\"line\">writer = new Writer(18, &quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>\n<p>假如 writer 是对象的话，就不需要通过 new 关键字创建对象了，对吧？那也就是说，writer 并不是对象，在“=”操作符执行之前，它仅仅是一个变量。那谁是对象呢？new Writer(18, “沉默王二”)，它是对象，存储于堆中；然后，“=”操作符将对象的引用赋值给了 writer 变量，于是 writer 此时应该叫对象引用，它存储在栈中，保存了对象在堆中的地址。<br>每当引用类型作为参数传递时，都会创建一个对象引用（实参）的副本（形参），该形参保存的地址和实参一样。<br>来看下面这段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReferenceTypeDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Writer a = new Writer(18);</span><br><span class=\"line\">        Writer b = new Writer(18);</span><br><span class=\"line\">        modify(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(a.getAge());</span><br><span class=\"line\">        System.out.println(b.getAge());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void modify(Writer a1, Writer b1) &#123;</span><br><span class=\"line\">        a1.setAge(30);</span><br><span class=\"line\"></span><br><span class=\"line\">        b1 = new Writer(18);</span><br><span class=\"line\">        b1.setAge(30);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（1）在调用 modify() 方法之前，实参 a 和 b 指向的对象是不一样的，尽管 age 都为 18。<br><img src=\"https://www.qyihe.xyz/images/post/10.17.jpg\"><br>（2）在调用 modify() 方法时，实参 a 和 b 都在栈中创建了一个新的副本，分别是 a1 和 b1，但指向的对象是一致的（a 和 a1 指向对象 a，b 和 b1 指向对象 b）。<br><img src=\"https://www.qyihe.xyz/images/post/10.18.jpg\"><br>（3）在 modify() 方法中，修改了形参 a1 的 age 为 30，意味着对象 a 的 age 从 18 变成了 30，而实参 a 指向的也是对象 a，所以 a 的 age 也变成了 30；形参 b1 指向了一个新的对象，随后 b1 的 age 被修改为 30。<br><img src=\"https://www.qyihe.xyz/images/post/10.19.jpg\"><br>修改 a1 的 age，意味着同时修改了 a 的 age，因为它们指向的对象是一个；修改 b1 的 age，对 b 却没有影响，因为它们指向的对象是两个。<br>程序输出的结果如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30</span><br><span class=\"line\">18</span><br></pre></td></tr></table></figure>\n<p>果然和我们的分析是吻合的。</p>\n<h1 id=\"七、Java-的类和对象\"><a href=\"#七、Java-的类和对象\" class=\"headerlink\" title=\"七、Java 的类和对象\"></a>七、Java 的类和对象</h1><p>类和对象是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。对象可以是现实中看得见的任何物体（一只特立独行的猪），也可以是想象中的任何虚拟物体（能七十二变的孙悟空），Java 通过类（class）来定义这些物体，有什么状态（通过字段，或者叫成员变量定义，比如说猪的颜色是纯色还是花色），有什么行为（通过方法定义，比如说猪会吃，会睡觉）。<br>来，让我来定义一个简单的类给你看看。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pig &#123;</span><br><span class=\"line\">    private String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;吃&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认情况下，每个 Java 类都会有一个空的构造方法，尽管它在源代码中是缺省的，但却可以通过反编译字节码看到它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pig &#123;</span><br><span class=\"line\">    private String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Pig() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;吃&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>没错，就是多出来的那个 public Pig() {}，参数是空的，方法体是空的。我们可以通过 new 关键字利用这个构造方法来创建一个对象，代码如下所示：<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pig pig = new Pig();</span><br></pre></td></tr></table></figure><br>当然了，我们也可以主动添加带参的构造方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pig &#123;</span><br><span class=\"line\">    private String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Pig(String color) &#123;</span><br><span class=\"line\">        this.color = color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;吃&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候，再查看反编译后的字节码时，你会发现缺省的无参构造方法消失了——和源代码一模一样。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pig &#123;</span><br><span class=\"line\">    private String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Pig(String color) &#123;</span><br><span class=\"line\">        this.color = color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;吃&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这意味着无法通过 new Pig() 来创建对象了——编译器会提醒你追加参数。<br><img src=\"https://www.qyihe.xyz/images/post/10.20.jpg\"><br>比如说你将代码修改为 new Pig(“纯白色”)，或者添加无参的构造方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pig &#123;</span><br><span class=\"line\">    private String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Pig(String color) &#123;</span><br><span class=\"line\">        this.color = color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Pig() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;吃&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用无参构造方法创建的对象状态默认值为 null（color 字符串为引用类型），如果是基本类型的话，默认值为对应基本类型的默认值，比如说 int 为 0，更详细的见下图。<br><img src=\"https://www.qyihe.xyz/images/post/10.21.jpg\"><br>（图片中有一处错误，boolean 的默认值为 false）<br>接下来，我们来创建多个 Pig 对象，它的颜色各不相同。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PigTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Pig pigNoColor = new Pig();</span><br><span class=\"line\">        Pig pigWhite = new Pig(&quot;纯白色&quot;);</span><br><span class=\"line\">        Pig pigBlack = new Pig(&quot;纯黑色&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你看，我们创建了 3 个不同花色的 Pig 对象，全部来自于一个类，由此可见类的重要性，只需要定义一次，就可以多次使用。<br>那假如我想改变对象的状态呢？该怎么办？目前毫无办法，因为没有任何可以更改状态的方法，直接修改 color 是行不通的，因为它的访问权限修饰符是 private 的。<br>最好的办法就是为 Pig 类追加 getter/setter 方法，就像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String getColor() &#123;</span><br><span class=\"line\">    return color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void setColor(String color) &#123;</span><br><span class=\"line\">    this.color = color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 setColor() 方法来修改，通过 getColor() 方法获取状态，它们的权限修饰符是 public 的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pig pigNoColor = new Pig();</span><br><span class=\"line\">pigNoColor.setColor(&quot;花色&quot;);</span><br><span class=\"line\">System.out.println(pigNoColor.getColor()); // 花色</span><br></pre></td></tr></table></figure>\n<p>为什么要这样设计呢？可以直接将 color 字段的访问权限修饰符换成是 public 的啊，不就和 getter/setter 一样的效果了吗？<br>因为有些情况，某些字段是不允许被随意修改的，它只有在对象创建的时候初始化一次，比如说猪的年龄，它只能每年长一岁（举个例子），没有月光宝盒让它变回去。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">public int getAge() &#123;</span><br><span class=\"line\">    return age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void increaseAge() &#123;</span><br><span class=\"line\">    this.age++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你看，age 就没有 setter 方法，只有一个每年可以调用一次的 increaseAge() 方法和 getter 方法。如果把 age 的访问权限修饰符更改为 public，age 就完全失去控制了，可以随意将其重置为 0 或者负数。<br>访问权限修饰符对于 Java 来说，非常重要，目前共有四种：public、private、protected 和 default（缺省）。<br>一个类只能使用 public 或者 default 修饰，public 修饰的类你之前已经见到过了，现在我来定义一个缺省权限修饰符的类给你欣赏一下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Dog &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>哈哈，其实也没啥可以欣赏的。缺省意味着这个类可以被同一个包下的其他类进行访问；而 public 意味着这个类可以被所有包下的类进行访问。<br>假如硬要通过 private 和 protected 来修饰类的话，编译器会生气的，它不同意。<br><img src=\"https://www.qyihe.xyz/images/post/10.22.jpg\"><br>private 可以用来修饰类的构造方法、字段和方法，只能被当前类进行访问。protected 也可以用来修饰类的构造方法、字段和方法，但它的权限范围更宽一些，可以被同一个包中的类进行访问，或者当前类的子类。<br>可以通过下面这张图来对比一下四个权限修饰符之间的差别：<br><img src=\"https://www.qyihe.xyz/images/post/10.23.jpg\"></p>\n<ul>\n<li><p>同一个类中，不管是哪种权限修饰符，都可以访问；</p>\n</li>\n<li><p>同一个包下，private 修饰的无法访问；</p>\n</li>\n<li><p>子类可以访问 public 和 protected 修饰的；</p>\n</li>\n<li><p>public 修饰符面向世界，哈哈，可以被所有的地方访问到。<br><img src=\"https://www.qyihe.xyz/images/post/10.24.jpg\"></p>\n<h1 id=\"八、Java-构造方法\"><a href=\"#八、Java-构造方法\" class=\"headerlink\" title=\"八、Java 构造方法\"></a>八、Java 构造方法</h1><p>假设现在有一个 Writer 类，它有两个字段，姓名和年纪：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Writer &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Writer&#123;&quot; +</span><br><span class=\"line\">                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +</span><br><span class=\"line\">                &quot;, age=&quot; + age +</span><br><span class=\"line\">                &#x27;&#125;&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重写了 toString() 方法，用于打印 Writer 类的详情。由于没有构造方法，意味着当我们创建 Writer 对象时，它的字段值并没有初始化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer writer = new Writer();</span><br><span class=\"line\">System.out.println(writer.toString());</span><br></pre></td></tr></table></figure>\n<p>输出结果如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer&#123;name=&#x27;null&#x27;, age=0&#125;</span><br></pre></td></tr></table></figure>\n<p>name 是字符串类型，所以默认值为 null，age 为 int 类型，所以默认值为 0。<br>让我们为 Writer 类主动加一个无参的构造方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Writer() &#123;</span><br><span class=\"line\">    this.name = &quot;&quot;;</span><br><span class=\"line\">    this.age = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造方法也是一个方法，只不过它没有返回值，默认返回创建对象的类型。需要注意的是，当前构造方法没有参数，它被称为无参构造方法。如果我们没有主动创建无参构造方法的话，编译器会隐式地自动添加一个无参的构造方法。这就是为什么，一开始虽然没有构造方法，却可以使用 new Writer() 创建对象的原因，只不过，所有的字段都被初始化成了默认值。<br>接下来，让我们添加一个有参的构造方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Writer(String name, int age) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们创建 Writer 对象的时候就可以通过对字段值初始化值了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer writer1 = new Writer(&quot;沉默王二&quot;,18);</span><br><span class=\"line\">System.out.println(writer1.toString());</span><br></pre></td></tr></table></figure>\n<p>来看一下打印结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer&#123;name=&#x27;沉默王二&#x27;, age=18&#125;</span><br></pre></td></tr></table></figure>\n<p>可以根据字段的数量添加不同参数数量的构造方法，比如说，我们可以单独为 name 字段添加一个构造方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Writer(String name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能够兼顾 age 字段，我们可以通过 this 关键字调用其他的构造方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Writer(String name) &#123;</span><br><span class=\"line\">    this(name,18);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把作者的年龄都默认初始化为 18。如果需要使用父类的构造方法，还可以使用 super 关键字，手册后面有详细的介绍。</p>\n<h1 id=\"九、Java-抽象类\"><a href=\"#九、Java-抽象类\" class=\"headerlink\" title=\"九、Java 抽象类\"></a>九、Java 抽象类</h1><p>当我们要完成的任务是确定的，但具体的方式需要随后开个会投票的话，Java 的抽象类就派上用场了。这句话怎么理解呢？搬个小板凳坐好，听我来给你讲讲。<br><img src=\"https://www.qyihe.xyz/images/post/10.25.jpg\"></p>\n<h2 id=\"01、抽象类的-5-个关键点\"><a href=\"#01、抽象类的-5-个关键点\" class=\"headerlink\" title=\"01、抽象类的 5 个关键点\"></a>01、抽象类的 5 个关键点</h2><p>（1）定义抽象类的时候需要用到关键字 abstract，放在 class 关键字前。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractPlayer &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于抽象类的命名，阿里出品的 Java 开发手册上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，记住了哦。<br>（2）抽象类不能被实例化，但可以有子类。<br>尝试通过 new 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。<br><img src=\"https://www.qyihe.xyz/images/post/10.26.jpg\"><br>通过 extends 关键字可以继承抽象类，继承后，BasketballPlayer 类就是 AbstractPlayer 的子类。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。<br>当在一个普通类（没有使用 abstract 关键字修饰）中定义了抽象方法，编译器就会有两处错误提示。<br>第一处在类级别上，提醒你“这个类必须通过 abstract 关键字定义”，or 的那个信息没必要，见下图。<br><img src=\"https://www.qyihe.xyz/images/post/10.27.jpg\"><br>第二处在方法级别上，提醒你“抽象方法所在的类不是抽象的”，见下图。<br><img src=\"https://www.qyihe.xyz/images/post/10.28.jpg\"><br>（4）抽象类可以同时声明抽象方法和具体方法，也可以什么方法都没有，但没必要。就像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractPlayer &#123;</span><br><span class=\"line\">    abstract void play();</span><br><span class=\"line\">    </span><br><span class=\"line\">    public void sleep() &#123;</span><br><span class=\"line\">        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（5）抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类中定义了 play() 方法，子类中就必须实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    void play() &#123;</span><br><span class=\"line\">        System.out.println(&quot;我是张伯伦，篮球场上得过 100 分&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有实现的话，编译器会提醒你“子类必须实现抽象方法”，见下图。<br><img src=\"https://www.qyihe.xyz/images/post/10.29.jpg\"></p>\n<h2 id=\"02、什么时候用抽象类\"><a href=\"#02、什么时候用抽象类\" class=\"headerlink\" title=\"02、什么时候用抽象类\"></a>02、什么时候用抽象类</h2><p>与抽象类息息相关的还有一个概念，就是接口，我们留到下一篇文章中详细说，因为要说的知识点还是蛮多的。你现在只需要有这样一个概念就好，接口是对行为的抽象，抽象类是对整个类（包含成员变量和行为）进行抽象。<br>（是不是有点明白又有点不明白，别着急，翘首以盼地等下一篇文章出炉吧）<br>除了接口之外，还有一个概念就是具体的类，就是不通过 abstract 修饰的普通类，见下面这段代码中的定义。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BasketballPlayer &#123;</span><br><span class=\"line\">   public void play() &#123;</span><br><span class=\"line\">        System.out.println(&quot;我是詹姆斯，现役第一人&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有接口，有具体类，那什么时候该使用抽象类呢？<br>（1）我们希望一些通用的功能被多个子类复用。比如说，AbstractPlayer 抽象类中有一个普通的方法 sleep()，表明所有运动员都需要休息，那么这个方法就可以被子类复用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractPlayer &#123;</span><br><span class=\"line\">    public void sleep() &#123;</span><br><span class=\"line\">        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然 AbstractPlayer 类可以不是抽象类——把 abstract 修饰符去掉也能满足这种场景。但 AbstractPlayer 类可能还会有一个或者多个抽象方法。<br>BasketballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BasketballPlayer 对象可以直接调用 sleep() 方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BasketballPlayer basketballPlayer = new BasketballPlayer();</span><br><span class=\"line\">basketballPlayer.sleep();</span><br></pre></td></tr></table></figure>\n<p>FootballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FootballPlayer extends AbstractPlayer &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>FootballPlayer 对象也可以直接调用 sleep() 方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FootballPlayer footballPlayer = new FootballPlayer();</span><br><span class=\"line\">footballPlayer.sleep();</span><br></pre></td></tr></table></figure>\n<p>（2）我们需要在抽象类中定义好 API，然后在子类中扩展实现。比如说，AbstractPlayer  抽象类中有一个抽象方法 play()，定义所有运动员都可以从事某项运动，但需要对应子类去扩展实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractPlayer &#123;</span><br><span class=\"line\">    abstract void play();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    void play() &#123;</span><br><span class=\"line\">        System.out.println(&quot;我是张伯伦，我篮球场上得过 100 分，&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;```</span><br><span class=\"line\"></span><br><span class=\"line\">FootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</span><br></pre></td></tr></table></figure>\n<p>public class FootballPlayer extends AbstractPlayer {<br>  @Override<br>  void play() {</p>\n<pre><code>  System.out.println(&quot;我是C罗，我能接住任意高度的头球&quot;);\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（3）如果父类与子类之间的关系符合 is-a 的层次关系，就可以使用抽象类，比如说篮球运动员是运动员，足球运动员是运动员。</span><br><span class=\"line\">## 03、具体示例</span><br><span class=\"line\">为了进一步展示抽象类的特性，我们再来看一个具体的示例。假设现在有一个文件，里面的内容非常简单——“Hello World”，现在需要有一个读取器将内容读取出来，最好能按照大写的方式，或者小写的方式。</span><br><span class=\"line\">这时候，最好定义一个抽象类，比如说 BaseFileReader：</span><br></pre></td></tr></table></figure>\n<p>public abstract class BaseFileReader {<br>  protected Path filePath;</p>\n<p>  protected BaseFileReader(Path filePath) {</p>\n<pre><code>  this.filePath = filePath;\n</code></pre>\n<p>  }</p>\n<p>  public List<String> readFile() throws IOException {</p>\n<pre><code>  return Files.lines(filePath)\n          .map(this::mapFileLine).collect(Collectors.toList());\n</code></pre>\n<p>  }</p>\n<p>  protected abstract String mapFileLine(String line);<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问。</span><br><span class=\"line\">readFile() 方法用来读取文件，方法体里面调用了抽象方法 mapFileLine()——需要子类扩展实现大小写的方式。</span><br><span class=\"line\">你看，BaseFileReader 设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。</span><br><span class=\"line\">小写的方式：</span><br></pre></td></tr></table></figure>\n<p>public class LowercaseFileReader extends BaseFileReader {<br>  protected LowercaseFileReader(Path filePath) {</p>\n<pre><code>  super(filePath);\n</code></pre>\n<p>  }</p>\n<p>  @Override<br>  protected String mapFileLine(String line) {</p>\n<pre><code>  return line.toLowerCase();\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">大写的方式：</span><br></pre></td></tr></table></figure>\n<p>public class UppercaseFileReader extends BaseFileReader {<br>  protected UppercaseFileReader(Path filePath) {</p>\n<pre><code>  super(filePath);\n</code></pre>\n<p>  }</p>\n<p>  @Override<br>  protected String mapFileLine(String line) {</p>\n<pre><code>  return line.toUpperCase();\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你看，从文件里面一行一行读取内容的代码被子类复用了——抽象类 BaseFileReader 类中定义的普通方法 readFile()。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。</span><br><span class=\"line\">接下来，我们来新建一个测试类 FileReaderTest：</span><br></pre></td></tr></table></figure>\n<p>public class FileReaderTest {<br>  public static void main(String[] args) throws URISyntaxException, IOException {</p>\n<pre><code>  URL location = FileReaderTest.class.getClassLoader().getResource(&quot;helloworld.txt&quot;);\n  Path path = Paths.get(location.toURI());\n  BaseFileReader lowercaseFileReader = new LowercaseFileReader(path);\n  BaseFileReader uppercaseFileReader = new UppercaseFileReader(path);\n  System.out.println(lowercaseFileReader.readFile());\n  System.out.println(uppercaseFileReader.readFile());\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">项目的 resource 目录下有一个文本文件，名字叫 helloworld.txt。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.30.jpg)</span><br><span class=\"line\">可以通过 ClassLoader.getResource() 的方式获取到该文件的 URI 路径，然后就可以使用 LowercaseFileReader 和 UppercaseFileReader 两种方式读取到文本内容了。</span><br><span class=\"line\">输出结果如下所示：</span><br></pre></td></tr></table></figure>\n<p>[hello world]<br>[HELLO WORLD]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 十、Java 接口</span><br><span class=\"line\">对于面向对象编程来说，抽象是一个极具魅力的特征。如果一个程序员的抽象思维很差，那他在编程中就会遇到很多困难，无法把业务变成具体的代码。在 Java 中，可以通过两种形式来达到抽象的目的，一种是抽象类，另外一种就是接口。</span><br><span class=\"line\">如果你现在就想知道抽象类与接口之间的区别，我可以提前给你说一个：</span><br><span class=\"line\"></span><br><span class=\"line\">- 一个类只能继承一个抽象类，但却可以实现多个接口。</span><br><span class=\"line\"></span><br><span class=\"line\">当然了，在没有搞清楚接口到底是什么，它可以做什么之前，这个区别理解起来会有点难度。</span><br><span class=\"line\">## 01、接口是什么</span><br><span class=\"line\">接口是通过 interface 关键字定义的，它可以包含一些常量和方法，来看下面这个示例。</span><br></pre></td></tr></table></figure>\n<p>public interface Electronic {<br>  // 常量<br>  String LED = “LED”;</p>\n<p>  // 抽象方法<br>  int getElectricityUse();</p>\n<p>  // 静态方法<br>  static boolean isEnergyEfficient(String electtronicType) {</p>\n<pre><code>  return electtronicType.equals(LED);\n</code></pre>\n<p>  }</p>\n<p>  // 默认方法<br>  default void printDescription() {</p>\n<pre><code>  System.out.println(&quot;电子&quot;);\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）接口中定义的变量会在编译的时候自动加上 public static final 修饰符，也就是说 LED 变量其实是一个常量。</span><br><span class=\"line\">Java 官方文档上有这样的声明：</span><br></pre></td></tr></table></figure>\n<p>Every field declaration in the body of an interface is implicitly public, static, and final.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">换句话说，接口可以用来作为常量类使用，还能省略掉 public static final，看似不错的一种选择，对吧？</span><br><span class=\"line\">不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。</span><br><span class=\"line\">（2）没有使用 private、default 或者 static 关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 public abstract 修饰符。也就是说 getElectricityUse() 其实是一个抽象方法，没有方法体——这是定义接口的本意。</span><br><span class=\"line\">（3）从 Java 8 开始，接口中允许有静态方法，比如说 isEnergyEfficient() 方法。</span><br><span class=\"line\">静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口的名字来调用，比如说 Electronic.isEnergyEfficient(&quot;LED&quot;)。</span><br><span class=\"line\">接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。</span><br><span class=\"line\">（4）接口中允许定义 default 方法也是从 Java 8 开始的，比如说 printDescription()，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现，也就是说，无法直接使用一个“;”号来结束默认方法——编译器会报错的。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.31.jpg)</span><br><span class=\"line\">允许在接口中定义默认方法的理由是很充分的，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 default 方法的帮助下，我们就必须挨个对实现类进行修改。</span><br><span class=\"line\">来看一下 Electronic 接口反编译后的字节码吧，你会发现，接口中定义的所有变量或者方法，都会自动添加上 public 关键字——假如你想知道编译器在背后都默默做了哪些辅助，记住反编译字节码就对了。</span><br></pre></td></tr></table></figure>\n<p>public interface Electronic<br>{</p>\n<p>  public abstract int getElectricityUse();</p>\n<p>  public static boolean isEnergyEfficient(String electtronicType)<br>  {</p>\n<pre><code>  return electtronicType.equals(&quot;LED&quot;);\n</code></pre>\n<p>  }</p>\n<p>  public void printDescription()<br>  {</p>\n<pre><code>  System.out.println(&quot;\\u7535\\u5B50&quot;);\n</code></pre>\n<p>  }</p>\n<p>  public static final String LED = “LED”;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有些读者可能会问，“二哥，为什么我反编译后的字节码和你的不一样，你用了什么反编译工具？”其实没有什么秘密，微信搜「沉默王二」回复关键字「JAD」就可以免费获取了，超级好用。</span><br><span class=\"line\">## 02、定义接口的注意事项</span><br><span class=\"line\">由之前的例子我们就可以得出下面这些结论：</span><br><span class=\"line\"></span><br><span class=\"line\">- 接口中允许定义变量</span><br><span class=\"line\">- 接口中允许定义抽象方法</span><br><span class=\"line\">- 接口中允许定义静态方法（Java 8 之后）</span><br><span class=\"line\">- 接口中允许定义默认方法（Java 8 之后）</span><br><span class=\"line\"></span><br><span class=\"line\">除此之外，我们还应该知道：</span><br><span class=\"line\">（1）接口不允许直接实例化。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.32.jpg)</span><br><span class=\"line\">需要定义一个类去实现接口，然后再实例化。</span><br></pre></td></tr></table></figure>\n<p>public class Computer implements Electronic {</p>\n<p>  public static void main(String[] args) {</p>\n<pre><code>  new Computer();\n</code></pre>\n<p>  }</p>\n<p>  @Override<br>  public int getElectricityUse() {</p>\n<pre><code>  return 0;\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（2）接口可以是空的，既不定义变量，也不定义方法。</span><br></pre></td></tr></table></figure>\n<p>public interface Serializable {<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Serializable 是最典型的一个空的接口，我之前分享过一篇文章《Java Serializable：明明就一个空的接口嘛》，感兴趣的读者可以去我的个人博客看一看，你就明白了空接口的意义。</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.itwanger.com/java/2019/1%E2%80%A6\">www.itwanger.com/java/2019/1…</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">（3）不要在定义接口的时候使用 final 关键字，否则会报编译错误，因为接口就是为了让子类实现的，而 final 阻止了这种行为。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.33.jpg)</span><br><span class=\"line\">（4）接口的抽象方法不能是 private、protected 或者 final。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.34.jpg)</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.35.jpg)</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.36.jpg)</span><br><span class=\"line\">（5）接口的变量是隐式 public static final，所以其值无法改变。</span><br><span class=\"line\">## 03、接口可以做什么</span><br><span class=\"line\">（1）使某些实现类具有我们想要的功能，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了 Comparable 或者 Comparator 的类具有比较功能。</span><br><span class=\"line\">Cloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 Object.clone() 方法，否则会抛出 CloneNotSupportedException。</span><br></pre></td></tr></table></figure>\n<p>public class CloneableTest implements Cloneable {<br>  @Override<br>  protected Object clone() throws CloneNotSupportedException {</p>\n<pre><code>  return super.clone();\n</code></pre>\n<p>  }</p>\n<p>  public static void main(String[] args) throws CloneNotSupportedException {</p>\n<pre><code>  CloneableTest c1 = new CloneableTest();\n  CloneableTest c2 = (CloneableTest) c1.clone();\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行后没有报错。现在把 implements Cloneable 去掉。</span><br></pre></td></tr></table></figure>\n<p>public class CloneableTest {<br>  @Override<br>  protected Object clone() throws CloneNotSupportedException {</p>\n<pre><code>  return super.clone();\n</code></pre>\n<p>  }</p>\n<p>  public static void main(String[] args) throws CloneNotSupportedException {</p>\n<pre><code>  CloneableTest c1 = new CloneableTest();\n  CloneableTest c2 = (CloneableTest) c1.clone();\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行后抛出 CloneNotSupportedException：</span><br></pre></td></tr></table></figure>\n<p>Exception in thread “main” java.lang.CloneNotSupportedException: com.cmower.baeldung.interface1.CloneableTest<br>  at java.base/java.lang.Object.clone(Native Method)<br>  at com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:6)<br>  at com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:11)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">至于 Comparable 和 Comparator 的用法，感兴趣的读者可以参照我之前写的另外一篇文章《来吧，一文彻底搞懂Java中的Comparable和Comparator》。</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.itwanger.com/java/2020/0%E2%80%A6\">www.itwanger.com/java/2020/0…</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（2）Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。</span><br><span class=\"line\">可能有些读者会问，“二哥，为什么 Java 只支持单一继承？”简单来解释一下。</span><br><span class=\"line\">如果有两个类共同继承（extends）一个有特定方法的父类，那么该方法会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。这也正是著名的菱形问题，见下图。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.37.jpg)</span><br><span class=\"line\">ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重载的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。</span><br><span class=\"line\">接口没有这方面的困扰。来定义两个接口，Fly 会飞，Run 会跑。</span><br></pre></td></tr></table></figure>\n<p>public interface Fly {<br>  void fly();<br>}<br>public interface Run {<br>  void run();<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">然后让一个类同时实现这两个接口。</span><br></pre></td></tr></table></figure>\n<p>public class Pig implements Fly,Run{<br>  @Override<br>  public void fly() {</p>\n<pre><code>  System.out.println(&quot;会飞的猪&quot;);\n</code></pre>\n<p>  }</p>\n<p>  @Override<br>  public void run() {</p>\n<pre><code>  System.out.println(&quot;会跑的猪&quot;);\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这就在某种形式上达到了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。</span><br><span class=\"line\">（3）实现多态。</span><br><span class=\"line\">什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。</span><br><span class=\"line\">多态可以通过继承（extends）的关系实现，也可以通过接口的形式实现。来看这样一个例子。</span><br><span class=\"line\">Shape 是表示一个形状。</span><br></pre></td></tr></table></figure>\n<p>public interface Shape {<br>  String name();<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">圆是一个形状。</span><br></pre></td></tr></table></figure>\n<p>public class Circle implements Shape {<br>  @Override<br>  public String name() {</p>\n<pre><code>  return &quot;圆&quot;;\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">正方形也是一个形状。</span><br></pre></td></tr></table></figure>\n<p>public class Square implements Shape {<br>  @Override<br>  public String name() {</p>\n<pre><code>  return &quot;正方形&quot;;\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">然后来看测试类。</span><br></pre></td></tr></table></figure>\n<p>List<Shape> shapes = new ArrayList&lt;&gt;();<br>Shape circleShape = new Circle();<br>Shape squareShape = new Square();</p>\n</li>\n</ul>\n<p>shapes.add(circleShape);<br>shapes.add(squareShape);</p>\n<p>for (Shape shape : shapes) {<br>    System.out.println(shape.name());<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多态的存在 3 个前提：</span><br><span class=\"line\">1、要有继承关系，Circle 和 Square 都实现了 Shape 接口</span><br><span class=\"line\">2、子类要重写父类的方法，Circle 和 Square 都重写了 name() 方法</span><br><span class=\"line\">3、父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle 对象，后者指向的是 Square 对象。</span><br><span class=\"line\">然后，我们来看一下测试结果：</span><br></pre></td></tr></table></figure>\n<p>圆<br>正方形</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 name() 方法的时候，它知道 Circle 对象应该调用 Circle 类的 name() 方法，Square 对象应该调用 Square 类的 name() 方法。</span><br><span class=\"line\">## 04、接口与抽象类的区别</span><br><span class=\"line\">好了，关于接口的一切，你应该都搞清楚了。现在回到读者春夏秋冬的那条留言，“兄弟，说说抽象类和接口之间的区别？”</span><br><span class=\"line\">（1）语法层面上</span><br><span class=\"line\"></span><br><span class=\"line\">- 接口中不能有 public 和 protected 修饰的方法，抽象类中可以有。</span><br><span class=\"line\">- 接口中的变量只能是隐式的常量，抽象类中可以有任意类型的变量。</span><br><span class=\"line\">- 一个类只能继承一个抽象类，但却可以实现多个接口。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）设计层面上</span><br><span class=\"line\">抽象类是对类的一种抽象，继承抽象类的类和抽象类本身是一种 is-a 的关系。</span><br><span class=\"line\">接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，所有的类都可以实现 Serializable 接口，从而具有序列化的功能。</span><br><span class=\"line\">就这么多吧，能说道这份上，我相信面试官就不会为难你了。</span><br><span class=\"line\"># 十一、Java 继承</span><br><span class=\"line\">在 Java 中，一个类可以继承另外一个类或者实现多个接口，我想这一点，大部分的读者应该都知道了。还有一点，我不确定大家是否知道，就是一个接口也可以继承另外一个接口，就像下面这样：</span><br></pre></td></tr></table></figure>\n<p>public interface OneInterface extends Cloneable {<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这样做有什么好处呢？我想有一部分读者应该已经猜出来了，就是实现了 OneInterface 接口的类，也可以使用 Object.clone() 方法了。</span><br></pre></td></tr></table></figure>\n<p>public class TestInterface implements OneInterface {<br>    public static void main(String[] args) throws CloneNotSupportedException {<br>        TestInterface c1 = new TestInterface();<br>        TestInterface c2 = (TestInterface) c1.clone();<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">除此之外，我们还可以在 OneInterface 接口中定义其他一些抽象方法（比如说深拷贝），使该接口拥有 Cloneable 所不具有的功能。</span><br></pre></td></tr></table></figure>\n<p>public interface OneInterface extends Cloneable {<br>    void deepClone();<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">看到了吧？这就是继承的好处：子接口拥有了父接口的方法，使得子接口具有了父接口相同的行为；同时，子接口还可以在此基础上自由发挥，添加属于自己的行为。</span><br><span class=\"line\">以上，把“接口”换成“类”，结论同样成立。让我们来定义一个普通的父类 Wanger：</span><br></pre></td></tr></table></figure>\n<p>public class Wanger {<br>    int age;<br>    String name;<br>    void write() {<br>        System.out.println(“我写了本《基督山伯爵》”);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">然后，我们再来定义一个子类 Wangxiaoer，使用关键字 extends 来继承父类 Wanger：</span><br></pre></td></tr></table></figure>\n<p>public class Wangxiaoer extends Wanger{<br>    @Override<br>    void write() {<br>        System.out.println(“我写了本《茶花女》”);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们可以将通用的方法和成员变量放在父类中，达到代码复用的目的；然后将特殊的方法和成员变量放在子类中，除此之外，子类还可以覆盖父类的方法（比如write() 方法）。这样，子类也就焕发出了新的生命力。</span><br><span class=\"line\">Java 只支持单一继承，这一点，我在上一篇接口的文章中已经提到过了。如果一个类在定义的时候没有使用 extends 关键字，那么它隐式地继承了 java.lang.Object 类——在我看来，这恐怕就是 Java 号称万物皆对象的真正原因了。</span><br><span class=\"line\">那究竟子类继承了父类的什么呢？</span><br><span class=\"line\">子类可以继承父类的非 private 成员变量，为了验证这一点，我们来看下面这个示例。</span><br></pre></td></tr></table></figure>\n<p>public class Wanger {<br>    String defaultName;<br>    private String privateName;<br>    public String publicName;<br>    protected String protectedName;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父类 Wanger 定义了四种类型的成员变量，缺省的 defaultName、私有的 privateName、共有的 publicName、受保护的 protectedName。</span><br><span class=\"line\">在子类 Wangxiaoer 中定义一个测试方法 testVariable()：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.38.jpg)</span><br><span class=\"line\">可以确认，除了私有的 privateName，其他三种类型的成员变量都可以继承到。</span><br><span class=\"line\">同理，子类可以继承父类的非 private 方法，为了验证这一点，我们来看下面这个示例。</span><br></pre></td></tr></table></figure>\n<p>public class Wanger {<br>    void write() {<br>    }</p>\n<pre><code>private void privateWrite() &#123;\n&#125;\n\npublic void publicWrite() &#123;\n&#125;\n\nprotected void protectedWrite() &#123;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父类 Wanger 定义了四种类型的方法，缺省的 write、私有的 privateWrite()、共有的 publicWrite()、受保护的 protectedWrite()。</span><br><span class=\"line\">在子类 Wangxiaoer 中定义一个 main 方法，并使用 new 关键字新建一个子类对象：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.39.jpg)</span><br><span class=\"line\">可以确认，除了私有的 privateWrite()，其他三种类型的方法都可以继承到。</span><br><span class=\"line\">不过，子类无法继承父类的构造方法。如果父类的构造方法是带有参数的，代码如下所示：</span><br></pre></td></tr></table></figure>\n<p>public class Wanger {<br>    int age;<br>    String name;</p>\n<pre><code>public Wanger(int age, String name) &#123;\n    this.age = age;\n    this.name = name;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">则必须在子类的构造器中显式地通过 super 关键字进行调用，否则编译器将提示以下错误：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.40.jpg)</span><br><span class=\"line\">修复后的代码如下所示：</span><br></pre></td></tr></table></figure>\n<p>public class Wangxiaoer extends Wanger{<br>    public Wangxiaoer(int age, String name) {<br>        super(age, name);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is-a 是继承的一个明显特征，就是说子类的对象引用类型可以是一个父类类型。</span><br></pre></td></tr></table></figure>\n<p>public class Wangxiaoer extends Wanger{<br>    public static void main(String[] args) {<br>        Wanger wangxiaoer = new Wangxiaoer();<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同理，子接口的实现类的对象引用类型也可以是一个父接口类型。</span><br></pre></td></tr></table></figure>\n<p>public interface OneInterface extends Cloneable {<br>}<br>public class TestInterface implements OneInterface {<br>    public static void main(String[] args) {<br>        Cloneable c1 = new TestInterface();<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">尽管一个类只能继承一个类，但一个类却可以实现多个接口，这一点，我在上一篇文章也提到过了。另外，还有一点我也提到了，就是 Java 8 之后，接口中可以定义 default 方法，这很方便，但也带来了新的问题：</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 如果一个类实现了多个接口，而这些接口中定义了相同签名的 default 方法，那么这个类就要重写该方法，否则编译无法通过。</span><br><span class=\"line\"></span><br><span class=\"line\">FlyInterface 是一个会飞的接口，里面有一个签名为 sleep() 的默认方法：</span><br></pre></td></tr></table></figure>\n<p>public interface FlyInterface {<br>    void fly();<br>    default void sleep() {<br>        System.out.println(“睡着飞”);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RunInterface 是一个会跑的接口，里面也有一个签名为 sleep() 的默认方法：</span><br></pre></td></tr></table></figure>\n<p>public interface RunInterface {<br>    void run();<br>    default void sleep() {<br>        System.out.println(“睡着跑”);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pig 类实现了 FlyInterface 和 RunInterface 两个接口，但这时候编译出错了。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.41.jpg)</span><br><span class=\"line\">原本，default 方法就是为实现该接口而不覆盖该方法的类提供默认实现的，现在，相同方法签名的 sleep() 方法把编译器搞懵逼了，只能重写了。</span><br></pre></td></tr></table></figure>\n<p>public class Pig implements FlyInterface, RunInterface {</p>\n<pre><code>@Override\npublic void fly() &#123;\n    System.out.println(&quot;会飞的猪&quot;);\n&#125;\n\n@Override\npublic void sleep() &#123;\n    System.out.println(&quot;只能重写了&quot;);\n&#125;\n\n@Override\npublic void run() &#123;\n    System.out.println(&quot;会跑的猪&quot;);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类虽然不能继承多个类，但接口却可以继承多个接口，这一点，我不知道有没有触及到一些读者的知识盲区。</span><br></pre></td></tr></table></figure>\n<p>public interface WalkInterface extends FlyInterface,RunInterface{<br>    void walk();<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 十二、this 关键字</span><br><span class=\"line\">在 Java 中，this 关键字指的是当前对象（它的方法正在被调用）的引用，能理解吧，各位亲？不理解的话，我们继续往下看。</span><br><span class=\"line\">看完再不明白，你过来捶爆我，我保证不还手，只要不打脸。</span><br><span class=\"line\">## 01、消除字段歧义</span><br><span class=\"line\">我敢赌一毛钱，所有的读者，不管男女老少，应该都知道这种用法，毕竟写构造方法的时候经常用啊。谁要不知道，过来，我给你发一毛钱红包，只要你脸皮够厚。</span><br></pre></td></tr></table></figure>\n<p>public class Writer {<br>    private int age;<br>    private String name;</p>\n<pre><code>public Writer(int age, String name) &#123;\n    this.age = age;\n    this.name = name;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer 类有两个成员变量，分别是 age 和 name，在使用有参构造函数的时候，如果参数名和成员变量的名字相同，就需要使用 this 关键字消除歧义：this.age 是指成员变量，age 是指构造方法的参数。</span><br><span class=\"line\">## 02、引用类的其他构造方法</span><br><span class=\"line\">当一个类的构造方法有多个，并且它们之间有交集的话，就可以使用 this 关键字来调用不同的构造方法，从而减少代码量。</span><br><span class=\"line\">比如说，在无参构造方法中调用有参构造方法：</span><br></pre></td></tr></table></figure>\n<p>public class Writer {<br>    private int age;<br>    private String name;</p>\n<pre><code>public Writer(int age, String name) &#123;\n    this.age = age;\n    this.name = name;\n&#125;\n\npublic Writer() &#123;\n    this(18, &quot;沉默王二&quot;);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">也可以在有参构造方法中调用无参构造方法：</span><br></pre></td></tr></table></figure>\n<p>public class Writer {<br>    private int age;<br>    private String name;</p>\n<pre><code>public Writer(int age, String name) &#123;\n    this();\n    this.age = age;\n    this.name = name;\n&#125;\n\npublic Writer() &#123;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需要注意的是，this() 必须是构造方法中的第一条语句，否则就会报错。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.42.jpg)</span><br><span class=\"line\">## 03、作为参数传递</span><br><span class=\"line\">在下例中，有一个无参的构造方法，里面调用了 print() 方法，参数只有一个 this 关键字。</span><br></pre></td></tr></table></figure>\n<p>public class ThisTest {<br>    public ThisTest() {<br>        print(this);<br>    }</p>\n<pre><code>private void print(ThisTest thisTest) &#123;\n    System.out.println(&quot;print &quot; +thisTest);\n&#125;\n\npublic static void main(String[] args) &#123;\n    ThisTest test = new ThisTest();\n    System.out.println(&quot;main &quot; + test);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">来打印看一下结果：</span><br></pre></td></tr></table></figure>\n<p>print com.cmower.baeldung.this1.ThisTest@573fd745<br>main com.cmower.baeldung.this1.ThisTest@573fd745</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从结果中可以看得出来，this 就是我们在 main() 方法中使用 new 关键字创建的 ThisTest 对象。</span><br><span class=\"line\">## 04、链式调用</span><br><span class=\"line\">学过 JavaScript，或者 jQuery 的读者可能对链式调用比较熟悉，类似于 a.b().c().d()，仿佛能无穷无尽调用下去。</span><br><span class=\"line\">在 Java 中，对应的专有名词叫 Builder 模式，来看一个示例。</span><br></pre></td></tr></table></figure>\n<p>public class Writer {<br>    private int age;<br>    private String name;<br>    private String bookName;</p>\n<pre><code>public Writer(WriterBuilder builder) &#123;\n    this.age = builder.age;\n    this.name = builder.name;\n    this.bookName = builder.bookName;\n&#125;\n\npublic static class WriterBuilder &#123;\n    public String bookName;\n    private int age;\n    private String name;\n\n    public WriterBuilder(int age, String name) &#123;\n        this.age = age;\n        this.name = name;\n    &#125;\n\n    public WriterBuilder writeBook(String bookName) &#123;\n        this.bookName = bookName;\n        return this;\n    &#125;\n\n    public Writer build() &#123;\n        return new Writer(this);\n    &#125;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer 类有三个成员变量，分别是 age、name 和 bookName，还有它们仨对应的一个构造方法，参数是一个内部静态类 WriterBuilder。</span><br><span class=\"line\">内部类 WriterBuilder 也有三个成员变量，和 Writer 类一致，不同的是，WriterBuilder 类的构造方法里面只有 age 和 name 赋值了，另外一个成员变量 bookName 通过单独的方法 writeBook() 来赋值，注意，该方法的返回类型是 WriterBuilder，最后使用 return 返回了 this 关键字。</span><br><span class=\"line\">最后的 build() 方法用来创建一个 Writer 对象，参数为 this 关键字，也就是当前的 WriterBuilder 对象。</span><br><span class=\"line\">这时候，创建 Writer 对象就可以通过链式调用的方式。</span><br></pre></td></tr></table></figure>\n<p>Writer writer = new Writer.WriterBuilder(18,”沉默王二”)<br>                .writeBook(“《Web全栈开发进阶之路》”)<br>                .build();</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 05、在内部类中访问外部类对象</span><br><span class=\"line\">说实话，自从 Java 8 的函数式编程出现后，就很少用到 this 在内部类中访问外部类对象了。来看一个示例：</span><br></pre></td></tr></table></figure>\n<p>public class ThisInnerTest {<br>    private String name;</p>\n<pre><code>class InnerClass &#123;\n    public InnerClass() &#123;\n        ThisInnerTest thisInnerTest = ThisInnerTest.this;\n        String outerName = thisInnerTest.name;\n    &#125;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在内部类 InnerClass 的构造方法中，通过外部类.this 可以获取到外部类对象，然后就可以使用外部类的成员变量了，比如说 name。</span><br><span class=\"line\"># 十三、super 关键字</span><br><span class=\"line\">简而言之，super 关键字就是用来访问父类的。</span><br><span class=\"line\">先来看父类：</span><br></pre></td></tr></table></figure>\n<p>public class SuperBase {<br>    String message = “父类”;</p>\n<pre><code>public SuperBase(String message) &#123;\n    this.message = message;\n&#125;\n\npublic SuperBase() &#123;\n&#125;\n\npublic void printMessage() &#123;\n    System.out.println(message);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">再来看子类：</span><br></pre></td></tr></table></figure>\n<p>public class SuperSub extends SuperBase {<br>    String message = “子类”;</p>\n<pre><code>public SuperSub(String message) &#123;\n    super(message);\n&#125;\n\npublic SuperSub() &#123;\n    super.printMessage();\n    printMessage();\n&#125;\n\npublic void getParentMessage() &#123;\n    System.out.println(super.message);\n&#125;\n\npublic void printMessage() &#123;\n    System.out.println(message);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）super 关键字可用于访问父类的构造方法</span><br><span class=\"line\">你看，子类可以通过 super(message) 来调用父类的构造方法。现在来新建一个 SuperSub 对象，看看输出结果是什么：</span><br></pre></td></tr></table></figure>\n<p>SuperSub superSub = new SuperSub(“子类的message”);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new 关键字在调用构造方法创建子类对象的时候，会通过 super 关键字初始化父类的 message，所以此此时父类的 message 会输出“子类的message”。</span><br><span class=\"line\">（2）super 关键字可以访问父类的变量</span><br><span class=\"line\">上述例子中的 SuperSub 类中就有，getParentMessage() 通过 super.message 方法父类的同名成员变量 message。</span><br><span class=\"line\">（3）当方法发生重写时，super 关键字可以访问父类的同名方法</span><br><span class=\"line\">上述例子中的 SuperSub 类中就有，无参的构造方法 SuperSub() 中就使用 super.printMessage() 调用了父类的同名方法。</span><br><span class=\"line\"># 十四、重写和重载</span><br><span class=\"line\">先来看一段重写的代码吧。</span><br></pre></td></tr></table></figure>\n<p>class LaoWang{<br>    public void write() {<br>        System.out.println(“老王写了一本《基督山伯爵》”);<br>    }<br>}<br>public class XiaoWang extends LaoWang {<br>    @Override<br>    public void write() {<br>        System.out.println(“小王写了一本《茶花女》”);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。就好像父类 LaoWang 有一个 write() 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 write() 方法（无参），但方法体是写一本《茶花女》。</span><br><span class=\"line\">来写一段测试代码。</span><br></pre></td></tr></table></figure>\n<p>public class OverridingTest {<br>    public static void main(String[] args) {<br>        LaoWang wang = new XiaoWang();<br>        wang.write();<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">大家猜结果是什么？</span><br></pre></td></tr></table></figure>\n<p>小王写了一本《茶花女》</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在上面的代码中，们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 write() 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 write() 方法而不是父类 LaoWang  中的 write() 方法，因此输出结果为“小王写了一本《茶花女》”。</span><br><span class=\"line\">再来看一段重载的代码吧。</span><br></pre></td></tr></table></figure>\n<p>class LaoWang{<br>    public void read() {<br>        System.out.println(“老王读了一本《Web全栈开发进阶之路》”);<br>    }</p>\n<pre><code>public void read(String bookname) &#123;\n    System.out.println(&quot;老王读了一本《&quot; + bookname + &quot;》&quot;);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">重载的两个方法名相同，但方法参数的个数不同，另外也不涉及到继承，两个方法在同一个类中。就好像类 LaoWang 有两个方法，名字都是 read()，但一个有参数（书名），另外一个没有（只能读写死的一本书）。</span><br><span class=\"line\">来写一段测试代码。</span><br></pre></td></tr></table></figure>\n<p>public class OverloadingTest {<br>    public static void main(String[] args) {<br>        LaoWang wang = new LaoWang();<br>        wang.read();<br>        wang.read(“金瓶梅”);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这结果就不用猜了。变量 wang 的类型为 LaoWang，wang.read() 调用的是无参的 read() 方法，因此先输出“老王读了一本《Web全栈开发进阶之路》”；wang.read(&quot;金瓶梅&quot;) 调用的是有参的 read(bookname) 方法，因此后输出“老王读了一本《金瓶梅》”。在编译期间，编译器就知道这两个 read() 方法时不同的，因为它们的方法签名（=方法名称+方法参数）不同。</span><br><span class=\"line\">简单的来总结一下：</span><br><span class=\"line\">（1）编译器无法决定调用哪个重写的方法，因为只从变量的类型上是无法做出判断的，要在运行时才能决定；但编译器可以明确地知道该调用哪个重载的方法，因为引用类型是确定的，参数个数决定了该调用哪个方法。</span><br><span class=\"line\">（2）多态针对的是重写，而不是重载。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.43.jpg)</span><br><span class=\"line\">哎，后悔啊，早年我要是能把这道面试题吃透的话，也不用被老马刁难了。吟一首诗感慨一下人生吧。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;青青园中葵，朝露待日晞。</span><br><span class=\"line\">&gt;阳春布德泽，万物生光辉。</span><br><span class=\"line\">&gt;常恐秋节至，焜黄华叶衰。</span><br><span class=\"line\">&gt;百川东到海，何时复西归?</span><br><span class=\"line\">&gt;少壮不努力，老大徒伤悲</span><br><span class=\"line\"></span><br><span class=\"line\">另外，我想要告诉大家的是，重写（Override）和重载（Overload）是 Java 中两个非常重要的概念，新手经常会被它们俩迷惑，因为它们俩的英文名字太像了，中文翻译也只差一个字。难，太难了。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.44.jpg)</span><br><span class=\"line\"># 十五、static 关键字</span><br><span class=\"line\">先来个提纲挈领（唉呀妈呀，成语区博主上线了）吧：</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;static 关键字可用于变量、方法、代码块和内部类，表示某个特定的成员只属于某个类本身，而不是该类的某个对象。</span><br><span class=\"line\"></span><br><span class=\"line\">## 01、静态变量</span><br><span class=\"line\">静态变量也叫类变量，它属于一个类，而不是这个类的对象。</span><br></pre></td></tr></table></figure>\n<p>public class Writer {<br>    private String name;<br>    private int age;<br>    public static int countOfWriters;</p>\n<pre><code>public Writer(String name, int age) &#123;\n    this.name = name;\n    this.age = age;\n    countOfWriters++;\n&#125;\n\npublic String getName() &#123;\n    return name;\n&#125;\n\npublic void setName(String name) &#123;\n    this.name = name;\n&#125;\n\npublic int getAge() &#123;\n    return age;\n&#125;\n\npublic void setAge(int age) &#123;\n    this.age = age;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中，countOfWriters 被称为静态变量，它有别于 name 和 age 这两个成员变量，因为它前面多了一个修饰符 static。</span><br><span class=\"line\">这意味着无论这个类被初始化多少次，静态变量的值都会在所有类的对象中共享。</span><br></pre></td></tr></table></figure>\n<p>Writer w1 = new Writer(“沉默王二”,18);<br>Writer w2 = new Writer(“沉默王三”,16);</p>\n<p>System.out.println(Writer.countOfWriters);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">按照上面的逻辑，你应该能推理得出，countOfWriters 的值此时应该为 2 而不是 1。从内存的角度来看，静态变量将会存储在 Java 虚拟机中一个名叫“Metaspace”（元空间，Java 8 之后）的特定池中。</span><br><span class=\"line\">静态变量和成员变量有着很大的不同，成员变量的值属于某个对象，不同的对象之间，值是不共享的；但静态变量不是的，它可以用来统计对象的数量，因为它是共享的。就像上面例子中的 countOfWriters，创建一个对象的时候，它的值为 1，创建两个对象的时候，它的值就为 2。</span><br><span class=\"line\">简单小结一下：</span><br><span class=\"line\">（1）由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问；</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.45.jpg)</span><br><span class=\"line\">（2）不需要初始化类就可以访问静态变量。</span><br></pre></td></tr></table></figure>\n<p>public class WriterDemo {<br>    public static void main(String[] args) {<br>        System.out.println(Writer.countOfWriters); // 输出 0<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 02、静态方法</span><br><span class=\"line\">静态方法也叫类方法，它和静态变量类似，属于一个类，而不是这个类的对象。</span><br></pre></td></tr></table></figure>\n<p>public static void setCountOfWriters(int countOfWriters) {<br>    Writer.countOfWriters = countOfWriters;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setCountOfWriters() 就是一个静态方法，它由 static 关键字修饰。</span><br><span class=\"line\">如果你用过 java.lang.Math 类或者 Apache 的一些工具类（比如说 StringUtils）的话，对静态方法一定不会感动陌生。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.46.jpg)</span><br><span class=\"line\">Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.47.jpg)</span><br><span class=\"line\">简单小结一下：</span><br><span class=\"line\">（1）Java 中的静态方法在编译时解析，因为静态方法不能被重写（方法重写发生在运行时阶段，为了多态）。</span><br><span class=\"line\">（2）抽象方法不能是静态的。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.48.jpg)</span><br><span class=\"line\">（3）静态方法不能使用 this 和 super 关键字。</span><br><span class=\"line\">（4）成员方法可以直接访问其他成员方法和成员变量。</span><br><span class=\"line\">（5）成员方法也可以直接方法静态方法和静态变量。</span><br><span class=\"line\">（6）静态方法可以访问所有其他静态方法和静态变量。</span><br><span class=\"line\">（7）静态方法无法直接访问成员方法和成员变量。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.49.jpg)</span><br><span class=\"line\">## 03、静态代码块</span><br><span class=\"line\">静态代码块可以用来初始化静态变量，尽管静态方法也可以在声明的时候直接初始化，但有些时候，我们需要多行代码来完成初始化。</span><br></pre></td></tr></table></figure>\n<p>public class StaticBlockDemo {<br>    public static List<String> writes = new ArrayList&lt;&gt;();</p>\n<pre><code>static &#123;\n    writes.add(&quot;沉默王二&quot;);\n    writes.add(&quot;沉默王三&quot;);\n    writes.add(&quot;沉默王四&quot;);\n\n    System.out.println(&quot;第一块&quot;);\n&#125;\n\nstatic &#123;\n    writes.add(&quot;沉默王五&quot;);\n    writes.add(&quot;沉默王六&quot;);\n\n    System.out.println(&quot;第二块&quot;);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">writes 是一个静态的 ArrayList，所以不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初始化。</span><br><span class=\"line\">简单小结一下：</span><br><span class=\"line\">（1）一个类可以有多个静态代码块。</span><br><span class=\"line\">（2）静态代码块的解析和执行顺序和它在类中的位置保持一致。为了验证这个结论，可以在 StaticBlockDemo 类中加入空的 main 方法，执行完的结果如下所示：</span><br></pre></td></tr></table></figure>\n<p>第一块<br>第二块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 04、静态内部类</span><br><span class=\"line\">Java 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。</span><br><span class=\"line\">常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我们本次文章的讨论范围，以后有机会再细说。</span><br></pre></td></tr></table></figure>\n<p>public class Singleton {<br>    private Singleton() {}</p>\n<pre><code>private static class SingletonHolder &#123;\n    public static final Singleton instance = new Singleton();\n&#125;\n\npublic static Singleton getInstance() &#123;\n    return SingletonHolder.instance;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以上这段代码是不是特别熟悉，对，这就是创建单例的一种方式，第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全也能保证 Singleton 类的唯一性。不过，创建单例更优雅的一种方式是使用枚举。</span><br><span class=\"line\">简单小结一下：</span><br><span class=\"line\">（1）静态内部类不能访问外部类的所有成员变量。</span><br><span class=\"line\">（2）静态内部类可以访问外部类的所有静态变量，包括私有静态变量。</span><br><span class=\"line\">（3）外部类不能声明为 static。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.50.jpg)</span><br><span class=\"line\"># 十六、Java 枚举</span><br><span class=\"line\">开门见山地说吧，enum（枚举）是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，默认继承自 java.lang.Enum。</span><br><span class=\"line\">为了证明这一点，我们来新建一个枚举 PlayerType：</span><br></pre></td></tr></table></figure>\n<p>public enum PlayerType {<br>    TENNIS,<br>    FOOTBALL,<br>    BASKETBALL<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">两个关键字带一个类名，还有大括号，以及三个大写的单词，但没看到继承 Enum 类啊？别着急，心急吃不了热豆腐啊。使用 JAD 查看一下反编译后的字节码，就一清二楚了。</span><br></pre></td></tr></table></figure>\n<p>public final class PlayerType extends Enum<br>{</p>\n<pre><code>public static PlayerType[] values()\n&#123;\n    return (PlayerType[])$VALUES.clone();\n&#125;\n\npublic static PlayerType valueOf(String name)\n&#123;\n    return (PlayerType)Enum.valueOf(com/cmower/baeldung/enum1/PlayerType, name);\n&#125;\n\nprivate PlayerType(String s, int i)\n&#123;\n    super(s, i);\n&#125;\n\npublic static final PlayerType TENNIS;\npublic static final PlayerType FOOTBALL;\npublic static final PlayerType BASKETBALL;\nprivate static final PlayerType $VALUES[];\n\nstatic \n&#123;\n    TENNIS = new PlayerType(&quot;TENNIS&quot;, 0);\n    FOOTBALL = new PlayerType(&quot;FOOTBALL&quot;, 1);\n    BASKETBALL = new PlayerType(&quot;BASKETBALL&quot;, 2);\n    $VALUES = (new PlayerType[] &#123;\n        TENNIS, FOOTBALL, BASKETBALL\n    &#125;);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">看到没？PlayerType 类是 final 的，并且继承自 Enum 类。这些工作我们程序员没做，编译器帮我们悄悄地做了。此外，它还附带几个有用静态方法，比如说 values() 和  valueOf(String name)。</span><br><span class=\"line\">## 01、内部枚举</span><br><span class=\"line\">好的，小伙伴们应该已经清楚枚举长什么样子了吧？既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。</span><br></pre></td></tr></table></figure>\n<p>public class Player {<br>    private PlayerType type;<br>    public enum PlayerType {<br>        TENNIS,<br>        FOOTBALL,<br>        BASKETBALL<br>    }</p>\n<pre><code>public boolean isBasketballPlayer() &#123;\n  return getType() == PlayerType.BASKETBALL;\n&#125;\n\npublic PlayerType getType() &#123;\n    return type;\n&#125;\n\npublic void setType(PlayerType type) &#123;\n    this.type = type;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PlayerType 就相当于 Player 的内部类，isBasketballPlayer() 方法用来判断运动员是否是一个篮球运动员。</span><br><span class=\"line\">由于枚举是 final 的，可以确保在 Java 虚拟机中仅有一个常量对象（可以参照反编译后的静态代码块「static 关键字带大括号的那部分代码」），所以我们可以很安全地使用“==”运算符来比较两个枚举是否相等，参照 isBasketballPlayer() 方法。</span><br><span class=\"line\">那为什么不使用 equals() 方法判断呢？</span><br></pre></td></tr></table></figure>\n<p>if(player.getType().equals(Player.PlayerType.BASKETBALL)){};<br>if(player.getType() == Player.PlayerType.BASKETBALL){};</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“==”运算符比较的时候，如果两个对象都为 null，并不会发生 NullPointerException，而 equals() 方法则会。</span><br><span class=\"line\">另外， “==”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而 equals() 方法则不会。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.51.jpg)</span><br><span class=\"line\">## 02、枚举可用于 switch 语句</span><br><span class=\"line\">这个我在之前的一篇我去的文章中详细地说明过了，感兴趣的小伙伴可以点击链接跳转过去看一下。</span><br></pre></td></tr></table></figure>\n<p>switch (playerType) {<br>        case TENNIS:<br>            return “网球运动员费德勒”;<br>        case FOOTBALL:<br>            return “足球运动员C罗”;<br>        case BASKETBALL:<br>            return “篮球运动员詹姆斯”;<br>        case UNKNOWN:<br>            throw new IllegalArgumentException(“未知”);<br>        default:<br>            throw new IllegalArgumentException(<br>                    “运动员类型: “ + playerType);</p>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 03、枚举可以有构造方法</span><br><span class=\"line\">如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。</span><br></pre></td></tr></table></figure>\n<p>public enum PlayerType {<br>    TENNIS(“网球”),<br>    FOOTBALL(“足球”),<br>    BASKETBALL(“篮球”);</p>\n<pre><code>private String name;\n\nPlayerType(String name) &#123;\n    this.name = name;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 04、EnumSet</span><br><span class=\"line\">EnumSet 是一个专门针对枚举类型的 Set 接口的实现类，它是处理枚举类型数据的一把利器，非常高效（内部实现是位向量，我也搞不懂）。</span><br><span class=\"line\">因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.52.jpg)</span><br><span class=\"line\">下面的示例中使用 noneOf() 创建了一个空的 PlayerType 的 EnumSet；使用 allOf() 创建了一个包含所有 PlayerType 的 EnumSet。</span><br></pre></td></tr></table></figure>\n<p>public class EnumSetTest {<br>    public enum PlayerType {<br>        TENNIS,<br>        FOOTBALL,<br>        BASKETBALL<br>    }</p>\n<pre><code>public static void main(String[] args) &#123;\n    EnumSet&lt;PlayerType&gt; enumSetNone = EnumSet.noneOf(PlayerType.class);\n    System.out.println(enumSetNone);\n\n    EnumSet&lt;PlayerType&gt; enumSetAll = EnumSet.allOf(PlayerType.class);\n    System.out.println(enumSetAll);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序输出结果如下所示：</span><br></pre></td></tr></table></figure>\n<p>[]<br>[TENNIS, FOOTBALL, BASKETBALL]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有了 EnumSet 后，就可以使用 Set 的一些方法了：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.53.jpg)</span><br><span class=\"line\">## 05、EnumMap</span><br><span class=\"line\">EnumMap 是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。</span><br><span class=\"line\">和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字：</span><br></pre></td></tr></table></figure>\n<p>EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有了 EnumMap 对象后就可以使用 Map 的一些方法了：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.54.jpg)</span><br><span class=\"line\">和 HashMap 的使用方法大致相同，来看下面的例子：</span><br></pre></td></tr></table></figure>\n<p>EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);<br>enumMap.put(PlayerType.BASKETBALL,”篮球运动员”);<br>enumMap.put(PlayerType.FOOTBALL,”足球运动员”);<br>enumMap.put(PlayerType.TENNIS,”网球运动员”);<br>System.out.println(enumMap);</p>\n<p>System.out.println(enumMap.get(PlayerType.BASKETBALL));<br>System.out.println(enumMap.containsKey(PlayerType.BASKETBALL));<br>System.out.println(enumMap.remove(PlayerType.BASKETBALL));</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序输出结果如下所示：</span><br></pre></td></tr></table></figure>\n<p>{TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员}<br>篮球运动员<br>true<br>篮球运动员</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 06、单例</span><br><span class=\"line\">通常情况下，实现一个单例并非易事，不信，来看下面这段代码</span><br></pre></td></tr></table></figure>\n<p>public class Singleton {<br>    private volatile static Singleton singleton;<br>    private Singleton (){}<br>    public static Singleton getSingleton() {<br>    if (singleton == null) {<br>        synchronized (Singleton.class) {<br>        if (singleton == null) {<br>            singleton = new Singleton();<br>        }<br>        }<br>    }<br>    return singleton;<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">但枚举的出现，让代码量减少到极致：</span><br></pre></td></tr></table></figure>\n<p>public enum EasySingleton{<br>    INSTANCE;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">完事了，真的超级短，有没有？枚举默认实现了 Serializable 接口，因此 Java 虚拟机可以保证该类为单例，这与传统的实现方式不大相同。传统方式中，我们必须确保单例在反序列化期间不能创建任何新实例。</span><br><span class=\"line\">## 07、枚举可与数据库交互</span><br><span class=\"line\">我们可以配合 Mybatis 将数据库字段转换为枚举类型。现在假设有一个数据库字段 check_type 的类型如下：</span><br></pre></td></tr></table></figure>\n<p><code>check_type</code> int(1) DEFAULT NULL COMMENT ‘检查类型（1：未通过、2：通过）’,</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">它对应的枚举类型为 CheckType，代码如下：</span><br></pre></td></tr></table></figure>\n<p>public enum CheckType {<br>    NO_PASS(0, “未通过”), PASS(1, “通过”);<br>    private int key;</p>\n<pre><code>private String text;\n\nprivate CheckType(int key, String text) &#123;\n    this.key = key;\n    this.text = text;\n&#125;\n\npublic int getKey() &#123;\n    return key;\n&#125;\n\npublic String getText() &#123;\n    return text;\n&#125;\n\nprivate static HashMap&lt;Integer,CheckType&gt; map = new HashMap&lt;Integer,CheckType&gt;();\nstatic &#123;\n    for(CheckType d : CheckType.values())&#123;\n        map.put(d.key, d);\n    &#125;\n&#125;\n\npublic static CheckType parse(Integer index) &#123;\n    if(map.containsKey(index))&#123;\n        return map.get(index);\n    &#125;\n    return null;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）CheckType 添加了构造方法，还有两个字段，key 为 int 型，text 为 String 型。</span><br><span class=\"line\">（2）CheckType 中有一个public static CheckType parse(Integer index)方法，可将一个 Integer 通过 key 的匹配转化为枚举类型。</span><br><span class=\"line\">那么现在，我们可以在 Mybatis 的配置文件中使用 typeHandler 将数据库字段转化为枚举类型。</span><br></pre></td></tr></table></figure>\n<resultMap id=\"CheckLog\" type=\"com.entity.CheckLog\">\n  <id property=\"id\" column=\"id\"/>\n  <result property=\"checkType\" column=\"check_type\" typeHandler=\"com.CheckTypeHandler\"></result>\n</resultMap>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中 checkType 字段对应的类如下：</span><br></pre></td></tr></table></figure>\npublic class CheckLog implements Serializable {\n\n<pre><code>private String id;\nprivate CheckType checkType;\n\npublic String getId() &#123;\n    return id;\n&#125;\n\npublic void setId(String id) &#123;\n    this.id = id;\n&#125;\n\npublic CheckType getCheckType() &#123;\n    return checkType;\n&#125;\n\npublic void setCheckType(CheckType checkType) &#123;\n    this.checkType = checkType;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CheckTypeHandler 转换器的类源码如下：</span><br></pre></td></tr></table></figure>\n<p>public class CheckTypeHandler extends BaseTypeHandler<CheckType> {</p>\n<pre><code>@Override\npublic CheckType getNullableResult(ResultSet rs, String index) throws SQLException &#123;\n    return CheckType.parse(rs.getInt(index));\n&#125;\n\n@Override\npublic CheckType getNullableResult(ResultSet rs, int index) throws SQLException &#123;\n    return CheckType.parse(rs.getInt(index));\n&#125;\n\n@Override\npublic CheckType getNullableResult(CallableStatement cs, int index) throws SQLException &#123;\n    return CheckType.parse(cs.getInt(index));\n&#125;\n\n@Override\npublic void setNonNullParameter(PreparedStatement ps, int index, CheckType val, JdbcType arg3) throws SQLException &#123;\n    ps.setInt(index, val.getKey());\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CheckTypeHandler 的核心功能就是调用 CheckType 枚举类的 parse() 方法对数据库字段进行转换。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.55.jpg)</span><br><span class=\"line\">恕我直言，我觉得小伙伴们肯定会用 Java 枚举了，如果还不会，就过来砍我！</span><br><span class=\"line\"># 十七、final 关键字</span><br><span class=\"line\">尽管继承可以让我们重用现有代码，但有时处于某些原因，我们确实需要对可扩展性进行限制，final 关键字可以帮助我们做到这一点。</span><br><span class=\"line\">## 01、final 类</span><br><span class=\"line\">如果一个类使用了 final 关键字修饰，那么它就无法被继承。如果小伙伴们细心观察的话，Java 就有不少 final 类，比如说最常见的 String 类。</span><br></pre></td></tr></table></figure>\n<p>public final class String<br>    implements java.io.Serializable, Comparable<String>, CharSequence,<br>               Constable, ConstantDesc {}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为什么 String 类要设计成 final 的呢？原因大致有以下三个：</span><br><span class=\"line\"></span><br><span class=\"line\">- 为了实现字符串常量池</span><br><span class=\"line\">- 为了线程安全</span><br><span class=\"line\">- 为了 HashCode 的不可变性</span><br><span class=\"line\"></span><br><span class=\"line\">更详细的原因，可以查看我之前写的一篇文章。</span><br><span class=\"line\">任何尝试从 final 类继承的行为将会引发编译错误，为了验证这一点，我们来看下面这个例子，Writer 类是 final 的。</span><br></pre></td></tr></table></figure>\n<p>public final class Writer {<br>    private String name;</p>\n<pre><code>public String getName() &#123;\n    return name;\n&#125;\n\npublic void setName(String name) &#123;\n    this.name = name;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">尝试去继承它，编译器会提示以下错误，Writer 类是 final 的，无法继承。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.56.jpg)</span><br><span class=\"line\">不过，类是 final 的，并不意味着该类的对象是不可变的。</span><br></pre></td></tr></table></figure>\n<p>Writer writer = new Writer();<br>writer.setName(“沉默王二”);<br>System.out.println(writer.getName()); // 沉默王二</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer 的 name 字段的默认值是 null，但可以通过 settter 方法将其更改为“沉默王二”。也就是说，如果一个类只是 final 的，那么它并不是不可变的全部条件。</span><br><span class=\"line\">如果，你想了解不可变类的全部真相，请查看我之前写的文章这次要说不明白immutable类，我就怎么地。突然发现，写系列文章真的妙啊，很多相关性的概念全部涉及到了。我真服了自己了。</span><br><span class=\"line\">把一个类设计成 final 的，有其安全方面的考虑，但不应该故意为之，因为把一个类定义成 final 的，意味着它没办法继承，假如这个类的一些方法存在一些问题的话，我们就无法通过重写的方式去修复它。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.57.jpg)</span><br><span class=\"line\">## 02、final 方法</span><br><span class=\"line\">被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它设计成 final 的。</span><br><span class=\"line\">Thread 类就是一个例子，它本身不是 final 的，这意味着我们可以扩展它，但它的 isAlive() 方法是 final 的：</span><br></pre></td></tr></table></figure>\n<p>public class Thread implements Runnable {<br>    public final native boolean isAlive();<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需要注意的是，该方法是一个本地（native）方法，用于确认线程是否处于活跃状态。而本地方法是由操作系统决定的，因此重写该方法并不容易实现。</span><br><span class=\"line\">Actor 类有一个 final 方法 show()：</span><br></pre></td></tr></table></figure>\n<p>public class Actor {<br>    public final void show() {</p>\n<pre><code>&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当我们想要重写该方法的话，就会出现编译错误：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.58.jpg)</span><br><span class=\"line\">如果一个类中的某些方法要被其他方法调用，则应考虑事被调用的方法称为 final 方法，否则，重写该方法会影响到调用方法的使用。</span><br><span class=\"line\">一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？</span><br><span class=\"line\">我能想到的一点，就是前者不能被继承，也就是说方法无法被重写；后者呢，可以被继承，然后追加一些非 final 的方法。没毛病吧？看把我聪明的。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.59.jpg)</span><br><span class=\"line\">## 03、final 变量</span><br><span class=\"line\">被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。之前被一个小伙伴问过，什么是 effective final，什么是 final，这一点，我在之前的文章也有阐述过，所以这里再贴一下地址：</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.itwanger.com/java/2020/0%E2%80%A6\">www.itwanger.com/java/2020/0…</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）final 修饰的基本数据类型</span><br><span class=\"line\">来声明一个 final 修饰的 int 类型的变量：</span><br></pre></td></tr></table></figure>\n<p>final int age = 18;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">尝试将它修改为 30，结果编译器生气了：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.60.jpg)</span><br><span class=\"line\">（2）final 修饰的引用类型</span><br><span class=\"line\">现在有一个普通的类 Pig，它有一个字段 name：</span><br></pre></td></tr></table></figure>\n<p>public class Pig {<br>   private String name;</p>\n<pre><code>public String getName() &#123;\n    return name;\n&#125;\n\npublic void setName(String name) &#123;\n    this.name = name;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在测试类中声明一个 final 修饰的 Pig 对象：</span><br><span class=\"line\"> final Pig pig = new Pig();</span><br><span class=\"line\">如果尝试将 pig 重新赋值的话，编译器同样会生气：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.61.jpg)</span><br><span class=\"line\">但我们仍然可以去修改 Pig 的字段值：</span><br></pre></td></tr></table></figure>\n<p>final Pig pig = new Pig();<br>pig.setName(“特立独行”);<br>System.out.println(pig.getName()); // 特立独行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（3）final 修饰的字段</span><br><span class=\"line\">final 修饰的字段可以分为两种，一种是 static 的，另外一种是没有 static 的，就像下面这样：</span><br></pre></td></tr></table></figure>\n<p>public class Pig {<br>   private final int age = 1;<br>   public static final double PRICE = 36.5;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">非 static 的 final 字段必须有一个默认值，否则编译器将会提醒没有初始化：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.62.jpg)</span><br><span class=\"line\">static 的 final 字段也叫常量，它的名字应该为大写，可以在声明的时候初始化，也可以通过 static 代码块初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">(4) final 修饰的参数</span><br><span class=\"line\"></span><br><span class=\"line\">final 关键字还可以修饰参数，它意味着参数在方法体内不能被再修改：</span><br></pre></td></tr></table></figure>\n<p>public class ArgFinalTest {<br>    public void arg(final int age) {<br>    }</p>\n<pre><code>public void arg1(final String name) &#123;\n&#125;\n</code></pre>\n<p>}</p>\n<p>```<br>如果尝试去修改它的话，编译器会提示以下错误：<br><img src=\"https://www.qyihe.xyz/images/post/10.63.jpg\"><br>。。。。。。</p>\n<blockquote>\n<p>转载于<a href=\"https://juejin.im/post/5ee414c76fb9a047dd2768ea#heading-39\">沉默王二</a></p>\n</blockquote>\n","site":{"data":{"link":{"class":{"class_name":null,"link_list":{"1":{"name":"Liam's Blog","link":"https://www.ccyh.xyz","avatar":"https://www.ccyh.xyz/img/myavatar.jpg","descr":"Talk Less, Think More"},"3":{"name":"新逸Cary","link":"https://blog.xinac.cn/","avatar":"https://alicdn.xinac.net/blog/avatar_1587692611685.gif","descr":"一个专注技术的程序猿"},"4":{"name":"白程序员的自习室","link":"https://www.studytime.xin","avatar":null,"descr":"白程序员的自习室，在这里有程序员的故事和技术，分享日常学习的知识和技术。"},"5":{"name":"Guyi' s Blog","link":"https://www.y2jq.com","avatar":"https://y2jq.com/pic/logo.jpg","descr":"人要清醒，外面的掌声越热烈越危险"},"7":{"name":"飞哥专栏","link":"https://www.ffeeii.com/","avatar":"https://ffeeii1.oss-cn-hangzhou.aliyuncs.com/2020/06/ffeeii_com_logo.jpg","descr":"关注技术开发和工程效率"}}}}}},"excerpt":"","more":"<p>这么说吧，在我眼里，Java 就是最流行的编程语言，没有之一（PHP 往一边站）。不仅岗位多，容易找到工作，关键是薪资水平也到位，不学 Java 亏得慌，对吧？<br>那可能零基础学编程的小伙伴就会头疼了，网上关于 Java 的大部分技术文章都不够幽默，不够风趣，不够系列，急需要一份能看得进去的学习手册，那我觉得我肝的这份手册正好符合要求，并且会一直持续更新下去。<br>第一版的内容暂时包含两方面，Java 基础和 Java 面向对象编程。来吧，先上目录，一睹为快。<br>01、Java 基本语法简介<br>02、Java 基本数据类型简介<br>03、Java main() 方法简介<br>04、Java 的流程控制语句<br>05、Java 包的简介<br>06、Java 到底是值传递还是引用传递<br>07、Java 的类和对象<br>08、Java 构造方法<br>09、Java 抽象类<br>10、Java 接口<br>11、Java 继承<br>12、this 关键字<br>13、super 关键字<br>14、重写和重载<br>15、static 关键字<br>16、Java 枚举<br>17、final 关键字<br>目录欣赏完了，接下来就是拜读精华内容的时间，搬个小板凳，认认真真好好学吧，学到就是赚到！</p>\n<h1 id=\"一、Java-基本语法简介\"><a href=\"#一、Java-基本语法简介\" class=\"headerlink\" title=\"一、Java 基本语法简介\"></a>一、Java 基本语法简介</h1><h2 id=\"01、数据类型\"><a href=\"#01、数据类型\" class=\"headerlink\" title=\"01、数据类型\"></a>01、数据类型</h2><p>Java 有 2 种数据类型，一种是基本数据类型，一种是引用类型。<br>基本数据类型用于存储简单类型的数据，比如说，int、long、byte、short 用于存储整数，float、double 用于存储浮点数，char 用于存储字符，boolean 用于存储布尔值。<br>不同的基本数据类型，有不同的默认值和大小，来个表格感受下。</p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>默认值</th>\n<th>大小</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean</td>\n<td>false</td>\n<td>1比特</td>\n</tr>\n<tr>\n<td>char</td>\n<td>0</td>\n<td>2字节</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>0</td>\n<td>1字节</td>\n</tr>\n<tr>\n<td>short</td>\n<td>0</td>\n<td>2字节</td>\n</tr>\n<tr>\n<td>int</td>\n<td>0</td>\n<td>4字节</td>\n</tr>\n<tr>\n<td>long</td>\n<td>0L</td>\n<td>8字节</td>\n</tr>\n<tr>\n<td>float</td>\n<td>0.0f</td>\n<td>4字节</td>\n</tr>\n<tr>\n<td>double</td>\n<td>0.0</td>\n<td>8字节</td>\n</tr>\n</tbody></table>\n<p>引用类型用于存储对象（null 表示没有值的对象）的引用，String 是引用类型的最佳代表，比如说 String cmower = “沉默王二”。</p>\n<h2 id=\"02、声明变量\"><a href=\"#02、声明变量\" class=\"headerlink\" title=\"02、声明变量\"></a>02、声明变量</h2><p>要声明一个变量，必须指定它的名字和类型，来看一个简单的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age;</span><br><span class=\"line\">String name;</span><br></pre></td></tr></table></figure>\n<p>count 和 name 在声明后会得到一个默认值，按照它们的数据类型——不能是局部变量（否则 Java 编译器会在你使用变量的时候提醒要先赋值），必须是类成员变量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SyntaxLocalVariable &#123;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SyntaxLocalVariable syntax = new SyntaxLocalVariable();</span><br><span class=\"line\">        System.out.println(syntax.age); // 输出 0</span><br><span class=\"line\">        System.out.println(syntax.name);  // 输出 null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以在声明一个变量后使用“=”操作符进行赋值，就像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age = 18;</span><br><span class=\"line\">String name = &quot;沉默王二&quot;;</span><br></pre></td></tr></table></figure>\n<p>我们定义了 2 个变量，int 类型的 age 和 String 类型的 name，age 赋值 18，name 赋值为“沉默王二”。<br>每行代码后面都跟了一个“;”，表示当前语句结束了。<br>在 Java 中，变量最好遵守命名约定，这样能提高代码的可阅读性。</p>\n<ul>\n<li>以字母、下划线（_）或者美元符号（$）开头</li>\n<li>不能使用 Java 的保留字，比如说 int 不能作为变量名</li>\n</ul>\n<h2 id=\"03、数组\"><a href=\"#03、数组\" class=\"headerlink\" title=\"03、数组\"></a>03、数组</h2><p>数组在 Java 中占据着重要的位置，它是很多集合类的底层实现。数组属于引用类型，它用来存储一系列指定类型的数据。<br>声明数组的一般语法如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type[] identiier = new type[length];</span><br></pre></td></tr></table></figure>\n<p>type 可以是任意的基本数据类型或者引用类型。来看下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ArraysDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int [] nums = new int[10];</span><br><span class=\"line\">        nums[0] = 18;</span><br><span class=\"line\">        nums[1] = 19;</span><br><span class=\"line\">        System.out.println(nums[0]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数组的索引从 0 开始，第一个元素的索引为 0，第二个元素的索引为 1。为什么要这样设计？感兴趣的话，你可以去探究一下。<br>通过变量名[索引]的方式可以访问数组指定索引处的元素，赋值或者取值是一样的。</p>\n<h2 id=\"04、关键字\"><a href=\"#04、关键字\" class=\"headerlink\" title=\"04、关键字\"></a>04、关键字</h2><p>关键字属于保留字，在 Java 中具有特殊的含义，比如说 public、final、static、new 等等，它们不能用来作为变量名。为了便于你作为参照，我列举了 48 个常用的关键字，你可以瞅一瞅。</p>\n<p>1： abstract： abstract 关键字用于声明抽象类——可以有抽象和非抽象方法。</p>\n<p>2： boolean： boolean 关键字用于将变量声明为布尔值类型，它只有 true 和 false 两个值。</p>\n<p>3： break： break 关键字用于中断循环或 switch 语句。</p>\n<p>4： byte： byte 关键字用于声明一个可以容纳 8 个比特的变量。</p>\n<p>5： case： case 关键字用于在 switch 语句中标记条件的值。</p>\n<p>6： catch： catch 关键字用于捕获 try 语句中的异常。</p>\n<p>7： char： char 关键字用于声明一个可以容纳无符号 16 位比特的 Unicode 字符的变量。</p>\n<p>8： class： class 关键字用于声明一个类。</p>\n<p>9： continue： continue 关键字用于继续下一个循环。它可以在指定条件下跳过其余代码。</p>\n<p>10：default： default 关键字用于指定 switch 语句中除去 case 条件之外的默认代码块。</p>\n<p>11：do： do 关键字通常和 while 关键字配合使用，do 后紧跟循环体。</p>\n<p>12：double： double 关键字用于声明一个可以容纳 64 位浮点数的变量。</p>\n<p>13：else： else 关键字用于指示 if 语句中的备用分支。</p>\n<p>14：enum： enum（枚举）关键字用于定义一组固定的常量。</p>\n<p>15：extends： extends 关键字用于指示一个类是从另一个类或接口继承的。</p>\n<p>16：final： final 关键字用于指示该变量是不可更改的。</p>\n<p>17：finally： finally 关键字和 try-catch 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</p>\n<p>18：float： float 关键字用于声明一个可以容纳 32 位浮点数的变量。</p>\n<p>19：for： for 关键字用于启动一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</p>\n<p>20：if： if 关键字用于指定条件，如果条件为真，则执行对应代码。</p>\n<p>21：implements： implements 关键字用于实现接口。</p>\n<p>22：import： import 关键字用于导入对应的类或者接口。</p>\n<p>23：instanceof： instanceof 关键字用于判断对象是否属于某个类型（class）。</p>\n<p>24：int： int 关键字用于声明一个可以容纳 32 位带符号的整数变量。</p>\n<p>25：interface： interface 关键字用于声明接口——只能具有抽象方法。</p>\n<p>26：long： long 关键字用于声明一个可以容纳 64 位整数的变量。</p>\n<p>27：native： native 关键字用于指定一个方法是通过调用本机接口（非 Java）实现的。</p>\n<p>28：new： new 关键字用于创建一个新的对象。</p>\n<p>29：null： 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null。</p>\n<p>30：package： package 关键字用于声明类所在的包。</p>\n<p>31：private： private 关键字是一个访问修饰符，表示方法或变量只对当前类可见。</p>\n<p>32：protected： protected 关键字也是一个访问修饰符，表示方法或变量对同一包内的类和所有子类可见。</p>\n<p>33：public： public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。</p>\n<p>34：return： return 关键字用于在代码执行完成后返回（一个值）。</p>\n<p>35：short： short 关键字用于声明一个可以容纳 16 位整数的变量。</p>\n<p>36：static： static 关键字表示该变量或方法是静态变量或静态方法。</p>\n<p>37：strictfp：  strictfp 关键字并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。</p>\n<p>38：super： super 关键字可用于调用父类的方法或者变量。</p>\n<p>39：switch： switch 关键字通常用于三个（以上）的条件判断。</p>\n<p>40：synchronized： synchronized 关键字用于指定多线程代码中的同步方法、变量或者代码块。</p>\n<p>41：this： this 关键字可用于在方法或构造函数中引用当前对象。</p>\n<p>42：throw： throw 关键字主动抛出异常。</p>\n<p>43：throws： throws 关键字用于声明异常。</p>\n<p>44：transient： transient 关键字在序列化的使用用到，它修饰的字段不会被序列化。</p>\n<p>45：try： try 关键字用于包裹要捕获异常的代码块。</p>\n<p>46：void： void 关键字用于指定方法没有返回值。</p>\n<p>47：volatile： volatile 关键字保证了不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>\n<p>48：while： 如果循环次数不固定，建议使用 while 循环。<br><img src=\"https://www.qyihe.xyz/images/post/10.1.jpg\"></p>\n<h2 id=\"05、操作符\"><a href=\"#05、操作符\" class=\"headerlink\" title=\"05、操作符\"></a>05、操作符</h2><p>除去“=”赋值操作符，Java 中还有很多其他作用的操作符，我们来大致看一下。</p>\n<h3 id=\"①、算术运算符\"><a href=\"#①、算术运算符\" class=\"headerlink\" title=\"①、算术运算符\"></a>①、算术运算符</h3><ul>\n<li> +（加号）</li>\n<li> –（减号）</li>\n<li> *（乘号）</li>\n<li> /（除号）</li>\n<li> ％（取余）</li>\n</ul>\n<p>来看一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ArithmeticOperator &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a = 10;</span><br><span class=\"line\">        int b = 5;</span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(a + b);//15  </span><br><span class=\"line\">        System.out.println(a - b);//5  </span><br><span class=\"line\">        System.out.println(a * b);//50  </span><br><span class=\"line\">        System.out.println(a / b);//2  </span><br><span class=\"line\">        System.out.println(a % b);//0  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>“+”号比较特殊，还可以用于字符串拼接，来看一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String result = &quot;沉默王二&quot; + &quot;一枚有趣的程序员&quot;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"②、逻辑运算符\"><a href=\"#②、逻辑运算符\" class=\"headerlink\" title=\"②、逻辑运算符\"></a>②、逻辑运算符</h3><p>逻辑运算符通常用于布尔表达式，常见的有：</p>\n<ul>\n<li>&amp;&amp;（AND）多个条件中只要有一个为 false 结果就为 false</li>\n<li>||（OR）多个条件只要有一个为 true 结果就为 true</li>\n<li>!（NOT）条件如果为 true，加上“!”就为 false，否则，反之。</li>\n</ul>\n<p>来看一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LogicalOperator &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int a=10;</span><br><span class=\"line\">        int b=5;</span><br><span class=\"line\">        int c=20;</span><br><span class=\"line\">        System.out.println(a&lt;b&amp;&amp;a&lt;c);//false</span><br><span class=\"line\">        System.out.println(a&gt;b||a&lt;c);//true</span><br><span class=\"line\">        System.out.println(!(a&lt;b)); // true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"③、比较运算符\"><a href=\"#③、比较运算符\" class=\"headerlink\" title=\"③、比较运算符\"></a>③、比较运算符</h3><ul>\n<li> &lt; (小于)</li>\n<li> &lt;= (小于或者等于)</li>\n<li><blockquote>\n<p>(大于)</p>\n</blockquote>\n</li>\n<li> &gt;= (大于或者等于)</li>\n<li> == (相等)</li>\n<li> != (不等)</li>\n</ul>\n<h2 id=\"06、程序结构\"><a href=\"#06、程序结构\" class=\"headerlink\" title=\"06、程序结构\"></a>06、程序结构</h2><p>Java 中最小的程序单元叫做类，一个类可以有一个或者多个字段（也叫作成员变量），还可以有一个或者多个方法，甚至还可以有一些内部类。<br>如果一个类想要执行，就必须有一个 main 方法——程序运行的入口，就好像人的嘴一样，嗯，可以这么牵强的理解一下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StructureProgram &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(&quot;没有成员变量，只有一个 main 方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类名叫做 StructureProgram，在它里面，只有一个 main 方法。</li>\n<li>{} 之间的代码称之为代码块。</li>\n<li>以上源代码将会保存在一个后缀名为 java 的文件中。</li>\n</ul>\n<h2 id=\"07、编译然后执行代码\"><a href=\"#07、编译然后执行代码\" class=\"headerlink\" title=\"07、编译然后执行代码\"></a>07、编译然后执行代码</h2><p>通常，一些教程在介绍这块内容的时候，建议你通过命令行中先执行 javac 命令将源代码编译成字节码文件，然后再执行 java 命令指定代码。<br>但我不希望这个糟糕的局面再继续下去了——新手安装配置 JDK 真的蛮需要勇气和耐心的，稍有不慎，没入门就先放弃了。况且，在命令行中编译源代码会遇到很多莫名其妙的错误，这对新手是极其致命的——如果你再遇到这种老式的教程，可以吐口水了。<br>好的方法，就是去下载 IntelliJ IDEA，简称 IDEA，它被业界公认为最好的 Java 集成开发工具，尤其在智能代码助手、代码自动提示、代码重构、代码版本管理(Git、SVN、Maven)、单元测试、代码分析等方面有着亮眼的发挥。IDEA 产于捷克（位于东欧），开发人员以严谨著称。IDEA 分为社区版和付费版两个版本，新手直接下载社区版就足够用了。<br>安装成功后，可以开始敲代码了，然后直接右键运行（连保存都省了），结果会在 Run 面板中显示，如下图所示。<br><img src=\"https://www.qyihe.xyz/images/post/10.2.jpg\"><br>想查看反编译后的字节码的话，可以在 src 的同级目录 target/classes 的包路径下找到一个 StructureProgram.class 的文件（如果找不到的话，在目录上右键选择「Reload from Disk」）。<br>可以双击打开它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//</span><br><span class=\"line\">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class=\"line\">// (powered by Fernflower decompiler)</span><br><span class=\"line\">//</span><br><span class=\"line\"></span><br><span class=\"line\">package com.cmower.baeldung.basic;</span><br><span class=\"line\"></span><br><span class=\"line\">public class StructureProgram &#123;</span><br><span class=\"line\">    public StructureProgram() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(&quot;没有成员变量，只有一个 main 方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>IDEA 默认会用 Fernflower 将 class 字节码反编译为我们可以看得懂的 Java 代码。实际上，class 字节码（请安装 show bytecode 插件）长下面这个样子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// class version 57.65535 (-65479)</span><br><span class=\"line\">// access flags 0x21</span><br><span class=\"line\">public class com/cmower/baeldung/basic/StructureProgram &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // compiled from: StructureProgram.java</span><br><span class=\"line\"></span><br><span class=\"line\">  // access flags 0x1</span><br><span class=\"line\">  public &lt;init&gt;()V</span><br><span class=\"line\">   L0</span><br><span class=\"line\">    LINENUMBER 3 L0</span><br><span class=\"line\">    ALOAD 0</span><br><span class=\"line\">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class=\"line\">    RETURN</span><br><span class=\"line\">   L1</span><br><span class=\"line\">    LOCALVARIABLE this Lcom/cmower/baeldung/basic/StructureProgram; L0 L1 0</span><br><span class=\"line\">    MAXSTACK = 1</span><br><span class=\"line\">    MAXLOCALS = 1</span><br><span class=\"line\"></span><br><span class=\"line\">  // access flags 0x9</span><br><span class=\"line\">  public static main([Ljava/lang/String;)V</span><br><span class=\"line\">   L0</span><br><span class=\"line\">    LINENUMBER 5 L0</span><br><span class=\"line\">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class=\"line\">    LDC &quot;\\u6ca1\\u6709\\u6210\\u5458\\u53d8\\u91cf\\uff0c\\u53ea\\u6709\\u4e00\\u4e2a main \\u65b9\\u6cd5&quot;</span><br><span class=\"line\">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class=\"line\">   L1</span><br><span class=\"line\">    LINENUMBER 6 L1</span><br><span class=\"line\">    RETURN</span><br><span class=\"line\">   L2</span><br><span class=\"line\">    LOCALVARIABLE args [Ljava/lang/String; L0 L2 0</span><br><span class=\"line\">    MAXSTACK = 2</span><br><span class=\"line\">    MAXLOCALS = 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新手看起来还是有些懵逼的，建议过过眼瘾就行了。<br><img src=\"https://www.qyihe.xyz/images/post/10.3.jpg\"></p>\n<h1 id=\"二、Java-基本数据类型简介\"><a href=\"#二、Java-基本数据类型简介\" class=\"headerlink\" title=\"二、Java 基本数据类型简介\"></a>二、Java 基本数据类型简介</h1><h2 id=\"01、布尔\"><a href=\"#01、布尔\" class=\"headerlink\" title=\"01、布尔\"></a>01、布尔</h2><p>布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean flag = true;</span><br></pre></td></tr></table></figure>\n<h2 id=\"02、byte\"><a href=\"#02、byte\" class=\"headerlink\" title=\"02、byte\"></a>02、byte</h2><p>byte 的取值范围在 -128 和 127 之间，包含 127。最小值为 -128，最大值为 127，默认值为 0。<br>在网络传输的过程中，为了节省空间，常用字节来作为数据的传输方式。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte a = 10;</span><br><span class=\"line\">byte b = -10;</span><br></pre></td></tr></table></figure>\n<h2 id=\"03、short\"><a href=\"#03、short\" class=\"headerlink\" title=\"03、short\"></a>03、short</h2><p>short 的取值范围在 -32,768 和 32,767 之间，包含 32,767。最小值为 -32,768，最大值为 32,767，默认值为 0。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">short s = 10000;</span><br><span class=\"line\">short r = -5000;</span><br></pre></td></tr></table></figure>\n<h2 id=\"04、int\"><a href=\"#04、int\" class=\"headerlink\" title=\"04、int\"></a>04、int</h2><p>int 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间，默认值为 0。如果没有特殊需求，整形数据就用 int。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 100000;</span><br><span class=\"line\">int b = -200000;</span><br></pre></td></tr></table></figure>\n<h2 id=\"05、long\"><a href=\"#05、long\" class=\"headerlink\" title=\"05、long\"></a>05、long</h2><p>long 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间，默认值为 0。如果 int 存储不下，就用 long，整形数据就用 int。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long a = 100000L; </span><br><span class=\"line\">long b = -200000L;</span><br></pre></td></tr></table></figure>\n<p>为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。</p>\n<h2 id=\"06、float\"><a href=\"#06、float\" class=\"headerlink\" title=\"06、float\"></a>06、float</h2><p>float 是单精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围是无限的，默认值为 0.0f。float 不适合用于精确的数值，比如说货币。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float f1 = 234.5f;</span><br></pre></td></tr></table></figure>\n<p>为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。</p>\n<h2 id=\"07、double\"><a href=\"#07、double\" class=\"headerlink\" title=\"07、double\"></a>07、double</h2><p>double 是双精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围也是无限的，默认值为 0.0。double 同样不适合用于精确的数值，比如说货币。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double d1 = 12.3</span><br></pre></td></tr></table></figure>\n<p>那精确的数值用什么表示呢？最好使用 BigDecimal，它可以表示一个任意大小且精度完全准确的浮点数。针对货币类型的数值，也可以先乘以 100 转成整形进行处理。<br>Tips：单精度是这样的格式，1 位符号，8 位指数，23 位小数，有效位数为 7 位。<br><img src=\"https://www.qyihe.xyz/images/post/10.4.jpg\"><br>双精度是这样的格式，1 位符号，11 位指数，52 为小数，有效位数为 16 位。<br><img src=\"https://www.qyihe.xyz/images/post/10.5.jpg\"><br>取值范围取决于指数位，计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。</p>\n<blockquote>\n<p>一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。</p>\n</blockquote>\n<h2 id=\"08、char\"><a href=\"#08、char\" class=\"headerlink\" title=\"08、char\"></a>08、char</h2><p>char 可以表示一个 16 位的 Unicode 字符，其值范围在 ‘\\u0000’（0）和 ‘\\uffff’（65,535）（包含）之间。代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char letterA = &#x27;A&#x27;; // 用英文的单引号包裹住。</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、Java-main-方法简介\"><a href=\"#三、Java-main-方法简介\" class=\"headerlink\" title=\"三、Java main() 方法简介\"></a>三、Java main() 方法简介</h1><p>每个程序都需要一个入口，对于 Java 程序来说，入口就是 main 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>public、static、void 这 3 个关键字在前面的内容已·经介绍过了，如果觉得回去找比较麻烦的话，这里再贴一下：</p>\n</li>\n<li><p>public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。</p>\n</li>\n<li><p>static 关键字表示该变量或方法是静态变量或静态方法，可以直接通过类访问，不需要实例化对象来访问。</p>\n</li>\n<li><p>void 关键字用于指定方法没有返回值。</p>\n</li>\n</ul>\n<p>另外，main 关键字为方法的名字，Java 虚拟机在执行程序时会寻找这个标识符；args 为 main() 方法的参数名，它的类型为一个 String 数组，也就是说，在使用 java 命令执行程序的时候，可以给 main() 方法传递字符串数组作为参数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java HelloWorld 沉默王二 沉默王三</span><br></pre></td></tr></table></figure>\n<p>javac 命令用来编译程序，java 命令用来执行程序，HelloWorld 为这段程序的类名，沉默王二和沉默王三为字符串数组，中间通过空格隔开，然后就可以在 main() 方法中通过 args[0] 和 args[1] 获取传递的参数值了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HelloWorld &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        if (&quot;沉默王二&quot;.equals(args[0])) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (&quot;沉默王三&quot;.equals(args[1])) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>main() 方法的写法并不是唯一的，还有其他几种变体，尽管它们可能并不常见，可以简单来了解一下。</p>\n<p>第二种，把方括号 [] 往 args 靠近而不是 String 靠近：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String []args) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三种，把方括号 [] 放在 args 的右侧：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String args[]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第四种，还可以把数组形式换成可变参数的形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String...args) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第五种，在 main() 方法上添加另外一个修饰符 strictfp，用于强调在处理浮点数时的兼容性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public strictfp static void main(String[] args) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以在 main() 方法上添加 final 关键字或者 synchronized 关键字。</p>\n<p>第六种，还可以为 args 参数添加 final 关键字：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(final String[] args) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第七种，最复杂的一种，所有可以添加的关键字统统添加上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final static synchronized strictfp void main(final String[] args) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然了，并不需要为了装逼特意把 main() 方法写成上面提到的这些形式，使用 IDE 提供的默认形式就可以了。</p>\n<h1 id=\"四、Java-的流程控制语句\"><a href=\"#四、Java-的流程控制语句\" class=\"headerlink\" title=\"四、Java 的流程控制语句\"></a>四、Java 的流程控制语句</h1><ul>\n<li><p>在 Java 中，有三种类型的流程控制语句：</p>\n</li>\n<li><p>条件分支，用于在两个或者多个条件之间做出选择，常见的有 if/else/else if、三元运算符和 switch 语句。</p>\n</li>\n<li><p>循环或者遍历，常见的有 for、while 和 do-while。</p>\n</li>\n<li><p>break 和 continue，用于跳出循环或者跳过进入下一轮循环。</p>\n</li>\n</ul>\n<h2 id=\"if-语句\"><a href=\"#if-语句\" class=\"headerlink\" title=\"if 语句\"></a>if 语句</h2><p>if 语句的格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(布尔表达式)&#123;  </span><br><span class=\"line\">// 如果条件为 true，则执行这块代码</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>画个流程图表示一下：<br><img src=\"https://www.qyihe.xyz/images/post/10.6.jpg\"><br>来写个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class IfExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age = 20;</span><br><span class=\"line\">        if (age &lt; 30) &#123;</span><br><span class=\"line\">            System.out.println(&quot;青春年华&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">青春年华</span><br></pre></td></tr></table></figure>\n<h2 id=\"if-else-语句\"><a href=\"#if-else-语句\" class=\"headerlink\" title=\"if-else 语句\"></a>if-else 语句</h2><p>if-else 语句的格式如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(布尔表达式)&#123;  </span><br><span class=\"line\">// 条件为 true 时执行的代码块</span><br><span class=\"line\">&#125;else&#123;  </span><br><span class=\"line\">// 条件为 false  时执行的代码块</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>画个流程图表示一下：<br><img src=\"https://www.qyihe.xyz/images/post/10.7.jpg\"><br>来写个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class IfElseExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age = 31;</span><br><span class=\"line\">        if (age &lt; 30) &#123;</span><br><span class=\"line\">            System.out.println(&quot;青春年华&quot;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            System.out.println(&quot;而立之年&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">而立之年</span><br></pre></td></tr></table></figure>\n<p>除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LeapYear &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int year = 2020;</span><br><span class=\"line\">        if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &#123;</span><br><span class=\"line\">            System.out.println(&quot;闰年&quot;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            System.out.println(&quot;普通年份&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">闰年</span><br></pre></td></tr></table></figure>\n<p>如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class IfElseTernaryExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int num = 13;</span><br><span class=\"line\">        String result = (num % 2 == 0) ? &quot;偶数&quot; : &quot;奇数&quot;;</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">奇数</span><br></pre></td></tr></table></figure>\n<h2 id=\"if-else-if-语句\"><a href=\"#if-else-if-语句\" class=\"headerlink\" title=\"if-else-if 语句\"></a>if-else-if 语句</h2><p>if-else-if 语句的格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(条件1)&#123;  </span><br><span class=\"line\">// 条件1 为 true 时执行的代码</span><br><span class=\"line\">&#125;else if(条件2)&#123;  </span><br><span class=\"line\">// 条件2 为 true 时执行的代码</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">else if(条件3)&#123;  </span><br><span class=\"line\">// 条件3 为 true 时执行的代码</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">...  </span><br><span class=\"line\">else&#123;  </span><br><span class=\"line\">// 以上条件均为 false 时执行的代码</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>画个流程图表示一下：<br><img src=\"https://www.qyihe.xyz/images/post/10.8.jpg\"><br>来写个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class IfElseIfExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age = 31;</span><br><span class=\"line\">        if (age &lt; 30) &#123;</span><br><span class=\"line\">            System.out.println(&quot;青春年华&quot;);</span><br><span class=\"line\">        &#125; else if (age &gt;= 30 &amp;&amp; age &lt; 40 ) &#123;</span><br><span class=\"line\">            System.out.println(&quot;而立之年&quot;);</span><br><span class=\"line\">        &#125; else if (age &gt;= 40 &amp;&amp; age &lt; 50 ) &#123;</span><br><span class=\"line\">            System.out.println(&quot;不惑之年&quot;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            System.out.println(&quot;知天命&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">而立之年</span><br></pre></td></tr></table></figure>\n<h2 id=\"if-嵌套语句\"><a href=\"#if-嵌套语句\" class=\"headerlink\" title=\"if 嵌套语句\"></a>if 嵌套语句</h2><p>if 嵌套语句的格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(外侧条件)&#123;    </span><br><span class=\"line\">     // 外侧条件为 true 时执行的代码 </span><br><span class=\"line\">          if(内侧条件)&#123;  </span><br><span class=\"line\">             // 内侧条件为 true 时执行的代码</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>画个流程图表示一下：<br><img src=\"https://www.qyihe.xyz/images/post/10.9.jpg\"><br>来写个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class NestedIfExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age = 20;</span><br><span class=\"line\">        boolean isGirl = true;</span><br><span class=\"line\">        if (age &gt;= 20) &#123;</span><br><span class=\"line\">            if (isGirl) &#123;</span><br><span class=\"line\">                System.out.println(&quot;女生法定结婚年龄&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">女生法定结婚年龄</span><br></pre></td></tr></table></figure>\n<h2 id=\"switch-语句的格式：\"><a href=\"#switch-语句的格式：\" class=\"headerlink\" title=\"switch 语句的格式：\"></a>switch 语句的格式：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(变量) &#123;    </span><br><span class=\"line\">case 可选值1:    </span><br><span class=\"line\"> // 可选值1匹配后执行的代码;    </span><br><span class=\"line\"> break;  // 该关键字是可选项</span><br><span class=\"line\">case 可选值2:    </span><br><span class=\"line\"> // 可选值2匹配后执行的代码;    </span><br><span class=\"line\"> break;  // 该关键字是可选项</span><br><span class=\"line\">......    </span><br><span class=\"line\">    </span><br><span class=\"line\">default: // 该关键字是可选项     </span><br><span class=\"line\"> // 所有可选值都不匹配后执行的代码 </span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>变量可以有 1 个或者 N 个值。</p>\n</li>\n<li><p>值类型必须和变量类型是一致的，并且值是确定的。</p>\n</li>\n<li><p>值必须是唯一的，不能重复，否则编译会出错。</p>\n</li>\n<li><p>break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。</p>\n</li>\n<li><p>default 关键字也是可选的。<br><img src=\"https://www.qyihe.xyz/images/post/10.10.jpg\"><br>画个流程图：</p>\n</li>\n</ul>\n<p>来个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Switch1 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age = 20;</span><br><span class=\"line\">        switch (age) &#123;</span><br><span class=\"line\">            case 20 :</span><br><span class=\"line\">                System.out.println(&quot;上学&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case 24 :</span><br><span class=\"line\">                System.out.println(&quot;苏州工作&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case 30 :</span><br><span class=\"line\">                System.out.println(&quot;洛阳工作&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                System.out.println(&quot;未知&quot;);</span><br><span class=\"line\">                break; // 可省略</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上学</span><br></pre></td></tr></table></figure>\n<p>当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Switch2 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String name = &quot;沉默王二&quot;;</span><br><span class=\"line\">        switch (name) &#123;</span><br><span class=\"line\">            case &quot;詹姆斯&quot;:</span><br><span class=\"line\">                System.out.println(&quot;篮球运动员&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;穆里尼奥&quot;:</span><br><span class=\"line\">                System.out.println(&quot;足球教练&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;沉默王二&quot;:</span><br><span class=\"line\">            case &quot;沉默王三&quot;:</span><br><span class=\"line\">                System.out.println(&quot;乒乓球爱好者&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                throw new IllegalArgumentException(</span><br><span class=\"line\">                        &quot;名字没有匹配项&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">乒乓球爱好者</span><br></pre></td></tr></table></figure>\n<p>枚举作为 switch 语句的变量也很常见，来看例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SwitchEnumDemo &#123;</span><br><span class=\"line\">    public enum PlayerTypes &#123;</span><br><span class=\"line\">        TENNIS,</span><br><span class=\"line\">        FOOTBALL,</span><br><span class=\"line\">        BASKETBALL,</span><br><span class=\"line\">        UNKNOWN</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(createPlayer(PlayerTypes.BASKETBALL));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static String createPlayer(PlayerTypes playerType) &#123;</span><br><span class=\"line\">        switch (playerType) &#123;</span><br><span class=\"line\">            case TENNIS:</span><br><span class=\"line\">                return &quot;网球运动员费德勒&quot;;</span><br><span class=\"line\">            case FOOTBALL:</span><br><span class=\"line\">                return &quot;足球运动员C罗&quot;;</span><br><span class=\"line\">            case BASKETBALL:</span><br><span class=\"line\">                return &quot;篮球运动员詹姆斯&quot;;</span><br><span class=\"line\">            case UNKNOWN:</span><br><span class=\"line\">                throw new IllegalArgumentException(&quot;未知&quot;);</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                throw new IllegalArgumentException(</span><br><span class=\"line\">                        &quot;运动员类型: &quot; + playerType);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">篮球运动员詹姆斯</span><br></pre></td></tr></table></figure>\n<h2 id=\"循环语句比较\"><a href=\"#循环语句比较\" class=\"headerlink\" title=\"循环语句比较\"></a>循环语句比较</h2><table>\n<thead>\n<tr>\n<th>比较方式</th>\n<th>for</th>\n<th>while</th>\n<th>do-while</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>简介</td>\n<td>for 循环的次数是固定的</td>\n<td>while 循环的次数是不固定的，并且需要条件为 true</td>\n<td>do-while 循环的次数也不固定，但会至少执行一次循环，无聊条件是否为 true</td>\n</tr>\n<tr>\n<td>何时使用</td>\n<td>循环次数固定的</td>\n<td>循环次数是不固定的</td>\n<td>循环次数不固定，并且循环体至少要执行一次</td>\n</tr>\n<tr>\n<td>语法</td>\n<td>for(init:condition;++/–) {// 要执行的代码}</td>\n<td>while(condition){// 要执行的代码}</td>\n<td>do{//要执行的代码}while(condition);</td>\n</tr>\n</tbody></table>\n<h2 id=\"普通的-for-循环\"><a href=\"#普通的-for-循环\" class=\"headerlink\" title=\"普通的 for 循环\"></a>普通的 for 循环</h2><p>普通的 for 循环可以分为 4 个部分：<br>（1）初始变量：循环开始执行时的初始条件。<br>（2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。<br>（3）循环体：循环每次要执行的代码块，直到条件变为 false。<br>（4）自增/自减：初识变量变化的方式。<br>来看一下普通 for 循环的格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(初识变量;条件;自增/自减)&#123;  </span><br><span class=\"line\">// 循环体</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>画个流程图：<br><img src=\"https://www.qyihe.xyz/images/post/10.11.jpg\"><br>来个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ForExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">            System.out.println(&quot;沉默王二好帅啊&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">沉默王二好帅啊</span><br><span class=\"line\">沉默王二好帅啊</span><br><span class=\"line\">沉默王二好帅啊</span><br><span class=\"line\">沉默王二好帅啊</span><br><span class=\"line\">沉默王二好帅啊</span><br></pre></td></tr></table></figure>\n<p>循环语句还可以嵌套呢，这样就可以打印出更好玩的呢。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PyramidForExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">            for (int j = 0;j&lt;= i;j++) &#123;</span><br><span class=\"line\">                System.out.print(&quot;❤&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印出什么玩意呢？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">❤</span><br><span class=\"line\">❤❤</span><br><span class=\"line\">❤❤❤</span><br><span class=\"line\">❤❤❤❤</span><br><span class=\"line\">❤❤❤❤❤</span><br></pre></td></tr></table></figure>\n<h2 id=\"for-each\"><a href=\"#for-each\" class=\"headerlink\" title=\"for-each\"></a>for-each</h2><p>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(元素类型 元素 : 数组或集合)&#123;  </span><br><span class=\"line\">// 要执行的代码</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>来看一下示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ForEachExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String[] strs = &#123;&quot;沉默王二&quot;, &quot;一枚有趣的程序员&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (String str : strs) &#123;</span><br><span class=\"line\">            System.out.println(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">沉默王二</span><br><span class=\"line\">一枚有趣的程序员</span><br></pre></td></tr></table></figure>\n<h2 id=\"无限-for-循环\"><a href=\"#无限-for-循环\" class=\"headerlink\" title=\"无限 for 循环\"></a>无限 for 循环</h2><p>想不想体验一下无限 for 循环的威力，也就是死循环？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class InfinitiveForExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for(;;)&#123;</span><br><span class=\"line\">            System.out.println(&quot;停不下来。。。。&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">停不下来。。。。</span><br><span class=\"line\">停不下来。。。。</span><br><span class=\"line\">停不下来。。。。</span><br><span class=\"line\">停不下来。。。。</span><br></pre></td></tr></table></figure>\n<p>一旦运行起来，就停不下来了，除非强制停止。</p>\n<h2 id=\"while-循环\"><a href=\"#while-循环\" class=\"headerlink\" title=\"while 循环\"></a>while 循环</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(条件)&#123;  </span><br><span class=\"line\">//循环体  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>画个流程图：<br><img src=\"https://www.qyihe.xyz/images/post/10.12.jpg\"><br>来个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WhileExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int i = 0;</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            System.out.println(&quot;沉默王二&quot;);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            if (i == 5) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>猜猜会输出几次？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br></pre></td></tr></table></figure>\n<h2 id=\"do-while-循环\"><a href=\"#do-while-循环\" class=\"headerlink\" title=\"do-while 循环\"></a>do-while 循环</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do&#123;  </span><br><span class=\"line\">// 循环体</span><br><span class=\"line\">&#125;while(提交); </span><br></pre></td></tr></table></figure>\n<p>画个流程图：<br><img src=\"https://www.qyihe.xyz/images/post/10.13.jpg\"><br>来个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DoWhileExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int i = 0;</span><br><span class=\"line\">        do &#123;</span><br><span class=\"line\">            System.out.println(&quot;沉默王二&quot;);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            if (i == 5) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; while (true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序输出结果如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br><span class=\"line\">沉默王二</span><br></pre></td></tr></table></figure>\n<h2 id=\"break\"><a href=\"#break\" class=\"headerlink\" title=\"break\"></a>break</h2><p>break 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。<br>可以将 break 关键字用于所有类型循环语句中，比如说 for 循环，while 循环，以及 do-while 循环。<br>来画个流程图感受一下：<br><img src=\"https://www.qyihe.xyz/images/post/10.14.jpg\"><br>用在 for 循环中的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class=\"line\">    if (i == 5) &#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用在嵌套 for 循环中的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class=\"line\">    for (int j = 1; j &lt;= 3; j++) &#123;</span><br><span class=\"line\">        if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(i + &quot; &quot; + j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用在 while 循环中的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 1;</span><br><span class=\"line\">while (i &lt;= 10) &#123;</span><br><span class=\"line\">    if (i == 5) &#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(i);</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用在 do-while 循环中的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int j = 1;</span><br><span class=\"line\">do &#123;</span><br><span class=\"line\">    if (j == 5) &#123; </span><br><span class=\"line\">        j++;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(j);</span><br><span class=\"line\">    j++;</span><br><span class=\"line\">&#125; while (j &lt;= 10);</span><br></pre></td></tr></table></figure>\n<h2 id=\"continue\"><a href=\"#continue\" class=\"headerlink\" title=\"continue\"></a>continue</h2><p>当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。<br>来个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ContinueDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class=\"line\">            if (i == 5) &#123;</span><br><span class=\"line\">                // 使用 continue 关键字</span><br><span class=\"line\">                continue;// 5 将会被跳过</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>5 真的被跳过了。<br>再来个循环嵌套的例子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ContinueInnerDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class=\"line\">            for (int j = 1; j &lt;= 3; j++) &#123;</span><br><span class=\"line\">                if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class=\"line\">                    //  当i=2，j=2时跳过</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(i + &quot; &quot; + j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印出什么玩意呢？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 1</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 3</span><br><span class=\"line\">2 1</span><br><span class=\"line\">2 3</span><br><span class=\"line\">3 1</span><br><span class=\"line\">3 2</span><br><span class=\"line\">3 3</span><br></pre></td></tr></table></figure>\n<p>“2 2” 没有输出，被跳过了。<br>再来看一下 while 循环时 continue 的使用示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ContinueWhileDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int i = 1;</span><br><span class=\"line\">        while (i &lt;= 10) &#123;</span><br><span class=\"line\">            if (i == 5) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。<br>最后，再来看一下 do-while 循环时 continue 的使用示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ContinueDoWhileDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int i=1;</span><br><span class=\"line\">        do&#123;</span><br><span class=\"line\">            if(i==5)&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;while(i&lt;=10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p>\n<h1 id=\"五、Java-包的简介\"><a href=\"#五、Java-包的简介\" class=\"headerlink\" title=\"五、Java 包的简介\"></a>五、Java 包的简介</h1><p>在 Java 中，我们使用 package（包）对相关的类、接口和子包进行分组。这样做的好处有：</p>\n<ul>\n<li>使相关类型更容易查找</li>\n<li>避免命名冲突，比如说 com.itwanger.Hello 和 com.itwangsan.Hello 不同</li>\n<li>通过包和访问权限控制符来限定类的可见性</li>\n</ul>\n<h2 id=\"01、创建一个包\"><a href=\"#01、创建一个包\" class=\"headerlink\" title=\"01、创建一个包\"></a>01、创建一个包</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.itwanger;</span><br></pre></td></tr></table></figure>\n<p>可以使用 package 关键字来定义一个包名，需要注意的是，这行代码必须处于一个类中的第一行。强烈建议在包中声明类，不要缺省，否则就失去了包结构的带来的好处。<br>包的命名应该遵守以下规则：</p>\n<ul>\n<li>应该全部是小写字母</li>\n<li>可以包含多个单词，单词之间使用“.”连接，比如说 java.lang</li>\n<li>名称由公司名或者组织名确定，采用倒序的方式，比如说，我个人博客的域名是 <a href=\"http://www.itwanger.com,所以我创建的包名是就是/\">www.itwanger.com，所以我创建的包名是就是</a> com.itwanger.xxxx。</li>\n</ul>\n<p>每个包或者子包都在磁盘上有自己的目录结构，如果 Java 文件时在 com.itwanger.xxxx 包下，那么该文件所在的目录结构就应该是 com-&gt;itwanger-&gt;xxxx。</p>\n<h2 id=\"02、使用包\"><a href=\"#02、使用包\" class=\"headerlink\" title=\"02、使用包\"></a>02、使用包</h2><p>让我们在名为 test 的子包里新建一个 Cmower 类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.itwanger.test;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Cmower &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果需要在另外一个包中使用 Cmower 类，就需要通过 import 关键字将其引入。有两种方式可供选择，第一种，使用 * 导入包下所有的类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.itwanger.test.*;</span><br></pre></td></tr></table></figure>\n<p>第二种，使用类名导入该类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.itwanger.test.Cmower;</span><br></pre></td></tr></table></figure>\n<p>Java 和第三方类库提供了很多包可供使用，可以通过上述的方式导入类库使用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.itwanger.test;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class CmowerTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List&lt;Cmower&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(new Cmower());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"03、全名\"><a href=\"#03、全名\" class=\"headerlink\" title=\"03、全名\"></a>03、全名</h2><p>有时，我们可能会使用来自不同包下的两个具有相同名称的类。例如，我们可能同时使用 java.sql.Date 和 java.util.Date。当我们遇到命名冲突时，我们需要对至少一个类使用全名（包名+类名）。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>list1 </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.add(new com.itwanger.test.Cmower());</span><br></pre></td></tr></table></figure>\n<h1 id=\"六、Java-到底是值传递还是引用传递\"><a href=\"#六、Java-到底是值传递还是引用传递\" class=\"headerlink\" title=\"六、Java 到底是值传递还是引用传递\"></a>六、Java 到底是值传递还是引用传递</h1><p>将参数传递给方法有两种常见的方式，一种是“值传递”，一种是“引用传递”。C 语言本身只支持值传递，它的衍生品 C++ 既支持值传递，也支持引用传递，而 Java 只支持值传递。</p>\n<h2 id=\"01、值传递-VS-引用传递\"><a href=\"#01、值传递-VS-引用传递\" class=\"headerlink\" title=\"01、值传递 VS 引用传递\"></a>01、值传递 VS 引用传递</h2><p>首先，我们必须要搞清楚，到底什么是值传递，什么是引用传递，否则，讨论 Java 到底是值传递还是引用传递就显得毫无意义。<br>当一个参数按照值的方式在两个方法之间传递时，调用者和被调用者其实是用的两个不同的变量——被调用者中的变量（原始值）是调用者中变量的一份拷贝，对它们当中的任何一个变量修改都不会影响到另外一个变量。<br>而当一个参数按照引用传递的方式在两个方法之间传递时，调用者和被调用者其实用的是同一个变量，当该变量被修改时，双方都是可见的。<br>Java 程序员之所以容易搞混值传递和引用传递，主要是因为 Java 有两种数据类型，一种是基本类型，比如说 int，另外一种是引用类型，比如说 String。<br>基本类型的变量存储的都是实际的值，而引用类型的变量存储的是对象的引用——指向了对象在内存中的地址。值和引用存储在 stack（栈）中，而对象存储在 heap（堆）中。<br><img src=\"https://www.qyihe.xyz/images/post/10.15.jpg\"><br>之所以有这个区别，是因为：</p>\n<ul>\n<li>栈的优势是，存取速度比堆要快，仅次于直接位于 CPU 中的寄存器。但缺点是，栈中的数据大小与生存周期必须是确定的。</li>\n<li>堆的优势是可以动态地分配内存大小，生存周期也不必事先告诉编译器，Java 的垃圾回收器会自动收走那些不再使用的数据。但由于要在运行时动态分配内存，存取速度较慢。</li>\n</ul>\n<h2 id=\"02、基本类型的参数传递\"><a href=\"#02、基本类型的参数传递\" class=\"headerlink\" title=\"02、基本类型的参数传递\"></a>02、基本类型的参数传递</h2><p>众所周知，Java 有 8 种基本数据类型，分别是 int、long、byte、short、float、double 、char 和 boolean。它们的值直接存储在栈中，每当作为参数传递时，都会将原始值（实参）复制一份新的出来，给形参用。形参将会在被调用方法结束时从栈中清除。<br>来看下面这段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PrimitiveTypeDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age = 18;</span><br><span class=\"line\">        modify(age);</span><br><span class=\"line\">        System.out.println(age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void modify(int age1) &#123;</span><br><span class=\"line\">        age1 = 30;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（1）main 方法中的 age 是基本类型，所以它的值 18 直接存储在栈中。<br>（2）调用 modify() 方法的时候，将为实参 age 创建一个副本（形参 age1），它的值也为 18，不过是在栈中的其他位置。<br>（3）对形参 age 的任何修改都只会影响它自身而不会影响实参。<br><img src=\"https://www.qyihe.xyz/images/post/10.16.jpg\"></p>\n<h2 id=\"03、引用类型的参数传递\"><a href=\"#03、引用类型的参数传递\" class=\"headerlink\" title=\"03、引用类型的参数传递\"></a>03、引用类型的参数传递</h2><p>来看一段创建引用类型变量的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer writer = new Writer(18, &quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>\n<p>writer 是对象吗？还是对象的引用？为了搞清楚这个问题，我们可以把上面的代码拆分为两行代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer writer;</span><br><span class=\"line\">writer = new Writer(18, &quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>\n<p>假如 writer 是对象的话，就不需要通过 new 关键字创建对象了，对吧？那也就是说，writer 并不是对象，在“=”操作符执行之前，它仅仅是一个变量。那谁是对象呢？new Writer(18, “沉默王二”)，它是对象，存储于堆中；然后，“=”操作符将对象的引用赋值给了 writer 变量，于是 writer 此时应该叫对象引用，它存储在栈中，保存了对象在堆中的地址。<br>每当引用类型作为参数传递时，都会创建一个对象引用（实参）的副本（形参），该形参保存的地址和实参一样。<br>来看下面这段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReferenceTypeDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Writer a = new Writer(18);</span><br><span class=\"line\">        Writer b = new Writer(18);</span><br><span class=\"line\">        modify(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(a.getAge());</span><br><span class=\"line\">        System.out.println(b.getAge());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void modify(Writer a1, Writer b1) &#123;</span><br><span class=\"line\">        a1.setAge(30);</span><br><span class=\"line\"></span><br><span class=\"line\">        b1 = new Writer(18);</span><br><span class=\"line\">        b1.setAge(30);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（1）在调用 modify() 方法之前，实参 a 和 b 指向的对象是不一样的，尽管 age 都为 18。<br><img src=\"https://www.qyihe.xyz/images/post/10.17.jpg\"><br>（2）在调用 modify() 方法时，实参 a 和 b 都在栈中创建了一个新的副本，分别是 a1 和 b1，但指向的对象是一致的（a 和 a1 指向对象 a，b 和 b1 指向对象 b）。<br><img src=\"https://www.qyihe.xyz/images/post/10.18.jpg\"><br>（3）在 modify() 方法中，修改了形参 a1 的 age 为 30，意味着对象 a 的 age 从 18 变成了 30，而实参 a 指向的也是对象 a，所以 a 的 age 也变成了 30；形参 b1 指向了一个新的对象，随后 b1 的 age 被修改为 30。<br><img src=\"https://www.qyihe.xyz/images/post/10.19.jpg\"><br>修改 a1 的 age，意味着同时修改了 a 的 age，因为它们指向的对象是一个；修改 b1 的 age，对 b 却没有影响，因为它们指向的对象是两个。<br>程序输出的结果如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30</span><br><span class=\"line\">18</span><br></pre></td></tr></table></figure>\n<p>果然和我们的分析是吻合的。</p>\n<h1 id=\"七、Java-的类和对象\"><a href=\"#七、Java-的类和对象\" class=\"headerlink\" title=\"七、Java 的类和对象\"></a>七、Java 的类和对象</h1><p>类和对象是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。对象可以是现实中看得见的任何物体（一只特立独行的猪），也可以是想象中的任何虚拟物体（能七十二变的孙悟空），Java 通过类（class）来定义这些物体，有什么状态（通过字段，或者叫成员变量定义，比如说猪的颜色是纯色还是花色），有什么行为（通过方法定义，比如说猪会吃，会睡觉）。<br>来，让我来定义一个简单的类给你看看。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pig &#123;</span><br><span class=\"line\">    private String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;吃&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认情况下，每个 Java 类都会有一个空的构造方法，尽管它在源代码中是缺省的，但却可以通过反编译字节码看到它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pig &#123;</span><br><span class=\"line\">    private String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Pig() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;吃&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>没错，就是多出来的那个 public Pig() {}，参数是空的，方法体是空的。我们可以通过 new 关键字利用这个构造方法来创建一个对象，代码如下所示：<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pig pig = new Pig();</span><br></pre></td></tr></table></figure><br>当然了，我们也可以主动添加带参的构造方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pig &#123;</span><br><span class=\"line\">    private String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Pig(String color) &#123;</span><br><span class=\"line\">        this.color = color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;吃&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候，再查看反编译后的字节码时，你会发现缺省的无参构造方法消失了——和源代码一模一样。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pig &#123;</span><br><span class=\"line\">    private String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Pig(String color) &#123;</span><br><span class=\"line\">        this.color = color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;吃&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这意味着无法通过 new Pig() 来创建对象了——编译器会提醒你追加参数。<br><img src=\"https://www.qyihe.xyz/images/post/10.20.jpg\"><br>比如说你将代码修改为 new Pig(“纯白色”)，或者添加无参的构造方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pig &#123;</span><br><span class=\"line\">    private String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Pig(String color) &#123;</span><br><span class=\"line\">        this.color = color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Pig() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;吃&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用无参构造方法创建的对象状态默认值为 null（color 字符串为引用类型），如果是基本类型的话，默认值为对应基本类型的默认值，比如说 int 为 0，更详细的见下图。<br><img src=\"https://www.qyihe.xyz/images/post/10.21.jpg\"><br>（图片中有一处错误，boolean 的默认值为 false）<br>接下来，我们来创建多个 Pig 对象，它的颜色各不相同。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PigTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Pig pigNoColor = new Pig();</span><br><span class=\"line\">        Pig pigWhite = new Pig(&quot;纯白色&quot;);</span><br><span class=\"line\">        Pig pigBlack = new Pig(&quot;纯黑色&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你看，我们创建了 3 个不同花色的 Pig 对象，全部来自于一个类，由此可见类的重要性，只需要定义一次，就可以多次使用。<br>那假如我想改变对象的状态呢？该怎么办？目前毫无办法，因为没有任何可以更改状态的方法，直接修改 color 是行不通的，因为它的访问权限修饰符是 private 的。<br>最好的办法就是为 Pig 类追加 getter/setter 方法，就像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String getColor() &#123;</span><br><span class=\"line\">    return color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void setColor(String color) &#123;</span><br><span class=\"line\">    this.color = color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 setColor() 方法来修改，通过 getColor() 方法获取状态，它们的权限修饰符是 public 的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pig pigNoColor = new Pig();</span><br><span class=\"line\">pigNoColor.setColor(&quot;花色&quot;);</span><br><span class=\"line\">System.out.println(pigNoColor.getColor()); // 花色</span><br></pre></td></tr></table></figure>\n<p>为什么要这样设计呢？可以直接将 color 字段的访问权限修饰符换成是 public 的啊，不就和 getter/setter 一样的效果了吗？<br>因为有些情况，某些字段是不允许被随意修改的，它只有在对象创建的时候初始化一次，比如说猪的年龄，它只能每年长一岁（举个例子），没有月光宝盒让它变回去。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">public int getAge() &#123;</span><br><span class=\"line\">    return age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void increaseAge() &#123;</span><br><span class=\"line\">    this.age++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你看，age 就没有 setter 方法，只有一个每年可以调用一次的 increaseAge() 方法和 getter 方法。如果把 age 的访问权限修饰符更改为 public，age 就完全失去控制了，可以随意将其重置为 0 或者负数。<br>访问权限修饰符对于 Java 来说，非常重要，目前共有四种：public、private、protected 和 default（缺省）。<br>一个类只能使用 public 或者 default 修饰，public 修饰的类你之前已经见到过了，现在我来定义一个缺省权限修饰符的类给你欣赏一下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Dog &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>哈哈，其实也没啥可以欣赏的。缺省意味着这个类可以被同一个包下的其他类进行访问；而 public 意味着这个类可以被所有包下的类进行访问。<br>假如硬要通过 private 和 protected 来修饰类的话，编译器会生气的，它不同意。<br><img src=\"https://www.qyihe.xyz/images/post/10.22.jpg\"><br>private 可以用来修饰类的构造方法、字段和方法，只能被当前类进行访问。protected 也可以用来修饰类的构造方法、字段和方法，但它的权限范围更宽一些，可以被同一个包中的类进行访问，或者当前类的子类。<br>可以通过下面这张图来对比一下四个权限修饰符之间的差别：<br><img src=\"https://www.qyihe.xyz/images/post/10.23.jpg\"></p>\n<ul>\n<li><p>同一个类中，不管是哪种权限修饰符，都可以访问；</p>\n</li>\n<li><p>同一个包下，private 修饰的无法访问；</p>\n</li>\n<li><p>子类可以访问 public 和 protected 修饰的；</p>\n</li>\n<li><p>public 修饰符面向世界，哈哈，可以被所有的地方访问到。<br><img src=\"https://www.qyihe.xyz/images/post/10.24.jpg\"></p>\n<h1 id=\"八、Java-构造方法\"><a href=\"#八、Java-构造方法\" class=\"headerlink\" title=\"八、Java 构造方法\"></a>八、Java 构造方法</h1><p>假设现在有一个 Writer 类，它有两个字段，姓名和年纪：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Writer &#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Writer&#123;&quot; +</span><br><span class=\"line\">                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +</span><br><span class=\"line\">                &quot;, age=&quot; + age +</span><br><span class=\"line\">                &#x27;&#125;&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重写了 toString() 方法，用于打印 Writer 类的详情。由于没有构造方法，意味着当我们创建 Writer 对象时，它的字段值并没有初始化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer writer = new Writer();</span><br><span class=\"line\">System.out.println(writer.toString());</span><br></pre></td></tr></table></figure>\n<p>输出结果如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer&#123;name=&#x27;null&#x27;, age=0&#125;</span><br></pre></td></tr></table></figure>\n<p>name 是字符串类型，所以默认值为 null，age 为 int 类型，所以默认值为 0。<br>让我们为 Writer 类主动加一个无参的构造方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Writer() &#123;</span><br><span class=\"line\">    this.name = &quot;&quot;;</span><br><span class=\"line\">    this.age = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造方法也是一个方法，只不过它没有返回值，默认返回创建对象的类型。需要注意的是，当前构造方法没有参数，它被称为无参构造方法。如果我们没有主动创建无参构造方法的话，编译器会隐式地自动添加一个无参的构造方法。这就是为什么，一开始虽然没有构造方法，却可以使用 new Writer() 创建对象的原因，只不过，所有的字段都被初始化成了默认值。<br>接下来，让我们添加一个有参的构造方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Writer(String name, int age) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们创建 Writer 对象的时候就可以通过对字段值初始化值了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer writer1 = new Writer(&quot;沉默王二&quot;,18);</span><br><span class=\"line\">System.out.println(writer1.toString());</span><br></pre></td></tr></table></figure>\n<p>来看一下打印结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer&#123;name=&#x27;沉默王二&#x27;, age=18&#125;</span><br></pre></td></tr></table></figure>\n<p>可以根据字段的数量添加不同参数数量的构造方法，比如说，我们可以单独为 name 字段添加一个构造方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Writer(String name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能够兼顾 age 字段，我们可以通过 this 关键字调用其他的构造方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Writer(String name) &#123;</span><br><span class=\"line\">    this(name,18);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把作者的年龄都默认初始化为 18。如果需要使用父类的构造方法，还可以使用 super 关键字，手册后面有详细的介绍。</p>\n<h1 id=\"九、Java-抽象类\"><a href=\"#九、Java-抽象类\" class=\"headerlink\" title=\"九、Java 抽象类\"></a>九、Java 抽象类</h1><p>当我们要完成的任务是确定的，但具体的方式需要随后开个会投票的话，Java 的抽象类就派上用场了。这句话怎么理解呢？搬个小板凳坐好，听我来给你讲讲。<br><img src=\"https://www.qyihe.xyz/images/post/10.25.jpg\"></p>\n<h2 id=\"01、抽象类的-5-个关键点\"><a href=\"#01、抽象类的-5-个关键点\" class=\"headerlink\" title=\"01、抽象类的 5 个关键点\"></a>01、抽象类的 5 个关键点</h2><p>（1）定义抽象类的时候需要用到关键字 abstract，放在 class 关键字前。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractPlayer &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于抽象类的命名，阿里出品的 Java 开发手册上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，记住了哦。<br>（2）抽象类不能被实例化，但可以有子类。<br>尝试通过 new 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。<br><img src=\"https://www.qyihe.xyz/images/post/10.26.jpg\"><br>通过 extends 关键字可以继承抽象类，继承后，BasketballPlayer 类就是 AbstractPlayer 的子类。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。<br>当在一个普通类（没有使用 abstract 关键字修饰）中定义了抽象方法，编译器就会有两处错误提示。<br>第一处在类级别上，提醒你“这个类必须通过 abstract 关键字定义”，or 的那个信息没必要，见下图。<br><img src=\"https://www.qyihe.xyz/images/post/10.27.jpg\"><br>第二处在方法级别上，提醒你“抽象方法所在的类不是抽象的”，见下图。<br><img src=\"https://www.qyihe.xyz/images/post/10.28.jpg\"><br>（4）抽象类可以同时声明抽象方法和具体方法，也可以什么方法都没有，但没必要。就像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractPlayer &#123;</span><br><span class=\"line\">    abstract void play();</span><br><span class=\"line\">    </span><br><span class=\"line\">    public void sleep() &#123;</span><br><span class=\"line\">        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（5）抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类中定义了 play() 方法，子类中就必须实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    void play() &#123;</span><br><span class=\"line\">        System.out.println(&quot;我是张伯伦，篮球场上得过 100 分&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有实现的话，编译器会提醒你“子类必须实现抽象方法”，见下图。<br><img src=\"https://www.qyihe.xyz/images/post/10.29.jpg\"></p>\n<h2 id=\"02、什么时候用抽象类\"><a href=\"#02、什么时候用抽象类\" class=\"headerlink\" title=\"02、什么时候用抽象类\"></a>02、什么时候用抽象类</h2><p>与抽象类息息相关的还有一个概念，就是接口，我们留到下一篇文章中详细说，因为要说的知识点还是蛮多的。你现在只需要有这样一个概念就好，接口是对行为的抽象，抽象类是对整个类（包含成员变量和行为）进行抽象。<br>（是不是有点明白又有点不明白，别着急，翘首以盼地等下一篇文章出炉吧）<br>除了接口之外，还有一个概念就是具体的类，就是不通过 abstract 修饰的普通类，见下面这段代码中的定义。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BasketballPlayer &#123;</span><br><span class=\"line\">   public void play() &#123;</span><br><span class=\"line\">        System.out.println(&quot;我是詹姆斯，现役第一人&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有接口，有具体类，那什么时候该使用抽象类呢？<br>（1）我们希望一些通用的功能被多个子类复用。比如说，AbstractPlayer 抽象类中有一个普通的方法 sleep()，表明所有运动员都需要休息，那么这个方法就可以被子类复用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractPlayer &#123;</span><br><span class=\"line\">    public void sleep() &#123;</span><br><span class=\"line\">        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然 AbstractPlayer 类可以不是抽象类——把 abstract 修饰符去掉也能满足这种场景。但 AbstractPlayer 类可能还会有一个或者多个抽象方法。<br>BasketballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BasketballPlayer 对象可以直接调用 sleep() 方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BasketballPlayer basketballPlayer = new BasketballPlayer();</span><br><span class=\"line\">basketballPlayer.sleep();</span><br></pre></td></tr></table></figure>\n<p>FootballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FootballPlayer extends AbstractPlayer &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>FootballPlayer 对象也可以直接调用 sleep() 方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FootballPlayer footballPlayer = new FootballPlayer();</span><br><span class=\"line\">footballPlayer.sleep();</span><br></pre></td></tr></table></figure>\n<p>（2）我们需要在抽象类中定义好 API，然后在子类中扩展实现。比如说，AbstractPlayer  抽象类中有一个抽象方法 play()，定义所有运动员都可以从事某项运动，但需要对应子类去扩展实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AbstractPlayer &#123;</span><br><span class=\"line\">    abstract void play();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    void play() &#123;</span><br><span class=\"line\">        System.out.println(&quot;我是张伯伦，我篮球场上得过 100 分，&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;```</span><br><span class=\"line\"></span><br><span class=\"line\">FootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</span><br></pre></td></tr></table></figure>\n<p>public class FootballPlayer extends AbstractPlayer {<br>  @Override<br>  void play() {</p>\n<pre><code>  System.out.println(&quot;我是C罗，我能接住任意高度的头球&quot;);\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（3）如果父类与子类之间的关系符合 is-a 的层次关系，就可以使用抽象类，比如说篮球运动员是运动员，足球运动员是运动员。</span><br><span class=\"line\">## 03、具体示例</span><br><span class=\"line\">为了进一步展示抽象类的特性，我们再来看一个具体的示例。假设现在有一个文件，里面的内容非常简单——“Hello World”，现在需要有一个读取器将内容读取出来，最好能按照大写的方式，或者小写的方式。</span><br><span class=\"line\">这时候，最好定义一个抽象类，比如说 BaseFileReader：</span><br></pre></td></tr></table></figure>\n<p>public abstract class BaseFileReader {<br>  protected Path filePath;</p>\n<p>  protected BaseFileReader(Path filePath) {</p>\n<pre><code>  this.filePath = filePath;\n</code></pre>\n<p>  }</p>\n<p>  public List<String> readFile() throws IOException {</p>\n<pre><code>  return Files.lines(filePath)\n          .map(this::mapFileLine).collect(Collectors.toList());\n</code></pre>\n<p>  }</p>\n<p>  protected abstract String mapFileLine(String line);<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问。</span><br><span class=\"line\">readFile() 方法用来读取文件，方法体里面调用了抽象方法 mapFileLine()——需要子类扩展实现大小写的方式。</span><br><span class=\"line\">你看，BaseFileReader 设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。</span><br><span class=\"line\">小写的方式：</span><br></pre></td></tr></table></figure>\n<p>public class LowercaseFileReader extends BaseFileReader {<br>  protected LowercaseFileReader(Path filePath) {</p>\n<pre><code>  super(filePath);\n</code></pre>\n<p>  }</p>\n<p>  @Override<br>  protected String mapFileLine(String line) {</p>\n<pre><code>  return line.toLowerCase();\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">大写的方式：</span><br></pre></td></tr></table></figure>\n<p>public class UppercaseFileReader extends BaseFileReader {<br>  protected UppercaseFileReader(Path filePath) {</p>\n<pre><code>  super(filePath);\n</code></pre>\n<p>  }</p>\n<p>  @Override<br>  protected String mapFileLine(String line) {</p>\n<pre><code>  return line.toUpperCase();\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你看，从文件里面一行一行读取内容的代码被子类复用了——抽象类 BaseFileReader 类中定义的普通方法 readFile()。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。</span><br><span class=\"line\">接下来，我们来新建一个测试类 FileReaderTest：</span><br></pre></td></tr></table></figure>\n<p>public class FileReaderTest {<br>  public static void main(String[] args) throws URISyntaxException, IOException {</p>\n<pre><code>  URL location = FileReaderTest.class.getClassLoader().getResource(&quot;helloworld.txt&quot;);\n  Path path = Paths.get(location.toURI());\n  BaseFileReader lowercaseFileReader = new LowercaseFileReader(path);\n  BaseFileReader uppercaseFileReader = new UppercaseFileReader(path);\n  System.out.println(lowercaseFileReader.readFile());\n  System.out.println(uppercaseFileReader.readFile());\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">项目的 resource 目录下有一个文本文件，名字叫 helloworld.txt。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.30.jpg)</span><br><span class=\"line\">可以通过 ClassLoader.getResource() 的方式获取到该文件的 URI 路径，然后就可以使用 LowercaseFileReader 和 UppercaseFileReader 两种方式读取到文本内容了。</span><br><span class=\"line\">输出结果如下所示：</span><br></pre></td></tr></table></figure>\n<p>[hello world]<br>[HELLO WORLD]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 十、Java 接口</span><br><span class=\"line\">对于面向对象编程来说，抽象是一个极具魅力的特征。如果一个程序员的抽象思维很差，那他在编程中就会遇到很多困难，无法把业务变成具体的代码。在 Java 中，可以通过两种形式来达到抽象的目的，一种是抽象类，另外一种就是接口。</span><br><span class=\"line\">如果你现在就想知道抽象类与接口之间的区别，我可以提前给你说一个：</span><br><span class=\"line\"></span><br><span class=\"line\">- 一个类只能继承一个抽象类，但却可以实现多个接口。</span><br><span class=\"line\"></span><br><span class=\"line\">当然了，在没有搞清楚接口到底是什么，它可以做什么之前，这个区别理解起来会有点难度。</span><br><span class=\"line\">## 01、接口是什么</span><br><span class=\"line\">接口是通过 interface 关键字定义的，它可以包含一些常量和方法，来看下面这个示例。</span><br></pre></td></tr></table></figure>\n<p>public interface Electronic {<br>  // 常量<br>  String LED = “LED”;</p>\n<p>  // 抽象方法<br>  int getElectricityUse();</p>\n<p>  // 静态方法<br>  static boolean isEnergyEfficient(String electtronicType) {</p>\n<pre><code>  return electtronicType.equals(LED);\n</code></pre>\n<p>  }</p>\n<p>  // 默认方法<br>  default void printDescription() {</p>\n<pre><code>  System.out.println(&quot;电子&quot;);\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）接口中定义的变量会在编译的时候自动加上 public static final 修饰符，也就是说 LED 变量其实是一个常量。</span><br><span class=\"line\">Java 官方文档上有这样的声明：</span><br></pre></td></tr></table></figure>\n<p>Every field declaration in the body of an interface is implicitly public, static, and final.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">换句话说，接口可以用来作为常量类使用，还能省略掉 public static final，看似不错的一种选择，对吧？</span><br><span class=\"line\">不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。</span><br><span class=\"line\">（2）没有使用 private、default 或者 static 关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 public abstract 修饰符。也就是说 getElectricityUse() 其实是一个抽象方法，没有方法体——这是定义接口的本意。</span><br><span class=\"line\">（3）从 Java 8 开始，接口中允许有静态方法，比如说 isEnergyEfficient() 方法。</span><br><span class=\"line\">静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口的名字来调用，比如说 Electronic.isEnergyEfficient(&quot;LED&quot;)。</span><br><span class=\"line\">接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。</span><br><span class=\"line\">（4）接口中允许定义 default 方法也是从 Java 8 开始的，比如说 printDescription()，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现，也就是说，无法直接使用一个“;”号来结束默认方法——编译器会报错的。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.31.jpg)</span><br><span class=\"line\">允许在接口中定义默认方法的理由是很充分的，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 default 方法的帮助下，我们就必须挨个对实现类进行修改。</span><br><span class=\"line\">来看一下 Electronic 接口反编译后的字节码吧，你会发现，接口中定义的所有变量或者方法，都会自动添加上 public 关键字——假如你想知道编译器在背后都默默做了哪些辅助，记住反编译字节码就对了。</span><br></pre></td></tr></table></figure>\n<p>public interface Electronic<br>{</p>\n<p>  public abstract int getElectricityUse();</p>\n<p>  public static boolean isEnergyEfficient(String electtronicType)<br>  {</p>\n<pre><code>  return electtronicType.equals(&quot;LED&quot;);\n</code></pre>\n<p>  }</p>\n<p>  public void printDescription()<br>  {</p>\n<pre><code>  System.out.println(&quot;\\u7535\\u5B50&quot;);\n</code></pre>\n<p>  }</p>\n<p>  public static final String LED = “LED”;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有些读者可能会问，“二哥，为什么我反编译后的字节码和你的不一样，你用了什么反编译工具？”其实没有什么秘密，微信搜「沉默王二」回复关键字「JAD」就可以免费获取了，超级好用。</span><br><span class=\"line\">## 02、定义接口的注意事项</span><br><span class=\"line\">由之前的例子我们就可以得出下面这些结论：</span><br><span class=\"line\"></span><br><span class=\"line\">- 接口中允许定义变量</span><br><span class=\"line\">- 接口中允许定义抽象方法</span><br><span class=\"line\">- 接口中允许定义静态方法（Java 8 之后）</span><br><span class=\"line\">- 接口中允许定义默认方法（Java 8 之后）</span><br><span class=\"line\"></span><br><span class=\"line\">除此之外，我们还应该知道：</span><br><span class=\"line\">（1）接口不允许直接实例化。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.32.jpg)</span><br><span class=\"line\">需要定义一个类去实现接口，然后再实例化。</span><br></pre></td></tr></table></figure>\n<p>public class Computer implements Electronic {</p>\n<p>  public static void main(String[] args) {</p>\n<pre><code>  new Computer();\n</code></pre>\n<p>  }</p>\n<p>  @Override<br>  public int getElectricityUse() {</p>\n<pre><code>  return 0;\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（2）接口可以是空的，既不定义变量，也不定义方法。</span><br></pre></td></tr></table></figure>\n<p>public interface Serializable {<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Serializable 是最典型的一个空的接口，我之前分享过一篇文章《Java Serializable：明明就一个空的接口嘛》，感兴趣的读者可以去我的个人博客看一看，你就明白了空接口的意义。</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.itwanger.com/java/2019/1%E2%80%A6\">www.itwanger.com/java/2019/1…</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">（3）不要在定义接口的时候使用 final 关键字，否则会报编译错误，因为接口就是为了让子类实现的，而 final 阻止了这种行为。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.33.jpg)</span><br><span class=\"line\">（4）接口的抽象方法不能是 private、protected 或者 final。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.34.jpg)</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.35.jpg)</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.36.jpg)</span><br><span class=\"line\">（5）接口的变量是隐式 public static final，所以其值无法改变。</span><br><span class=\"line\">## 03、接口可以做什么</span><br><span class=\"line\">（1）使某些实现类具有我们想要的功能，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了 Comparable 或者 Comparator 的类具有比较功能。</span><br><span class=\"line\">Cloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 Object.clone() 方法，否则会抛出 CloneNotSupportedException。</span><br></pre></td></tr></table></figure>\n<p>public class CloneableTest implements Cloneable {<br>  @Override<br>  protected Object clone() throws CloneNotSupportedException {</p>\n<pre><code>  return super.clone();\n</code></pre>\n<p>  }</p>\n<p>  public static void main(String[] args) throws CloneNotSupportedException {</p>\n<pre><code>  CloneableTest c1 = new CloneableTest();\n  CloneableTest c2 = (CloneableTest) c1.clone();\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行后没有报错。现在把 implements Cloneable 去掉。</span><br></pre></td></tr></table></figure>\n<p>public class CloneableTest {<br>  @Override<br>  protected Object clone() throws CloneNotSupportedException {</p>\n<pre><code>  return super.clone();\n</code></pre>\n<p>  }</p>\n<p>  public static void main(String[] args) throws CloneNotSupportedException {</p>\n<pre><code>  CloneableTest c1 = new CloneableTest();\n  CloneableTest c2 = (CloneableTest) c1.clone();\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行后抛出 CloneNotSupportedException：</span><br></pre></td></tr></table></figure>\n<p>Exception in thread “main” java.lang.CloneNotSupportedException: com.cmower.baeldung.interface1.CloneableTest<br>  at java.base/java.lang.Object.clone(Native Method)<br>  at com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:6)<br>  at com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:11)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">至于 Comparable 和 Comparator 的用法，感兴趣的读者可以参照我之前写的另外一篇文章《来吧，一文彻底搞懂Java中的Comparable和Comparator》。</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.itwanger.com/java/2020/0%E2%80%A6\">www.itwanger.com/java/2020/0…</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（2）Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。</span><br><span class=\"line\">可能有些读者会问，“二哥，为什么 Java 只支持单一继承？”简单来解释一下。</span><br><span class=\"line\">如果有两个类共同继承（extends）一个有特定方法的父类，那么该方法会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。这也正是著名的菱形问题，见下图。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.37.jpg)</span><br><span class=\"line\">ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重载的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。</span><br><span class=\"line\">接口没有这方面的困扰。来定义两个接口，Fly 会飞，Run 会跑。</span><br></pre></td></tr></table></figure>\n<p>public interface Fly {<br>  void fly();<br>}<br>public interface Run {<br>  void run();<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">然后让一个类同时实现这两个接口。</span><br></pre></td></tr></table></figure>\n<p>public class Pig implements Fly,Run{<br>  @Override<br>  public void fly() {</p>\n<pre><code>  System.out.println(&quot;会飞的猪&quot;);\n</code></pre>\n<p>  }</p>\n<p>  @Override<br>  public void run() {</p>\n<pre><code>  System.out.println(&quot;会跑的猪&quot;);\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这就在某种形式上达到了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。</span><br><span class=\"line\">（3）实现多态。</span><br><span class=\"line\">什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。</span><br><span class=\"line\">多态可以通过继承（extends）的关系实现，也可以通过接口的形式实现。来看这样一个例子。</span><br><span class=\"line\">Shape 是表示一个形状。</span><br></pre></td></tr></table></figure>\n<p>public interface Shape {<br>  String name();<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">圆是一个形状。</span><br></pre></td></tr></table></figure>\n<p>public class Circle implements Shape {<br>  @Override<br>  public String name() {</p>\n<pre><code>  return &quot;圆&quot;;\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">正方形也是一个形状。</span><br></pre></td></tr></table></figure>\n<p>public class Square implements Shape {<br>  @Override<br>  public String name() {</p>\n<pre><code>  return &quot;正方形&quot;;\n</code></pre>\n<p>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">然后来看测试类。</span><br></pre></td></tr></table></figure>\n<p>List<Shape> shapes = new ArrayList&lt;&gt;();<br>Shape circleShape = new Circle();<br>Shape squareShape = new Square();</p>\n</li>\n</ul>\n<p>shapes.add(circleShape);<br>shapes.add(squareShape);</p>\n<p>for (Shape shape : shapes) {<br>    System.out.println(shape.name());<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多态的存在 3 个前提：</span><br><span class=\"line\">1、要有继承关系，Circle 和 Square 都实现了 Shape 接口</span><br><span class=\"line\">2、子类要重写父类的方法，Circle 和 Square 都重写了 name() 方法</span><br><span class=\"line\">3、父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle 对象，后者指向的是 Square 对象。</span><br><span class=\"line\">然后，我们来看一下测试结果：</span><br></pre></td></tr></table></figure>\n<p>圆<br>正方形</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 name() 方法的时候，它知道 Circle 对象应该调用 Circle 类的 name() 方法，Square 对象应该调用 Square 类的 name() 方法。</span><br><span class=\"line\">## 04、接口与抽象类的区别</span><br><span class=\"line\">好了，关于接口的一切，你应该都搞清楚了。现在回到读者春夏秋冬的那条留言，“兄弟，说说抽象类和接口之间的区别？”</span><br><span class=\"line\">（1）语法层面上</span><br><span class=\"line\"></span><br><span class=\"line\">- 接口中不能有 public 和 protected 修饰的方法，抽象类中可以有。</span><br><span class=\"line\">- 接口中的变量只能是隐式的常量，抽象类中可以有任意类型的变量。</span><br><span class=\"line\">- 一个类只能继承一个抽象类，但却可以实现多个接口。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）设计层面上</span><br><span class=\"line\">抽象类是对类的一种抽象，继承抽象类的类和抽象类本身是一种 is-a 的关系。</span><br><span class=\"line\">接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，所有的类都可以实现 Serializable 接口，从而具有序列化的功能。</span><br><span class=\"line\">就这么多吧，能说道这份上，我相信面试官就不会为难你了。</span><br><span class=\"line\"># 十一、Java 继承</span><br><span class=\"line\">在 Java 中，一个类可以继承另外一个类或者实现多个接口，我想这一点，大部分的读者应该都知道了。还有一点，我不确定大家是否知道，就是一个接口也可以继承另外一个接口，就像下面这样：</span><br></pre></td></tr></table></figure>\n<p>public interface OneInterface extends Cloneable {<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这样做有什么好处呢？我想有一部分读者应该已经猜出来了，就是实现了 OneInterface 接口的类，也可以使用 Object.clone() 方法了。</span><br></pre></td></tr></table></figure>\n<p>public class TestInterface implements OneInterface {<br>    public static void main(String[] args) throws CloneNotSupportedException {<br>        TestInterface c1 = new TestInterface();<br>        TestInterface c2 = (TestInterface) c1.clone();<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">除此之外，我们还可以在 OneInterface 接口中定义其他一些抽象方法（比如说深拷贝），使该接口拥有 Cloneable 所不具有的功能。</span><br></pre></td></tr></table></figure>\n<p>public interface OneInterface extends Cloneable {<br>    void deepClone();<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">看到了吧？这就是继承的好处：子接口拥有了父接口的方法，使得子接口具有了父接口相同的行为；同时，子接口还可以在此基础上自由发挥，添加属于自己的行为。</span><br><span class=\"line\">以上，把“接口”换成“类”，结论同样成立。让我们来定义一个普通的父类 Wanger：</span><br></pre></td></tr></table></figure>\n<p>public class Wanger {<br>    int age;<br>    String name;<br>    void write() {<br>        System.out.println(“我写了本《基督山伯爵》”);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">然后，我们再来定义一个子类 Wangxiaoer，使用关键字 extends 来继承父类 Wanger：</span><br></pre></td></tr></table></figure>\n<p>public class Wangxiaoer extends Wanger{<br>    @Override<br>    void write() {<br>        System.out.println(“我写了本《茶花女》”);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们可以将通用的方法和成员变量放在父类中，达到代码复用的目的；然后将特殊的方法和成员变量放在子类中，除此之外，子类还可以覆盖父类的方法（比如write() 方法）。这样，子类也就焕发出了新的生命力。</span><br><span class=\"line\">Java 只支持单一继承，这一点，我在上一篇接口的文章中已经提到过了。如果一个类在定义的时候没有使用 extends 关键字，那么它隐式地继承了 java.lang.Object 类——在我看来，这恐怕就是 Java 号称万物皆对象的真正原因了。</span><br><span class=\"line\">那究竟子类继承了父类的什么呢？</span><br><span class=\"line\">子类可以继承父类的非 private 成员变量，为了验证这一点，我们来看下面这个示例。</span><br></pre></td></tr></table></figure>\n<p>public class Wanger {<br>    String defaultName;<br>    private String privateName;<br>    public String publicName;<br>    protected String protectedName;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父类 Wanger 定义了四种类型的成员变量，缺省的 defaultName、私有的 privateName、共有的 publicName、受保护的 protectedName。</span><br><span class=\"line\">在子类 Wangxiaoer 中定义一个测试方法 testVariable()：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.38.jpg)</span><br><span class=\"line\">可以确认，除了私有的 privateName，其他三种类型的成员变量都可以继承到。</span><br><span class=\"line\">同理，子类可以继承父类的非 private 方法，为了验证这一点，我们来看下面这个示例。</span><br></pre></td></tr></table></figure>\n<p>public class Wanger {<br>    void write() {<br>    }</p>\n<pre><code>private void privateWrite() &#123;\n&#125;\n\npublic void publicWrite() &#123;\n&#125;\n\nprotected void protectedWrite() &#123;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父类 Wanger 定义了四种类型的方法，缺省的 write、私有的 privateWrite()、共有的 publicWrite()、受保护的 protectedWrite()。</span><br><span class=\"line\">在子类 Wangxiaoer 中定义一个 main 方法，并使用 new 关键字新建一个子类对象：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.39.jpg)</span><br><span class=\"line\">可以确认，除了私有的 privateWrite()，其他三种类型的方法都可以继承到。</span><br><span class=\"line\">不过，子类无法继承父类的构造方法。如果父类的构造方法是带有参数的，代码如下所示：</span><br></pre></td></tr></table></figure>\n<p>public class Wanger {<br>    int age;<br>    String name;</p>\n<pre><code>public Wanger(int age, String name) &#123;\n    this.age = age;\n    this.name = name;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">则必须在子类的构造器中显式地通过 super 关键字进行调用，否则编译器将提示以下错误：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.40.jpg)</span><br><span class=\"line\">修复后的代码如下所示：</span><br></pre></td></tr></table></figure>\n<p>public class Wangxiaoer extends Wanger{<br>    public Wangxiaoer(int age, String name) {<br>        super(age, name);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is-a 是继承的一个明显特征，就是说子类的对象引用类型可以是一个父类类型。</span><br></pre></td></tr></table></figure>\n<p>public class Wangxiaoer extends Wanger{<br>    public static void main(String[] args) {<br>        Wanger wangxiaoer = new Wangxiaoer();<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同理，子接口的实现类的对象引用类型也可以是一个父接口类型。</span><br></pre></td></tr></table></figure>\n<p>public interface OneInterface extends Cloneable {<br>}<br>public class TestInterface implements OneInterface {<br>    public static void main(String[] args) {<br>        Cloneable c1 = new TestInterface();<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">尽管一个类只能继承一个类，但一个类却可以实现多个接口，这一点，我在上一篇文章也提到过了。另外，还有一点我也提到了，就是 Java 8 之后，接口中可以定义 default 方法，这很方便，但也带来了新的问题：</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 如果一个类实现了多个接口，而这些接口中定义了相同签名的 default 方法，那么这个类就要重写该方法，否则编译无法通过。</span><br><span class=\"line\"></span><br><span class=\"line\">FlyInterface 是一个会飞的接口，里面有一个签名为 sleep() 的默认方法：</span><br></pre></td></tr></table></figure>\n<p>public interface FlyInterface {<br>    void fly();<br>    default void sleep() {<br>        System.out.println(“睡着飞”);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RunInterface 是一个会跑的接口，里面也有一个签名为 sleep() 的默认方法：</span><br></pre></td></tr></table></figure>\n<p>public interface RunInterface {<br>    void run();<br>    default void sleep() {<br>        System.out.println(“睡着跑”);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pig 类实现了 FlyInterface 和 RunInterface 两个接口，但这时候编译出错了。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.41.jpg)</span><br><span class=\"line\">原本，default 方法就是为实现该接口而不覆盖该方法的类提供默认实现的，现在，相同方法签名的 sleep() 方法把编译器搞懵逼了，只能重写了。</span><br></pre></td></tr></table></figure>\n<p>public class Pig implements FlyInterface, RunInterface {</p>\n<pre><code>@Override\npublic void fly() &#123;\n    System.out.println(&quot;会飞的猪&quot;);\n&#125;\n\n@Override\npublic void sleep() &#123;\n    System.out.println(&quot;只能重写了&quot;);\n&#125;\n\n@Override\npublic void run() &#123;\n    System.out.println(&quot;会跑的猪&quot;);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类虽然不能继承多个类，但接口却可以继承多个接口，这一点，我不知道有没有触及到一些读者的知识盲区。</span><br></pre></td></tr></table></figure>\n<p>public interface WalkInterface extends FlyInterface,RunInterface{<br>    void walk();<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 十二、this 关键字</span><br><span class=\"line\">在 Java 中，this 关键字指的是当前对象（它的方法正在被调用）的引用，能理解吧，各位亲？不理解的话，我们继续往下看。</span><br><span class=\"line\">看完再不明白，你过来捶爆我，我保证不还手，只要不打脸。</span><br><span class=\"line\">## 01、消除字段歧义</span><br><span class=\"line\">我敢赌一毛钱，所有的读者，不管男女老少，应该都知道这种用法，毕竟写构造方法的时候经常用啊。谁要不知道，过来，我给你发一毛钱红包，只要你脸皮够厚。</span><br></pre></td></tr></table></figure>\n<p>public class Writer {<br>    private int age;<br>    private String name;</p>\n<pre><code>public Writer(int age, String name) &#123;\n    this.age = age;\n    this.name = name;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer 类有两个成员变量，分别是 age 和 name，在使用有参构造函数的时候，如果参数名和成员变量的名字相同，就需要使用 this 关键字消除歧义：this.age 是指成员变量，age 是指构造方法的参数。</span><br><span class=\"line\">## 02、引用类的其他构造方法</span><br><span class=\"line\">当一个类的构造方法有多个，并且它们之间有交集的话，就可以使用 this 关键字来调用不同的构造方法，从而减少代码量。</span><br><span class=\"line\">比如说，在无参构造方法中调用有参构造方法：</span><br></pre></td></tr></table></figure>\n<p>public class Writer {<br>    private int age;<br>    private String name;</p>\n<pre><code>public Writer(int age, String name) &#123;\n    this.age = age;\n    this.name = name;\n&#125;\n\npublic Writer() &#123;\n    this(18, &quot;沉默王二&quot;);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">也可以在有参构造方法中调用无参构造方法：</span><br></pre></td></tr></table></figure>\n<p>public class Writer {<br>    private int age;<br>    private String name;</p>\n<pre><code>public Writer(int age, String name) &#123;\n    this();\n    this.age = age;\n    this.name = name;\n&#125;\n\npublic Writer() &#123;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需要注意的是，this() 必须是构造方法中的第一条语句，否则就会报错。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.42.jpg)</span><br><span class=\"line\">## 03、作为参数传递</span><br><span class=\"line\">在下例中，有一个无参的构造方法，里面调用了 print() 方法，参数只有一个 this 关键字。</span><br></pre></td></tr></table></figure>\n<p>public class ThisTest {<br>    public ThisTest() {<br>        print(this);<br>    }</p>\n<pre><code>private void print(ThisTest thisTest) &#123;\n    System.out.println(&quot;print &quot; +thisTest);\n&#125;\n\npublic static void main(String[] args) &#123;\n    ThisTest test = new ThisTest();\n    System.out.println(&quot;main &quot; + test);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">来打印看一下结果：</span><br></pre></td></tr></table></figure>\n<p>print com.cmower.baeldung.this1.ThisTest@573fd745<br>main com.cmower.baeldung.this1.ThisTest@573fd745</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从结果中可以看得出来，this 就是我们在 main() 方法中使用 new 关键字创建的 ThisTest 对象。</span><br><span class=\"line\">## 04、链式调用</span><br><span class=\"line\">学过 JavaScript，或者 jQuery 的读者可能对链式调用比较熟悉，类似于 a.b().c().d()，仿佛能无穷无尽调用下去。</span><br><span class=\"line\">在 Java 中，对应的专有名词叫 Builder 模式，来看一个示例。</span><br></pre></td></tr></table></figure>\n<p>public class Writer {<br>    private int age;<br>    private String name;<br>    private String bookName;</p>\n<pre><code>public Writer(WriterBuilder builder) &#123;\n    this.age = builder.age;\n    this.name = builder.name;\n    this.bookName = builder.bookName;\n&#125;\n\npublic static class WriterBuilder &#123;\n    public String bookName;\n    private int age;\n    private String name;\n\n    public WriterBuilder(int age, String name) &#123;\n        this.age = age;\n        this.name = name;\n    &#125;\n\n    public WriterBuilder writeBook(String bookName) &#123;\n        this.bookName = bookName;\n        return this;\n    &#125;\n\n    public Writer build() &#123;\n        return new Writer(this);\n    &#125;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer 类有三个成员变量，分别是 age、name 和 bookName，还有它们仨对应的一个构造方法，参数是一个内部静态类 WriterBuilder。</span><br><span class=\"line\">内部类 WriterBuilder 也有三个成员变量，和 Writer 类一致，不同的是，WriterBuilder 类的构造方法里面只有 age 和 name 赋值了，另外一个成员变量 bookName 通过单独的方法 writeBook() 来赋值，注意，该方法的返回类型是 WriterBuilder，最后使用 return 返回了 this 关键字。</span><br><span class=\"line\">最后的 build() 方法用来创建一个 Writer 对象，参数为 this 关键字，也就是当前的 WriterBuilder 对象。</span><br><span class=\"line\">这时候，创建 Writer 对象就可以通过链式调用的方式。</span><br></pre></td></tr></table></figure>\n<p>Writer writer = new Writer.WriterBuilder(18,”沉默王二”)<br>                .writeBook(“《Web全栈开发进阶之路》”)<br>                .build();</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 05、在内部类中访问外部类对象</span><br><span class=\"line\">说实话，自从 Java 8 的函数式编程出现后，就很少用到 this 在内部类中访问外部类对象了。来看一个示例：</span><br></pre></td></tr></table></figure>\n<p>public class ThisInnerTest {<br>    private String name;</p>\n<pre><code>class InnerClass &#123;\n    public InnerClass() &#123;\n        ThisInnerTest thisInnerTest = ThisInnerTest.this;\n        String outerName = thisInnerTest.name;\n    &#125;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在内部类 InnerClass 的构造方法中，通过外部类.this 可以获取到外部类对象，然后就可以使用外部类的成员变量了，比如说 name。</span><br><span class=\"line\"># 十三、super 关键字</span><br><span class=\"line\">简而言之，super 关键字就是用来访问父类的。</span><br><span class=\"line\">先来看父类：</span><br></pre></td></tr></table></figure>\n<p>public class SuperBase {<br>    String message = “父类”;</p>\n<pre><code>public SuperBase(String message) &#123;\n    this.message = message;\n&#125;\n\npublic SuperBase() &#123;\n&#125;\n\npublic void printMessage() &#123;\n    System.out.println(message);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">再来看子类：</span><br></pre></td></tr></table></figure>\n<p>public class SuperSub extends SuperBase {<br>    String message = “子类”;</p>\n<pre><code>public SuperSub(String message) &#123;\n    super(message);\n&#125;\n\npublic SuperSub() &#123;\n    super.printMessage();\n    printMessage();\n&#125;\n\npublic void getParentMessage() &#123;\n    System.out.println(super.message);\n&#125;\n\npublic void printMessage() &#123;\n    System.out.println(message);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）super 关键字可用于访问父类的构造方法</span><br><span class=\"line\">你看，子类可以通过 super(message) 来调用父类的构造方法。现在来新建一个 SuperSub 对象，看看输出结果是什么：</span><br></pre></td></tr></table></figure>\n<p>SuperSub superSub = new SuperSub(“子类的message”);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new 关键字在调用构造方法创建子类对象的时候，会通过 super 关键字初始化父类的 message，所以此此时父类的 message 会输出“子类的message”。</span><br><span class=\"line\">（2）super 关键字可以访问父类的变量</span><br><span class=\"line\">上述例子中的 SuperSub 类中就有，getParentMessage() 通过 super.message 方法父类的同名成员变量 message。</span><br><span class=\"line\">（3）当方法发生重写时，super 关键字可以访问父类的同名方法</span><br><span class=\"line\">上述例子中的 SuperSub 类中就有，无参的构造方法 SuperSub() 中就使用 super.printMessage() 调用了父类的同名方法。</span><br><span class=\"line\"># 十四、重写和重载</span><br><span class=\"line\">先来看一段重写的代码吧。</span><br></pre></td></tr></table></figure>\n<p>class LaoWang{<br>    public void write() {<br>        System.out.println(“老王写了一本《基督山伯爵》”);<br>    }<br>}<br>public class XiaoWang extends LaoWang {<br>    @Override<br>    public void write() {<br>        System.out.println(“小王写了一本《茶花女》”);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。就好像父类 LaoWang 有一个 write() 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 write() 方法（无参），但方法体是写一本《茶花女》。</span><br><span class=\"line\">来写一段测试代码。</span><br></pre></td></tr></table></figure>\n<p>public class OverridingTest {<br>    public static void main(String[] args) {<br>        LaoWang wang = new XiaoWang();<br>        wang.write();<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">大家猜结果是什么？</span><br></pre></td></tr></table></figure>\n<p>小王写了一本《茶花女》</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在上面的代码中，们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 write() 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 write() 方法而不是父类 LaoWang  中的 write() 方法，因此输出结果为“小王写了一本《茶花女》”。</span><br><span class=\"line\">再来看一段重载的代码吧。</span><br></pre></td></tr></table></figure>\n<p>class LaoWang{<br>    public void read() {<br>        System.out.println(“老王读了一本《Web全栈开发进阶之路》”);<br>    }</p>\n<pre><code>public void read(String bookname) &#123;\n    System.out.println(&quot;老王读了一本《&quot; + bookname + &quot;》&quot;);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">重载的两个方法名相同，但方法参数的个数不同，另外也不涉及到继承，两个方法在同一个类中。就好像类 LaoWang 有两个方法，名字都是 read()，但一个有参数（书名），另外一个没有（只能读写死的一本书）。</span><br><span class=\"line\">来写一段测试代码。</span><br></pre></td></tr></table></figure>\n<p>public class OverloadingTest {<br>    public static void main(String[] args) {<br>        LaoWang wang = new LaoWang();<br>        wang.read();<br>        wang.read(“金瓶梅”);<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这结果就不用猜了。变量 wang 的类型为 LaoWang，wang.read() 调用的是无参的 read() 方法，因此先输出“老王读了一本《Web全栈开发进阶之路》”；wang.read(&quot;金瓶梅&quot;) 调用的是有参的 read(bookname) 方法，因此后输出“老王读了一本《金瓶梅》”。在编译期间，编译器就知道这两个 read() 方法时不同的，因为它们的方法签名（=方法名称+方法参数）不同。</span><br><span class=\"line\">简单的来总结一下：</span><br><span class=\"line\">（1）编译器无法决定调用哪个重写的方法，因为只从变量的类型上是无法做出判断的，要在运行时才能决定；但编译器可以明确地知道该调用哪个重载的方法，因为引用类型是确定的，参数个数决定了该调用哪个方法。</span><br><span class=\"line\">（2）多态针对的是重写，而不是重载。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.43.jpg)</span><br><span class=\"line\">哎，后悔啊，早年我要是能把这道面试题吃透的话，也不用被老马刁难了。吟一首诗感慨一下人生吧。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;青青园中葵，朝露待日晞。</span><br><span class=\"line\">&gt;阳春布德泽，万物生光辉。</span><br><span class=\"line\">&gt;常恐秋节至，焜黄华叶衰。</span><br><span class=\"line\">&gt;百川东到海，何时复西归?</span><br><span class=\"line\">&gt;少壮不努力，老大徒伤悲</span><br><span class=\"line\"></span><br><span class=\"line\">另外，我想要告诉大家的是，重写（Override）和重载（Overload）是 Java 中两个非常重要的概念，新手经常会被它们俩迷惑，因为它们俩的英文名字太像了，中文翻译也只差一个字。难，太难了。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.44.jpg)</span><br><span class=\"line\"># 十五、static 关键字</span><br><span class=\"line\">先来个提纲挈领（唉呀妈呀，成语区博主上线了）吧：</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;static 关键字可用于变量、方法、代码块和内部类，表示某个特定的成员只属于某个类本身，而不是该类的某个对象。</span><br><span class=\"line\"></span><br><span class=\"line\">## 01、静态变量</span><br><span class=\"line\">静态变量也叫类变量，它属于一个类，而不是这个类的对象。</span><br></pre></td></tr></table></figure>\n<p>public class Writer {<br>    private String name;<br>    private int age;<br>    public static int countOfWriters;</p>\n<pre><code>public Writer(String name, int age) &#123;\n    this.name = name;\n    this.age = age;\n    countOfWriters++;\n&#125;\n\npublic String getName() &#123;\n    return name;\n&#125;\n\npublic void setName(String name) &#123;\n    this.name = name;\n&#125;\n\npublic int getAge() &#123;\n    return age;\n&#125;\n\npublic void setAge(int age) &#123;\n    this.age = age;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中，countOfWriters 被称为静态变量，它有别于 name 和 age 这两个成员变量，因为它前面多了一个修饰符 static。</span><br><span class=\"line\">这意味着无论这个类被初始化多少次，静态变量的值都会在所有类的对象中共享。</span><br></pre></td></tr></table></figure>\n<p>Writer w1 = new Writer(“沉默王二”,18);<br>Writer w2 = new Writer(“沉默王三”,16);</p>\n<p>System.out.println(Writer.countOfWriters);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">按照上面的逻辑，你应该能推理得出，countOfWriters 的值此时应该为 2 而不是 1。从内存的角度来看，静态变量将会存储在 Java 虚拟机中一个名叫“Metaspace”（元空间，Java 8 之后）的特定池中。</span><br><span class=\"line\">静态变量和成员变量有着很大的不同，成员变量的值属于某个对象，不同的对象之间，值是不共享的；但静态变量不是的，它可以用来统计对象的数量，因为它是共享的。就像上面例子中的 countOfWriters，创建一个对象的时候，它的值为 1，创建两个对象的时候，它的值就为 2。</span><br><span class=\"line\">简单小结一下：</span><br><span class=\"line\">（1）由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问；</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.45.jpg)</span><br><span class=\"line\">（2）不需要初始化类就可以访问静态变量。</span><br></pre></td></tr></table></figure>\n<p>public class WriterDemo {<br>    public static void main(String[] args) {<br>        System.out.println(Writer.countOfWriters); // 输出 0<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 02、静态方法</span><br><span class=\"line\">静态方法也叫类方法，它和静态变量类似，属于一个类，而不是这个类的对象。</span><br></pre></td></tr></table></figure>\n<p>public static void setCountOfWriters(int countOfWriters) {<br>    Writer.countOfWriters = countOfWriters;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setCountOfWriters() 就是一个静态方法，它由 static 关键字修饰。</span><br><span class=\"line\">如果你用过 java.lang.Math 类或者 Apache 的一些工具类（比如说 StringUtils）的话，对静态方法一定不会感动陌生。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.46.jpg)</span><br><span class=\"line\">Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.47.jpg)</span><br><span class=\"line\">简单小结一下：</span><br><span class=\"line\">（1）Java 中的静态方法在编译时解析，因为静态方法不能被重写（方法重写发生在运行时阶段，为了多态）。</span><br><span class=\"line\">（2）抽象方法不能是静态的。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.48.jpg)</span><br><span class=\"line\">（3）静态方法不能使用 this 和 super 关键字。</span><br><span class=\"line\">（4）成员方法可以直接访问其他成员方法和成员变量。</span><br><span class=\"line\">（5）成员方法也可以直接方法静态方法和静态变量。</span><br><span class=\"line\">（6）静态方法可以访问所有其他静态方法和静态变量。</span><br><span class=\"line\">（7）静态方法无法直接访问成员方法和成员变量。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.49.jpg)</span><br><span class=\"line\">## 03、静态代码块</span><br><span class=\"line\">静态代码块可以用来初始化静态变量，尽管静态方法也可以在声明的时候直接初始化，但有些时候，我们需要多行代码来完成初始化。</span><br></pre></td></tr></table></figure>\n<p>public class StaticBlockDemo {<br>    public static List<String> writes = new ArrayList&lt;&gt;();</p>\n<pre><code>static &#123;\n    writes.add(&quot;沉默王二&quot;);\n    writes.add(&quot;沉默王三&quot;);\n    writes.add(&quot;沉默王四&quot;);\n\n    System.out.println(&quot;第一块&quot;);\n&#125;\n\nstatic &#123;\n    writes.add(&quot;沉默王五&quot;);\n    writes.add(&quot;沉默王六&quot;);\n\n    System.out.println(&quot;第二块&quot;);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">writes 是一个静态的 ArrayList，所以不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初始化。</span><br><span class=\"line\">简单小结一下：</span><br><span class=\"line\">（1）一个类可以有多个静态代码块。</span><br><span class=\"line\">（2）静态代码块的解析和执行顺序和它在类中的位置保持一致。为了验证这个结论，可以在 StaticBlockDemo 类中加入空的 main 方法，执行完的结果如下所示：</span><br></pre></td></tr></table></figure>\n<p>第一块<br>第二块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 04、静态内部类</span><br><span class=\"line\">Java 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。</span><br><span class=\"line\">常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我们本次文章的讨论范围，以后有机会再细说。</span><br></pre></td></tr></table></figure>\n<p>public class Singleton {<br>    private Singleton() {}</p>\n<pre><code>private static class SingletonHolder &#123;\n    public static final Singleton instance = new Singleton();\n&#125;\n\npublic static Singleton getInstance() &#123;\n    return SingletonHolder.instance;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以上这段代码是不是特别熟悉，对，这就是创建单例的一种方式，第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全也能保证 Singleton 类的唯一性。不过，创建单例更优雅的一种方式是使用枚举。</span><br><span class=\"line\">简单小结一下：</span><br><span class=\"line\">（1）静态内部类不能访问外部类的所有成员变量。</span><br><span class=\"line\">（2）静态内部类可以访问外部类的所有静态变量，包括私有静态变量。</span><br><span class=\"line\">（3）外部类不能声明为 static。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.50.jpg)</span><br><span class=\"line\"># 十六、Java 枚举</span><br><span class=\"line\">开门见山地说吧，enum（枚举）是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，默认继承自 java.lang.Enum。</span><br><span class=\"line\">为了证明这一点，我们来新建一个枚举 PlayerType：</span><br></pre></td></tr></table></figure>\n<p>public enum PlayerType {<br>    TENNIS,<br>    FOOTBALL,<br>    BASKETBALL<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">两个关键字带一个类名，还有大括号，以及三个大写的单词，但没看到继承 Enum 类啊？别着急，心急吃不了热豆腐啊。使用 JAD 查看一下反编译后的字节码，就一清二楚了。</span><br></pre></td></tr></table></figure>\n<p>public final class PlayerType extends Enum<br>{</p>\n<pre><code>public static PlayerType[] values()\n&#123;\n    return (PlayerType[])$VALUES.clone();\n&#125;\n\npublic static PlayerType valueOf(String name)\n&#123;\n    return (PlayerType)Enum.valueOf(com/cmower/baeldung/enum1/PlayerType, name);\n&#125;\n\nprivate PlayerType(String s, int i)\n&#123;\n    super(s, i);\n&#125;\n\npublic static final PlayerType TENNIS;\npublic static final PlayerType FOOTBALL;\npublic static final PlayerType BASKETBALL;\nprivate static final PlayerType $VALUES[];\n\nstatic \n&#123;\n    TENNIS = new PlayerType(&quot;TENNIS&quot;, 0);\n    FOOTBALL = new PlayerType(&quot;FOOTBALL&quot;, 1);\n    BASKETBALL = new PlayerType(&quot;BASKETBALL&quot;, 2);\n    $VALUES = (new PlayerType[] &#123;\n        TENNIS, FOOTBALL, BASKETBALL\n    &#125;);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">看到没？PlayerType 类是 final 的，并且继承自 Enum 类。这些工作我们程序员没做，编译器帮我们悄悄地做了。此外，它还附带几个有用静态方法，比如说 values() 和  valueOf(String name)。</span><br><span class=\"line\">## 01、内部枚举</span><br><span class=\"line\">好的，小伙伴们应该已经清楚枚举长什么样子了吧？既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。</span><br></pre></td></tr></table></figure>\n<p>public class Player {<br>    private PlayerType type;<br>    public enum PlayerType {<br>        TENNIS,<br>        FOOTBALL,<br>        BASKETBALL<br>    }</p>\n<pre><code>public boolean isBasketballPlayer() &#123;\n  return getType() == PlayerType.BASKETBALL;\n&#125;\n\npublic PlayerType getType() &#123;\n    return type;\n&#125;\n\npublic void setType(PlayerType type) &#123;\n    this.type = type;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PlayerType 就相当于 Player 的内部类，isBasketballPlayer() 方法用来判断运动员是否是一个篮球运动员。</span><br><span class=\"line\">由于枚举是 final 的，可以确保在 Java 虚拟机中仅有一个常量对象（可以参照反编译后的静态代码块「static 关键字带大括号的那部分代码」），所以我们可以很安全地使用“==”运算符来比较两个枚举是否相等，参照 isBasketballPlayer() 方法。</span><br><span class=\"line\">那为什么不使用 equals() 方法判断呢？</span><br></pre></td></tr></table></figure>\n<p>if(player.getType().equals(Player.PlayerType.BASKETBALL)){};<br>if(player.getType() == Player.PlayerType.BASKETBALL){};</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“==”运算符比较的时候，如果两个对象都为 null，并不会发生 NullPointerException，而 equals() 方法则会。</span><br><span class=\"line\">另外， “==”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而 equals() 方法则不会。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.51.jpg)</span><br><span class=\"line\">## 02、枚举可用于 switch 语句</span><br><span class=\"line\">这个我在之前的一篇我去的文章中详细地说明过了，感兴趣的小伙伴可以点击链接跳转过去看一下。</span><br></pre></td></tr></table></figure>\n<p>switch (playerType) {<br>        case TENNIS:<br>            return “网球运动员费德勒”;<br>        case FOOTBALL:<br>            return “足球运动员C罗”;<br>        case BASKETBALL:<br>            return “篮球运动员詹姆斯”;<br>        case UNKNOWN:<br>            throw new IllegalArgumentException(“未知”);<br>        default:<br>            throw new IllegalArgumentException(<br>                    “运动员类型: “ + playerType);</p>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 03、枚举可以有构造方法</span><br><span class=\"line\">如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。</span><br></pre></td></tr></table></figure>\n<p>public enum PlayerType {<br>    TENNIS(“网球”),<br>    FOOTBALL(“足球”),<br>    BASKETBALL(“篮球”);</p>\n<pre><code>private String name;\n\nPlayerType(String name) &#123;\n    this.name = name;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 04、EnumSet</span><br><span class=\"line\">EnumSet 是一个专门针对枚举类型的 Set 接口的实现类，它是处理枚举类型数据的一把利器，非常高效（内部实现是位向量，我也搞不懂）。</span><br><span class=\"line\">因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.52.jpg)</span><br><span class=\"line\">下面的示例中使用 noneOf() 创建了一个空的 PlayerType 的 EnumSet；使用 allOf() 创建了一个包含所有 PlayerType 的 EnumSet。</span><br></pre></td></tr></table></figure>\n<p>public class EnumSetTest {<br>    public enum PlayerType {<br>        TENNIS,<br>        FOOTBALL,<br>        BASKETBALL<br>    }</p>\n<pre><code>public static void main(String[] args) &#123;\n    EnumSet&lt;PlayerType&gt; enumSetNone = EnumSet.noneOf(PlayerType.class);\n    System.out.println(enumSetNone);\n\n    EnumSet&lt;PlayerType&gt; enumSetAll = EnumSet.allOf(PlayerType.class);\n    System.out.println(enumSetAll);\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序输出结果如下所示：</span><br></pre></td></tr></table></figure>\n<p>[]<br>[TENNIS, FOOTBALL, BASKETBALL]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有了 EnumSet 后，就可以使用 Set 的一些方法了：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.53.jpg)</span><br><span class=\"line\">## 05、EnumMap</span><br><span class=\"line\">EnumMap 是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。</span><br><span class=\"line\">和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字：</span><br></pre></td></tr></table></figure>\n<p>EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有了 EnumMap 对象后就可以使用 Map 的一些方法了：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.54.jpg)</span><br><span class=\"line\">和 HashMap 的使用方法大致相同，来看下面的例子：</span><br></pre></td></tr></table></figure>\n<p>EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);<br>enumMap.put(PlayerType.BASKETBALL,”篮球运动员”);<br>enumMap.put(PlayerType.FOOTBALL,”足球运动员”);<br>enumMap.put(PlayerType.TENNIS,”网球运动员”);<br>System.out.println(enumMap);</p>\n<p>System.out.println(enumMap.get(PlayerType.BASKETBALL));<br>System.out.println(enumMap.containsKey(PlayerType.BASKETBALL));<br>System.out.println(enumMap.remove(PlayerType.BASKETBALL));</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序输出结果如下所示：</span><br></pre></td></tr></table></figure>\n<p>{TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员}<br>篮球运动员<br>true<br>篮球运动员</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 06、单例</span><br><span class=\"line\">通常情况下，实现一个单例并非易事，不信，来看下面这段代码</span><br></pre></td></tr></table></figure>\n<p>public class Singleton {<br>    private volatile static Singleton singleton;<br>    private Singleton (){}<br>    public static Singleton getSingleton() {<br>    if (singleton == null) {<br>        synchronized (Singleton.class) {<br>        if (singleton == null) {<br>            singleton = new Singleton();<br>        }<br>        }<br>    }<br>    return singleton;<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">但枚举的出现，让代码量减少到极致：</span><br></pre></td></tr></table></figure>\n<p>public enum EasySingleton{<br>    INSTANCE;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">完事了，真的超级短，有没有？枚举默认实现了 Serializable 接口，因此 Java 虚拟机可以保证该类为单例，这与传统的实现方式不大相同。传统方式中，我们必须确保单例在反序列化期间不能创建任何新实例。</span><br><span class=\"line\">## 07、枚举可与数据库交互</span><br><span class=\"line\">我们可以配合 Mybatis 将数据库字段转换为枚举类型。现在假设有一个数据库字段 check_type 的类型如下：</span><br></pre></td></tr></table></figure>\n<p><code>check_type</code> int(1) DEFAULT NULL COMMENT ‘检查类型（1：未通过、2：通过）’,</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">它对应的枚举类型为 CheckType，代码如下：</span><br></pre></td></tr></table></figure>\n<p>public enum CheckType {<br>    NO_PASS(0, “未通过”), PASS(1, “通过”);<br>    private int key;</p>\n<pre><code>private String text;\n\nprivate CheckType(int key, String text) &#123;\n    this.key = key;\n    this.text = text;\n&#125;\n\npublic int getKey() &#123;\n    return key;\n&#125;\n\npublic String getText() &#123;\n    return text;\n&#125;\n\nprivate static HashMap&lt;Integer,CheckType&gt; map = new HashMap&lt;Integer,CheckType&gt;();\nstatic &#123;\n    for(CheckType d : CheckType.values())&#123;\n        map.put(d.key, d);\n    &#125;\n&#125;\n\npublic static CheckType parse(Integer index) &#123;\n    if(map.containsKey(index))&#123;\n        return map.get(index);\n    &#125;\n    return null;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）CheckType 添加了构造方法，还有两个字段，key 为 int 型，text 为 String 型。</span><br><span class=\"line\">（2）CheckType 中有一个public static CheckType parse(Integer index)方法，可将一个 Integer 通过 key 的匹配转化为枚举类型。</span><br><span class=\"line\">那么现在，我们可以在 Mybatis 的配置文件中使用 typeHandler 将数据库字段转化为枚举类型。</span><br></pre></td></tr></table></figure>\n<resultMap id=\"CheckLog\" type=\"com.entity.CheckLog\">\n  <id property=\"id\" column=\"id\"/>\n  <result property=\"checkType\" column=\"check_type\" typeHandler=\"com.CheckTypeHandler\"></result>\n</resultMap>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中 checkType 字段对应的类如下：</span><br></pre></td></tr></table></figure>\npublic class CheckLog implements Serializable {\n\n<pre><code>private String id;\nprivate CheckType checkType;\n\npublic String getId() &#123;\n    return id;\n&#125;\n\npublic void setId(String id) &#123;\n    this.id = id;\n&#125;\n\npublic CheckType getCheckType() &#123;\n    return checkType;\n&#125;\n\npublic void setCheckType(CheckType checkType) &#123;\n    this.checkType = checkType;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CheckTypeHandler 转换器的类源码如下：</span><br></pre></td></tr></table></figure>\n<p>public class CheckTypeHandler extends BaseTypeHandler<CheckType> {</p>\n<pre><code>@Override\npublic CheckType getNullableResult(ResultSet rs, String index) throws SQLException &#123;\n    return CheckType.parse(rs.getInt(index));\n&#125;\n\n@Override\npublic CheckType getNullableResult(ResultSet rs, int index) throws SQLException &#123;\n    return CheckType.parse(rs.getInt(index));\n&#125;\n\n@Override\npublic CheckType getNullableResult(CallableStatement cs, int index) throws SQLException &#123;\n    return CheckType.parse(cs.getInt(index));\n&#125;\n\n@Override\npublic void setNonNullParameter(PreparedStatement ps, int index, CheckType val, JdbcType arg3) throws SQLException &#123;\n    ps.setInt(index, val.getKey());\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CheckTypeHandler 的核心功能就是调用 CheckType 枚举类的 parse() 方法对数据库字段进行转换。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.55.jpg)</span><br><span class=\"line\">恕我直言，我觉得小伙伴们肯定会用 Java 枚举了，如果还不会，就过来砍我！</span><br><span class=\"line\"># 十七、final 关键字</span><br><span class=\"line\">尽管继承可以让我们重用现有代码，但有时处于某些原因，我们确实需要对可扩展性进行限制，final 关键字可以帮助我们做到这一点。</span><br><span class=\"line\">## 01、final 类</span><br><span class=\"line\">如果一个类使用了 final 关键字修饰，那么它就无法被继承。如果小伙伴们细心观察的话，Java 就有不少 final 类，比如说最常见的 String 类。</span><br></pre></td></tr></table></figure>\n<p>public final class String<br>    implements java.io.Serializable, Comparable<String>, CharSequence,<br>               Constable, ConstantDesc {}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为什么 String 类要设计成 final 的呢？原因大致有以下三个：</span><br><span class=\"line\"></span><br><span class=\"line\">- 为了实现字符串常量池</span><br><span class=\"line\">- 为了线程安全</span><br><span class=\"line\">- 为了 HashCode 的不可变性</span><br><span class=\"line\"></span><br><span class=\"line\">更详细的原因，可以查看我之前写的一篇文章。</span><br><span class=\"line\">任何尝试从 final 类继承的行为将会引发编译错误，为了验证这一点，我们来看下面这个例子，Writer 类是 final 的。</span><br></pre></td></tr></table></figure>\n<p>public final class Writer {<br>    private String name;</p>\n<pre><code>public String getName() &#123;\n    return name;\n&#125;\n\npublic void setName(String name) &#123;\n    this.name = name;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">尝试去继承它，编译器会提示以下错误，Writer 类是 final 的，无法继承。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.56.jpg)</span><br><span class=\"line\">不过，类是 final 的，并不意味着该类的对象是不可变的。</span><br></pre></td></tr></table></figure>\n<p>Writer writer = new Writer();<br>writer.setName(“沉默王二”);<br>System.out.println(writer.getName()); // 沉默王二</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Writer 的 name 字段的默认值是 null，但可以通过 settter 方法将其更改为“沉默王二”。也就是说，如果一个类只是 final 的，那么它并不是不可变的全部条件。</span><br><span class=\"line\">如果，你想了解不可变类的全部真相，请查看我之前写的文章这次要说不明白immutable类，我就怎么地。突然发现，写系列文章真的妙啊，很多相关性的概念全部涉及到了。我真服了自己了。</span><br><span class=\"line\">把一个类设计成 final 的，有其安全方面的考虑，但不应该故意为之，因为把一个类定义成 final 的，意味着它没办法继承，假如这个类的一些方法存在一些问题的话，我们就无法通过重写的方式去修复它。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.57.jpg)</span><br><span class=\"line\">## 02、final 方法</span><br><span class=\"line\">被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它设计成 final 的。</span><br><span class=\"line\">Thread 类就是一个例子，它本身不是 final 的，这意味着我们可以扩展它，但它的 isAlive() 方法是 final 的：</span><br></pre></td></tr></table></figure>\n<p>public class Thread implements Runnable {<br>    public final native boolean isAlive();<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需要注意的是，该方法是一个本地（native）方法，用于确认线程是否处于活跃状态。而本地方法是由操作系统决定的，因此重写该方法并不容易实现。</span><br><span class=\"line\">Actor 类有一个 final 方法 show()：</span><br></pre></td></tr></table></figure>\n<p>public class Actor {<br>    public final void show() {</p>\n<pre><code>&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当我们想要重写该方法的话，就会出现编译错误：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.58.jpg)</span><br><span class=\"line\">如果一个类中的某些方法要被其他方法调用，则应考虑事被调用的方法称为 final 方法，否则，重写该方法会影响到调用方法的使用。</span><br><span class=\"line\">一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？</span><br><span class=\"line\">我能想到的一点，就是前者不能被继承，也就是说方法无法被重写；后者呢，可以被继承，然后追加一些非 final 的方法。没毛病吧？看把我聪明的。</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.59.jpg)</span><br><span class=\"line\">## 03、final 变量</span><br><span class=\"line\">被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。之前被一个小伙伴问过，什么是 effective final，什么是 final，这一点，我在之前的文章也有阐述过，所以这里再贴一下地址：</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.itwanger.com/java/2020/0%E2%80%A6\">www.itwanger.com/java/2020/0…</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）final 修饰的基本数据类型</span><br><span class=\"line\">来声明一个 final 修饰的 int 类型的变量：</span><br></pre></td></tr></table></figure>\n<p>final int age = 18;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">尝试将它修改为 30，结果编译器生气了：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.60.jpg)</span><br><span class=\"line\">（2）final 修饰的引用类型</span><br><span class=\"line\">现在有一个普通的类 Pig，它有一个字段 name：</span><br></pre></td></tr></table></figure>\n<p>public class Pig {<br>   private String name;</p>\n<pre><code>public String getName() &#123;\n    return name;\n&#125;\n\npublic void setName(String name) &#123;\n    this.name = name;\n&#125;\n</code></pre>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在测试类中声明一个 final 修饰的 Pig 对象：</span><br><span class=\"line\"> final Pig pig = new Pig();</span><br><span class=\"line\">如果尝试将 pig 重新赋值的话，编译器同样会生气：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.61.jpg)</span><br><span class=\"line\">但我们仍然可以去修改 Pig 的字段值：</span><br></pre></td></tr></table></figure>\n<p>final Pig pig = new Pig();<br>pig.setName(“特立独行”);<br>System.out.println(pig.getName()); // 特立独行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（3）final 修饰的字段</span><br><span class=\"line\">final 修饰的字段可以分为两种，一种是 static 的，另外一种是没有 static 的，就像下面这样：</span><br></pre></td></tr></table></figure>\n<p>public class Pig {<br>   private final int age = 1;<br>   public static final double PRICE = 36.5;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">非 static 的 final 字段必须有一个默认值，否则编译器将会提醒没有初始化：</span><br><span class=\"line\">![](https://www.qyihe.xyz/images/post/10.62.jpg)</span><br><span class=\"line\">static 的 final 字段也叫常量，它的名字应该为大写，可以在声明的时候初始化，也可以通过 static 代码块初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">(4) final 修饰的参数</span><br><span class=\"line\"></span><br><span class=\"line\">final 关键字还可以修饰参数，它意味着参数在方法体内不能被再修改：</span><br></pre></td></tr></table></figure>\n<p>public class ArgFinalTest {<br>    public void arg(final int age) {<br>    }</p>\n<pre><code>public void arg1(final String name) &#123;\n&#125;\n</code></pre>\n<p>}</p>\n<p>```<br>如果尝试去修改它的话，编译器会提示以下错误：<br><img src=\"https://www.qyihe.xyz/images/post/10.63.jpg\"><br>。。。。。。</p>\n<blockquote>\n<p>转载于<a href=\"https://juejin.im/post/5ee414c76fb9a047dd2768ea#heading-39\">沉默王二</a></p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cky03p47j00010cumergrcm09","category_id":"cky03p47s00040cuma195cfb2","_id":"cky03p48g000j0cumhif41wq4"},{"post_id":"cky03p483000b0cumfey86ehe","category_id":"cky03p47s00040cuma195cfb2","_id":"cky03p48z000o0cum37yk25om"},{"post_id":"cky03p489000f0cumctz4eolr","category_id":"cky03p47s00040cuma195cfb2","_id":"cky03p491000s0cum7bo30kem"},{"post_id":"cky03p47p00030cum9lu9bgw2","category_id":"cky03p47s00040cuma195cfb2","_id":"cky03p492000w0cum5svtftp0"},{"post_id":"cky03p47x00070cum2thybj1g","category_id":"cky03p47s00040cuma195cfb2","_id":"cky03p493000y0cum00fl1hot"},{"post_id":"cky03p48100090cum1xdlgn8p","category_id":"cky03p490000r0cumc5ydbecm","_id":"cky03p49500120cumfqvkh9bt"},{"post_id":"cky03p48e000h0cumdeebbqmv","category_id":"cky03p490000r0cumc5ydbecm","_id":"cky03p49600140cum1q96heb3"},{"post_id":"cky03p49s001d0cumdx5u14dx","category_id":"cky03p47s00040cuma195cfb2","_id":"cky03p49t001g0cum8qi07por"}],"PostTag":[{"post_id":"cky03p489000f0cumctz4eolr","tag_id":"cky03p47u00050cumdopocdst","_id":"cky03p48x000l0cum88mvaodc"},{"post_id":"cky03p489000f0cumctz4eolr","tag_id":"cky03p485000d0cum06rwdtzf","_id":"cky03p48z000p0cum4yfl28bo"},{"post_id":"cky03p47j00010cumergrcm09","tag_id":"cky03p47u00050cumdopocdst","_id":"cky03p491000u0cumhlm75n9v"},{"post_id":"cky03p47j00010cumergrcm09","tag_id":"cky03p485000d0cum06rwdtzf","_id":"cky03p493000x0cumht8hb330"},{"post_id":"cky03p47p00030cum9lu9bgw2","tag_id":"cky03p48w000k0cumgaw80397","_id":"cky03p49400110cumf3axgiyn"},{"post_id":"cky03p47x00070cum2thybj1g","tag_id":"cky03p47u00050cumdopocdst","_id":"cky03p49700160cum02333uyw"},{"post_id":"cky03p47x00070cum2thybj1g","tag_id":"cky03p485000d0cum06rwdtzf","_id":"cky03p49700170cum2hr9cw97"},{"post_id":"cky03p47x00070cum2thybj1g","tag_id":"cky03p49500130cumed491598","_id":"cky03p49700190cum2vhxgbi6"},{"post_id":"cky03p483000b0cumfey86ehe","tag_id":"cky03p47u00050cumdopocdst","_id":"cky03p498001a0cum81ur11z8"},{"post_id":"cky03p483000b0cumfey86ehe","tag_id":"cky03p485000d0cum06rwdtzf","_id":"cky03p498001b0cumehje3nz6"},{"post_id":"cky03p48e000h0cumdeebbqmv","tag_id":"cky03p49700180cumf2mc1uz8","_id":"cky03p499001c0cum4r11fh2h"},{"post_id":"cky03p49s001d0cumdx5u14dx","tag_id":"cky03p47u00050cumdopocdst","_id":"cky03p49t001e0cum9p4lejoy"},{"post_id":"cky03p49s001d0cumdx5u14dx","tag_id":"cky03p485000d0cum06rwdtzf","_id":"cky03p49t001f0cum4eo5eaox"}],"Tag":[{"name":"java","_id":"cky03p47u00050cumdopocdst"},{"name":"基础","_id":"cky03p485000d0cum06rwdtzf"},{"name":"Github","_id":"cky03p48w000k0cumgaw80397"},{"name":"进制","_id":"cky03p49500130cumed491598"},{"name":"书籍","_id":"cky03p49700180cumf2mc1uz8"}]}}